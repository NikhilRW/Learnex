(node:20204) ESLintRCWarning: You are using an eslintrc configuration file, which is deprecated and support will be removed in v10.0.0. Please migrate to an eslint.config.js file. See https://eslint.org/docs/latest/use/configure/migration-guide for details. An eslintrc configuration file is used because you have the ESLINT_USE_FLAT_CONFIG environment variable set to false. If you want to use an eslint.config.js file, remove the environment variable. If you want to find the location of the eslintrc configuration file, use the --debug flag.
[{"filePath":"D:\\Capstone_Project\\Learnex\\src\\App.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'StatusBar' is defined but never used.","line":25,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useTypedSelector' is defined but never used.","line":26,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fcmInitialized' is assigned a value but never used.","line":212,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":212,"endColumn":33}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has an unnecessary dependency: 'getMessaging'. Either exclude it or remove the dependency array. Outer scope values like 'getMessaging' aren't valid dependencies because mutating them doesn't re-render the component.","line":275,"column":6,"nodeType":"ArrayExpression","endLine":275,"endColumn":55,"suggestions":[{"desc":"Update the dependencies array to be: [navigationRef, permissionsGranted]","fix":{"range":[10579,10628],"text":"[navigationRef, permissionsGranted]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, {useEffect, useState} from 'react';\r\nimport {Platform, Linking, Alert, PermissionsAndroid} from 'react-native';\r\nimport SplashScreen from 'react-native-splash-screen';\r\nimport Route from 'shared/navigation/routes/Route';\r\nimport {Provider} from 'react-redux';\r\nimport {persistor, store} from 'shared/store/store';\r\nimport 'react-native-gesture-handler';\r\nimport 'react-native-reanimated';\r\nimport {GestureHandlerRootView} from 'react-native-gesture-handler';\r\nimport {PersistGate} from 'redux-persist/integration/react';\r\nimport ThemeListener from 'shared/helpers/ThemeListener';\r\nimport Loader from 'auth/components/Loader';\r\nimport {SafeAreaProvider} from 'react-native-safe-area-context';\r\nimport {setDeepLink} from 'shared/reducers/DeepLink';\r\nimport {fetchHackathons} from 'shared/reducers/Hackathon';\r\nimport {\r\n  NavigationContainer,\r\n  useNavigationContainerRef,\r\n} from '@react-navigation/native';\r\nimport {DeepLinkHandler} from 'shared/services/DeepLinkHandler';\r\nimport {PushNotificationHandler} from 'shared/utils/PushNotificationHandler';\r\nimport {styles} from 'shared/styles/App';\r\nimport {getMessaging} from '@react-native-firebase/messaging';\r\nimport {changeIsLoggedIn} from './shared/reducers/User';\r\nimport {StatusBar} from 'react-native';\r\nimport {useTypedSelector} from './shared/hooks/redux/useTypedSelector';\r\n\r\n// Interface definition for deep link event\r\ninterface DeepLinkEvent {\r\n  url: string;\r\n}\r\n\r\n// Interface for subscription returned by Linking\r\ninterface LinkingSubscription {\r\n  remove: () => void;\r\n}\r\n// globalThis.RNFB_SILENCE_MODULAR_DEPRECATION_WARNINGS = true;\r\n\r\nconst App = () => {\r\n  const navigationRef = useNavigationContainerRef();\r\n  const [permissionsGranted, setPermissionsGranted] = useState<boolean | null>(\r\n    null,\r\n  );\r\n\r\n  \r\n\r\n  // Check and request all required permissions\r\n  useEffect(() => {\r\n    const requestAllPermissions = async () => {\r\n      try {\r\n        // For Android 13+ (API 33+), request notification permissions explicitly\r\n        if (Platform.OS === 'android' && Platform.Version >= 33) {\r\n          const notificationPermission = await PermissionsAndroid.request(\r\n            PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS,\r\n            {\r\n              title: 'Notification Permission',\r\n              message:\r\n                'This app needs notification permission to send you updates',\r\n              buttonNeutral: 'Ask Me Later',\r\n              buttonNegative: 'Cancel',\r\n              buttonPositive: 'OK',\r\n            },\r\n          );\r\n\r\n          if (notificationPermission !== PermissionsAndroid.RESULTS.GRANTED) {\r\n            Alert.alert(\r\n              'Notifications Disabled',\r\n              \"You won't receive important notifications. You can enable them in app settings later.\",\r\n              [{text: 'OK'}],\r\n            );\r\n          }\r\n        }\r\n\r\n        // Request other permissions individually to avoid TypeScript errors\r\n        let allPermissionsGranted = true;\r\n\r\n        if (Platform.OS === 'android') {\r\n          // Request camera permission if needed\r\n          if (PermissionsAndroid.PERMISSIONS.CAMERA) {\r\n            const cameraPermission = await PermissionsAndroid.request(\r\n              PermissionsAndroid.PERMISSIONS.CAMERA,\r\n              {\r\n                title: 'Camera Permission',\r\n                message: 'This app needs camera access',\r\n                buttonNeutral: 'Ask Me Later',\r\n                buttonNegative: 'Cancel',\r\n                buttonPositive: 'OK',\r\n              },\r\n            );\r\n\r\n            if (cameraPermission !== PermissionsAndroid.RESULTS.GRANTED) {\r\n              allPermissionsGranted = false;\r\n              console.warn('Camera permission not granted');\r\n            }\r\n          }\r\n\r\n          // Request storage permissions if needed\r\n          if (PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE) {\r\n            const writeStoragePermission = await PermissionsAndroid.request(\r\n              PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE,\r\n              {\r\n                title: 'Storage Permission',\r\n                message: 'This app needs access to save files',\r\n                buttonNeutral: 'Ask Me Later',\r\n                buttonNegative: 'Cancel',\r\n                buttonPositive: 'OK',\r\n              },\r\n            );\r\n\r\n            if (writeStoragePermission !== PermissionsAndroid.RESULTS.GRANTED) {\r\n              allPermissionsGranted = false;\r\n              console.warn('Write storage permission not granted');\r\n            }\r\n          }\r\n\r\n          // Request microphone permission if needed\r\n          if (PermissionsAndroid.PERMISSIONS.RECORD_AUDIO) {\r\n            const micPermission = await PermissionsAndroid.request(\r\n              PermissionsAndroid.PERMISSIONS.RECORD_AUDIO,\r\n              {\r\n                title: 'Microphone Permission',\r\n                message: 'This app needs microphone access',\r\n                buttonNeutral: 'Ask Me Later',\r\n                buttonNegative: 'Cancel',\r\n                buttonPositive: 'OK',\r\n              },\r\n            );\r\n\r\n            if (micPermission !== PermissionsAndroid.RESULTS.GRANTED) {\r\n              allPermissionsGranted = false;\r\n              console.warn('Microphone permission not granted');\r\n            }\r\n          }\r\n\r\n          if (!allPermissionsGranted) {\r\n            console.warn('Not all permissions were granted');\r\n          }\r\n        }\r\n\r\n        // Also use the PushNotificationHandler's permission check for iOS\r\n        const hasNotificationPermission =\r\n          await PushNotificationHandler.checkPermissions();\r\n\r\n        // We'll consider permissions granted if either the notification permission is granted\r\n        // or we're on Android and have dealt with the permissions above\r\n        const isGranted =\r\n          hasNotificationPermission || Platform.OS === 'android';\r\n        setPermissionsGranted(isGranted);\r\n\r\n        if (!isGranted && Platform.OS === 'ios') {\r\n          Alert.alert(\r\n            'Permissions Required',\r\n            'This app requires notification permissions to function properly. Please grant permissions in your device settings.',\r\n            [{text: 'OK'}],\r\n          );\r\n        }\r\n      } catch (error) {\r\n        console.error('Error requesting permissions:', error);\r\n        // Continue with app initialization even if permission requests fail\r\n        setPermissionsGranted(false);\r\n      }\r\n    };\r\n    setTimeout(() => {\r\n      requestAllPermissions();\r\n    }, 1000);\r\n  }, []);\r\n\r\n  // Main initialization effect - only runs after permission check\r\n  useEffect(() => {\r\n    // Don't initialize until permission check is complete\r\n    if (permissionsGranted === null) return;\r\n\r\n    if (Platform.OS === 'android') {\r\n      SplashScreen.hide();\r\n    }\r\n\r\n    // Configure deep links with navigation reference\r\n    DeepLinkHandler.configureDeepLinks(navigationRef);\r\n\r\n    // Load hackathon data on app startup - always use 'India' as location\r\n    store.dispatch(fetchHackathons({location: 'India'}));\r\n\r\n    // Configure notification channels right away regardless of permission status\r\n    // This doesn't need permissions and won't crash\r\n    PushNotificationHandler.configureChannels();\r\n\r\n    // Only initialize services that require permissions if permissions were granted\r\n    if (permissionsGranted) {\r\n      // Set up message handlers for FCM\r\n      PushNotificationHandler.setupMessageHandlers();\r\n\r\n      // Initialize notification service during app startup\r\n      const initNotifications = async () => {\r\n        try {\r\n          const notificationService =\r\n            require('shared/services/NotificationService').default;\r\n          await notificationService.setupNotificationChannels();\r\n\r\n          // Set up background notification handlers\r\n          notificationService.setupBackgroundHandler();\r\n\r\n          // If user is already logged in, set up the message and task listeners\r\n          const {getAuth} = require('@react-native-firebase/auth');\r\n          if (getAuth().currentUser) {\r\n            console.log(\r\n              'User already logged in, setting up notification listeners',\r\n            );\r\n            notificationService.setupMessageListener();\r\n            notificationService.setupTaskNotificationListener();\r\n\r\n            // Initialize FCM\r\n            const fcmInitialized = await notificationService.initializeFCM();\r\n          } else {\r\n            changeIsLoggedIn(false);\r\n          }\r\n        } catch (error) {\r\n          console.error('Failed to initialize notification service:', error);\r\n        }\r\n      };\r\n      initNotifications();\r\n    }\r\n\r\n    // Set up deep link handler\r\n    const handleDeepLink = (event: DeepLinkEvent) => {\r\n      const {url} = event;\r\n      if (url) {\r\n        // Store the URL in Redux for later use\r\n        store.dispatch(setDeepLink(url));\r\n      }\r\n    };\r\n\r\n    // Set up listeners for deep links - handle API differences in React Native versions\r\n    let subscription: LinkingSubscription | undefined;\r\n    if (Linking.addEventListener) {\r\n      // Modern React Native (>=0.65)\r\n      subscription = Linking.addEventListener('url', handleDeepLink);\r\n    } else {\r\n      // Older React Native with deprecated API\r\n      // @ts-ignore - We need this for backwards compatibility\r\n      Linking.addEventListener('url', handleDeepLink);\r\n    }\r\n\r\n    // Check for initial URL (app opened via deep link)\r\n    Linking.getInitialURL().then(url => {\r\n      if (url) {\r\n        console.log('App opened with URL:', url);\r\n        store.dispatch(setDeepLink(url));\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      // Clean up the event listener - handle API differences\r\n      if (subscription) {\r\n        // Modern React Native with subscription object\r\n        subscription.remove();\r\n      } else {\r\n        // For older React Native versions\r\n        // @ts-ignore - removeEventListener is not in the type definitions but may exist in older RN versions\r\n        Linking.removeEventListener('url', handleDeepLink);\r\n      }\r\n\r\n      // Clean up notification listeners if needed\r\n      if (permissionsGranted) {\r\n        try {\r\n          const notificationService =\r\n            require('shared/services/NotificationService').default;\r\n          notificationService.removeMessageListener();\r\n          notificationService.removeTaskListener();\r\n        } catch (error) {\r\n          console.error('Failed to clean up notification listeners:', error);\r\n        }\r\n      }\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [navigationRef, permissionsGranted, getMessaging]);\r\n\r\n\r\n  return (\r\n    <>\r\n      <GestureHandlerRootView style={styles.flex1}>\r\n        <SafeAreaProvider>\r\n          <Provider store={store}>\r\n            <PersistGate loading={<Loader />} persistor={persistor}>\r\n              <ThemeListener />\r\n              <NavigationContainer\r\n                ref={navigationRef}\r\n                onReady={() => {\r\n                  DeepLinkHandler.checkPendingNavigation();\r\n                }}>\r\n                <Route />\r\n              </NavigationContainer>\r\n            </PersistGate>\r\n          </Provider>\r\n        </SafeAreaProvider>\r\n      </GestureHandlerRootView>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\components\\ButtonLoader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\components\\ErrorMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\components\\Loader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\components\\OAuthButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\schema\\yupSchemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\screens\\LinkedInAuth.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'a' is defined but never used.","line":63,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":63,"endColumn":8},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  flex: 1,\n  height: '100%',\n  position: 'absolute',\n  zIndex: 1000,\n  width: '100%',\n  top: 0,\n  left: 0\n}","line":70,"column":16,"nodeType":"ObjectExpression","endLine":78,"endColumn":10}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\r\nimport React, { useRef } from 'react';\r\nimport { View } from 'react-native';\r\nimport Config from 'react-native-config';\r\nimport WebView from 'react-native-webview';\r\nimport { ShouldStartLoadRequest } from 'react-native-webview/lib/WebViewTypes';\r\nimport { useTypedSelector } from 'hooks/redux/useTypedSelector';\r\nimport Snackbar from 'react-native-snackbar';\r\nimport { useTypedDispatch } from 'hooks/redux/useTypedDispatch';\r\nimport { changeIsLoggedIn, changeProfileColor } from 'shared/reducers/User';\r\nimport { getRandomColors } from 'shared/helpers/common/stringHelpers';\r\n\r\nconst LinkedInAuth = () => {\r\n  const ref = useRef<WebView>(null);\r\n  const firebase = useTypedSelector(state => state.firebase.firebase);\r\n  const dispatch = useTypedDispatch();\r\n\r\n  const handleURIChange = (event: ShouldStartLoadRequest) => {\r\n    if (event.url.includes('code=')) {\r\n      handleDeepLink(event.url);\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  };\r\n  const handleDeepLink = async (url: string) => {\r\n    const authenticationCode = new URL(url).searchParams.get('code');\r\n    const response = await axios.post(\r\n      'https://www.linkedin.com/oauth/v2/accessToken',\r\n      {\r\n        grant_type: 'authorization_code',\r\n        code: authenticationCode,\r\n        client_id: Config.LINKEDIN_CLIENT_ID!,\r\n        client_secret: Config.LINKEDIN_CLIENT_SECRET!,\r\n        redirect_uri: 'https://learnex-web.vercel.app/auth/linkedin/sign-in',\r\n      },\r\n      {\r\n        headers: {\r\n          'Content-Type': 'application/x-www-form-urlencoded',\r\n        },\r\n      },\r\n    );\r\n    if (response.data.access_token !== null) {\r\n      const { success, error } = await firebase.auth.linkedinSignIn(\r\n        response.data.access_token,\r\n      );\r\n      if (success) {\r\n        dispatch(changeProfileColor(getRandomColors()));\r\n        dispatch(changeIsLoggedIn(true));\r\n      } else {\r\n        Snackbar.show({\r\n          text: 'Login Unsuccessful Due To : ' + error,\r\n          duration: Snackbar.LENGTH_LONG,\r\n          textColor: 'white',\r\n          backgroundColor: '#007cb5',\r\n        });\r\n        console.log(error);\r\n      }\r\n    } else {\r\n      Snackbar.show({ text: 'LinkedIn Authentication Failed' });\r\n    }\r\n  };\r\n  let a;\r\n  return (\r\n    <View className=\"flex-1\">\r\n      <WebView\r\n        source={{\r\n          uri: 'https://www.linkedin.com/oauth/v2/authorization?redirect_uri=https%3A%2F%2Flearnex-web.vercel.app%2Fauth%2Flinkedin%2Fsign-in&client_id=782j1d8cgc8xaw&response_type=code&scope=email%20profile',\r\n        }}\r\n        style={{\r\n          flex: 1,\r\n          height: '100%',\r\n          position: 'absolute',\r\n          zIndex: 1000,\r\n          width: '100%',\r\n          top: 0,\r\n          left: 0,\r\n        }}\r\n        ref={ref}\r\n        onShouldStartLoadWithRequest={handleURIChange}\r\n      />\r\n    </View>\r\n  );\r\n};\r\n\r\nexport default LinkedInAuth;\r\n\r\n// In The SignIn.tsx\r\n// <TouchableOpacity\r\n//                       disabled={isLinkedInLoading || isSubmitting}\r\n//                       onPress={handleLinkedInSignIn}\r\n//                       style={{\r\n//                         width: 38,\r\n//                         height: 38,\r\n//                         justifyContent: 'center',\r\n//                         alignItems: 'center',\r\n//                         backgroundColor: '#0066C8',\r\n//                         borderRadius: 30,\r\n//                       }}>\r\n//                       {isLinkedInLoading ? (\r\n//                         <>{/* <ButtonLoader /> */}</>\r\n//                       ) : (\r\n//                         <Image\r\n//                           source={require('shared/res/webp/linkedin.webp')}\r\n//                           style={{\r\n//                             width: 38,\r\n//                             height: 38,\r\n//                             borderRadius: 30,\r\n//                             marginBottom: 1.5,\r\n//                           }}\r\n//                         />\r\n//                       )}\r\n//                     </TouchableOpacity>\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\screens\\SignIn.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\screens\\SignUp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\styles\\ButtonLoader.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\styles\\ErrorMessage.style.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\styles\\Loader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\styles\\OAuthButton.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\styles\\SignIn.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Auth\\styles\\SignUp.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\components\\ChatHeaderLeft.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\components\\ChatHeaderRight.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\components\\ChatInputBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\components\\EditMessageInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\components\\LoadingOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\components\\MessageContextMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\components\\MessageItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\components\\MessageSuggestions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\models\\Message.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\screens\\Chat.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useCallback has a missing dependency: 'handleMessageLongPress'. Either include it or remove the dependency array.","line":437,"column":5,"nodeType":"ArrayExpression","endLine":437,"endColumn":31,"suggestions":[{"desc":"Update the dependencies array to be: [isDark, currentUser?.uid, handleMessageLongPress]","fix":{"range":[14187,14213],"text":"[isDark, currentUser?.uid, handleMessageLongPress]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\screens\\ContactList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\screens\\Conversations.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has a missing dependency: 'messageService'. Either include it or remove the dependency array.","line":59,"column":6,"nodeType":"ArrayExpression","endLine":59,"endColumn":19,"suggestions":[{"desc":"Update the dependencies array to be: [currentUser, messageService]","fix":{"range":[2409,2422],"text":"[currentUser, messageService]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'handleConversationPress' is assigned a value but never used.","line":92,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":92,"endColumn":32}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\r\nimport {\r\n  View,\r\n  Text,\r\n  TouchableOpacity,\r\n  ActivityIndicator,\r\n  RefreshControl,\r\n  Alert,\r\n  Platform,\r\n} from 'react-native';\r\nimport { Avatar, SearchBar } from 'react-native-elements';\r\nimport { useTypedSelector } from 'hooks/redux/useTypedSelector';\r\nimport { useNavigation } from '@react-navigation/native';\r\nimport { NavigationProp } from '@react-navigation/native';\r\nimport { UserStackParamList } from 'shared/navigation/routes/UserStack';\r\nimport { MessageService } from 'conversations/services/MessageService';\r\nimport { Conversation } from 'conversations/models/Message';\r\nimport Ionicons from 'react-native-vector-icons/Ionicons';\r\nimport MaterialIcons from 'react-native-vector-icons/MaterialIcons';\r\nimport { SwipeListView } from 'react-native-swipe-list-view';\r\nimport { SafeAreaView } from 'react-native-safe-area-context';\r\nimport { formatDistanceToNow } from 'date-fns';\r\nimport { getUsernameForLogo } from 'shared/helpers/common/stringHelpers';\r\nimport Snackbar from 'react-native-snackbar';\r\nimport { styles } from 'conversations/styles/Conversations';\r\nimport { SCREEN_WIDTH } from 'shared/constants/common';\r\n\r\n// TODO: refactor the component logic into hook.\r\n\r\nconst ConversationsScreen: React.FC = () => {\r\n  const navigation = useNavigation<NavigationProp<UserStackParamList>>();\r\n  // const insets = useSafeAreaInsets();\r\n  const isDark = useTypedSelector(state => state.user.theme) === 'dark';\r\n  const firebase = useTypedSelector(state => state.firebase.firebase);\r\n  const currentUser = firebase.currentUser();\r\n  //const reduxUserPhoto = useTypedSelector(state => state.user.userPhoto);\r\n  const [conversations, setConversations] = useState<Conversation[]>([]);\r\n  const [filteredConversations, setFilteredConversations] = useState<\r\n    Conversation[]\r\n  >([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [search, setSearch] = useState('');\r\n  const [refreshing, setRefreshing] = useState(false);\r\n  const messageService = new MessageService();\r\n\r\n  useEffect(() => {\r\n    if (!currentUser) return;\r\n\r\n    const unsubscribe = messageService.listenToConversations(\r\n      currentUser.uid,\r\n      newConversations => {\r\n        setConversations(newConversations);\r\n        setFilteredConversations(newConversations);\r\n        setLoading(false);\r\n      },\r\n    );\r\n\r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n\r\n  useEffect(() => {\r\n    if (search.trim() === '') {\r\n      setFilteredConversations(conversations);\r\n    } else {\r\n      const searchLower = search.toLowerCase();\r\n      const filtered = conversations.filter(conversation => {\r\n        const otherParticipantId = conversation.participants.find(\r\n          id => id !== currentUser?.uid,\r\n        );\r\n        if (!otherParticipantId) return false;\r\n\r\n        const otherParticipantDetails =\r\n          conversation.participantDetails[otherParticipantId];\r\n        return otherParticipantDetails.name.toLowerCase().includes(searchLower);\r\n      });\r\n      setFilteredConversations(filtered);\r\n    }\r\n  }, [search, conversations, currentUser]);\r\n\r\n  const onRefresh = async () => {\r\n    setRefreshing(true);\r\n    // The listener will automatically update, but we'll wait briefly for visual feedback\r\n    setTimeout(() => {\r\n      setRefreshing(false);\r\n    }, 1000);\r\n  };\r\n\r\n  const handleNewMessage = () => {\r\n    navigation.navigate('ContactList');\r\n  };\r\n\r\n  const handleConversationPress = (conversation: Conversation) => {\r\n    const otherParticipantId = conversation.participants.find(\r\n      id => id !== currentUser?.uid,\r\n    );\r\n    if (!otherParticipantId) return;\r\n\r\n    navigation.navigate('Chat', {\r\n      conversationId: conversation.id,\r\n      recipientId: otherParticipantId,\r\n      recipientName: conversation.participantDetails[otherParticipantId].name,\r\n      recipientPhoto: conversation.participantDetails[otherParticipantId].image,\r\n      isQrInitiated: false,\r\n    });\r\n  };\r\n\r\n  // Handle conversation deletion\r\n  const handleDeleteConversation = async (conversationId: string) => {\r\n    try {\r\n      // Show confirmation dialog\r\n      if (Platform.OS === 'ios' || Platform.OS === 'android') {\r\n        Alert.alert(\r\n          'Delete Conversation',\r\n          'Are you sure you want to delete this conversation? This action cannot be undone.',\r\n          [\r\n            { text: 'Cancel', style: 'cancel' },\r\n            {\r\n              text: 'Delete',\r\n              style: 'destructive',\r\n              onPress: async () => {\r\n                try {\r\n                  Snackbar.show({\r\n                    text: 'Deleting conversation...',\r\n                    duration: Snackbar.LENGTH_INDEFINITE,\r\n                  });\r\n\r\n                  await messageService.deleteConversation(conversationId);\r\n\r\n                  Snackbar.dismiss();\r\n                  Snackbar.show({\r\n                    text: 'Conversation deleted successfully',\r\n                    duration: Snackbar.LENGTH_SHORT,\r\n                    backgroundColor: '#4CAF50',\r\n                  });\r\n                } catch (error) {\r\n                  console.error('Error deleting conversation:', error);\r\n                  Snackbar.show({\r\n                    text: 'Failed to delete conversation',\r\n                    duration: Snackbar.LENGTH_LONG,\r\n                    backgroundColor: '#F44336',\r\n                  });\r\n                }\r\n              },\r\n            },\r\n          ],\r\n        );\r\n      }\r\n    } catch (error) {\r\n      console.error('Error deleting conversation:', error);\r\n      Snackbar.show({\r\n        text: 'Failed to delete conversation',\r\n        duration: Snackbar.LENGTH_LONG,\r\n        backgroundColor: '#F44336',\r\n      });\r\n    }\r\n  };\r\n\r\n  const renderEmptyList = () => (\r\n    <View style={styles.emptyContainer}>\r\n      {loading ? (\r\n        <ActivityIndicator size=\"large\" color=\"#2379C2\" />\r\n      ) : (\r\n        <>\r\n          <MaterialIcons\r\n            name=\"chat-bubble-outline\"\r\n            size={80}\r\n            color={isDark ? '#555' : '#ccc'}\r\n          />\r\n          <Text style={[styles.emptyText, isDark ? styles.darkEmptyText : styles.lightEmptyText]}>\r\n            No conversations yet\r\n          </Text>\r\n          <Text\r\n            style={[styles.emptySubText, isDark ? styles.darkEmptySubText : styles.lightEmptySubText]}>\r\n            Start messaging with your peers\r\n          </Text>\r\n          <TouchableOpacity\r\n            style={[styles.newMessageButton, styles.emptyButtonMarginTop]}\r\n            onPress={handleNewMessage}>\r\n            <Text style={styles.newMessageButtonText}>Start New Chat</Text>\r\n          </TouchableOpacity>\r\n        </>\r\n      )}\r\n    </View>\r\n  );\r\n\r\n  const renderConversationItem = ({ item }: { item: Conversation }) => {\r\n    const otherParticipantId = item.participants.find(\r\n      id => id !== currentUser?.uid,\r\n    );\r\n    if (!otherParticipantId) return null;\r\n\r\n    const otherParticipant = item.participantDetails[otherParticipantId];\r\n    const isUnread =\r\n      item.unreadCount && item.unreadCount[currentUser?.uid || ''] > 0;\r\n    const lastMessageTime = item.lastMessage?.timestamp\r\n      ? formatDistanceToNow(new Date(item.lastMessage.timestamp), {\r\n        addSuffix: true,\r\n      })\r\n      : '';\r\n\r\n    return (\r\n      <TouchableOpacity\r\n        style={[\r\n          styles.conversationItem,\r\n          isDark\r\n            ? isUnread ? styles.darkUnreadConversationItem : styles.darkConversationItem\r\n            : isUnread ? styles.lightUnreadConversationItem : styles.lightConversationItem,\r\n        ]}\r\n        onPress={() => {\r\n          navigation.navigate('Chat', {\r\n            conversationId: item.id,\r\n            recipientId: otherParticipantId,\r\n            recipientName: otherParticipant.name,\r\n            recipientPhoto: otherParticipant.image,\r\n            isQrInitiated: false,\r\n          });\r\n        }}>\r\n        {otherParticipant.image ? (\r\n          <Avatar\r\n            rounded\r\n            source={{ uri: otherParticipant.image }}\r\n            size={Math.min(SCREEN_WIDTH * 0.12, 50)}\r\n            containerStyle={styles.avatar}\r\n          />\r\n        ) : (\r\n          <Avatar\r\n            rounded\r\n            title={getUsernameForLogo(otherParticipant.name)}\r\n            size={Math.min(SCREEN_WIDTH * 0.12, 50)}\r\n            containerStyle={[styles.avatar, styles.avatarPlaceholderBg]}\r\n          />\r\n        )}\r\n\r\n        <View style={styles.conversationDetails}>\r\n          <View style={styles.conversationHeader}>\r\n            <Text\r\n              style={[\r\n                styles.participantName,\r\n                isDark ? styles.darkParticipantName : styles.lightParticipantName,\r\n                isUnread && styles.unreadParticipantName,\r\n              ]}\r\n              numberOfLines={1}>\r\n              {otherParticipant.name}\r\n            </Text>\r\n            <Text style={[styles.timeText, isDark ? styles.darkTimeText : styles.lightTimeText]}>\r\n              {lastMessageTime}\r\n            </Text>\r\n          </View>\r\n\r\n          <View style={styles.lastMessageContainer}>\r\n            {otherParticipant.typing ? (\r\n              <Text style={[styles.typingText, styles.typingHighlight]}>\r\n                typing...\r\n              </Text>\r\n            ) : (\r\n              <Text\r\n                style={[\r\n                  styles.lastMessageText,\r\n                  isDark\r\n                    ? isUnread ? styles.darkUnreadMessageText : styles.darkReadMessageText\r\n                    : isUnread ? styles.lightUnreadMessageText : styles.lightReadMessageText,\r\n                ]}\r\n                numberOfLines={1}\r\n                ellipsizeMode=\"tail\">\r\n                {item.lastMessage?.text || 'No messages yet'}\r\n              </Text>\r\n            )}\r\n\r\n            {isUnread && (\r\n              <View style={styles.unreadBadge}>\r\n                <Text style={styles.unreadCount}>\r\n                  {currentUser && item.unreadCount\r\n                    ? item.unreadCount[currentUser.uid] || 0\r\n                    : 0}\r\n                </Text>\r\n              </View>\r\n            )}\r\n          </View>\r\n        </View>\r\n      </TouchableOpacity>\r\n    );\r\n  };\r\n\r\n  // Render hidden item with delete action\r\n  const renderHiddenItem = ({ item }: { item: Conversation }) => (\r\n    <View\r\n      style={[\r\n        styles.rowBack,\r\n        isDark ? styles.darkRowBack : styles.lightRowBack,\r\n      ]}>\r\n      <TouchableOpacity\r\n        style={[styles.deleteButton]}\r\n        onPress={() => handleDeleteConversation(item.id)}>\r\n        <MaterialIcons name=\"delete\" size={24} color=\"#ffffff\" />\r\n        <Text style={styles.deleteButtonText}>Delete</Text>\r\n      </TouchableOpacity>\r\n    </View>\r\n  );\r\n\r\n  return (\r\n    <SafeAreaView\r\n      style={[\r\n        styles.container,\r\n        isDark ? styles.darkContainer : styles.lightContainer,\r\n      ]}>\r\n      <View style={styles.header}>\r\n        <Text style={[styles.title, isDark ? styles.darkText : styles.lightText]}>\r\n          Messages\r\n        </Text>\r\n        <TouchableOpacity\r\n          style={styles.newMessageButtonSmall}\r\n          onPress={handleNewMessage}>\r\n          <Ionicons\r\n            name=\"create-outline\"\r\n            size={Math.min(SCREEN_WIDTH * 0.06, 24)}\r\n            color=\"white\"\r\n          />\r\n        </TouchableOpacity>\r\n      </View>\r\n\r\n      {/* @ts-ignore */}\r\n      <SearchBar\r\n        placeholder=\"Search conversations...\"\r\n        onChangeText={(text: string = '') => setSearch(text)}\r\n        value={search}\r\n        containerStyle={[\r\n          styles.searchContainer,\r\n          isDark ? styles.darkSearchBackground : styles.lightSearchBackground,\r\n        ]}\r\n        inputContainerStyle={[\r\n          styles.searchInputContainer,\r\n          isDark ? styles.darkSearchInputBackground : styles.lightSearchInputBackground,\r\n        ]}\r\n        inputStyle={isDark ? styles.darkText : styles.lightText}\r\n        placeholderTextColor={isDark ? '#aaa' : '#999'}\r\n        round\r\n        lightTheme={!isDark}\r\n      />\r\n\r\n      {filteredConversations.length === 0 ? (\r\n        renderEmptyList()\r\n      ) : (\r\n        <SwipeListView\r\n          data={filteredConversations}\r\n          renderItem={renderConversationItem}\r\n          renderHiddenItem={renderHiddenItem}\r\n          keyExtractor={item => item.id}\r\n          rightOpenValue={-75}\r\n          disableRightSwipe\r\n          contentContainerStyle={[\r\n            styles.listContent,\r\n            filteredConversations.length === 0 && styles.emptyListContent,\r\n          ]}\r\n          refreshControl={\r\n            <RefreshControl\r\n              refreshing={refreshing}\r\n              onRefresh={onRefresh}\r\n              colors={['#2379C2']}\r\n              tintColor={isDark ? '#2379C2' : '#2379C2'}\r\n            />\r\n          }\r\n        />\r\n      )}\r\n    </SafeAreaView>\r\n  );\r\n};\r\n\r\nexport default ConversationsScreen;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\services\\MessageService.ts","messages":[{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 4 column 3.","line":83,"column":65,"nodeType":"Identifier","messageId":"noShadow","endLine":83,"endColumn":68},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 4 column 3.","line":425,"column":49,"nodeType":"Identifier","messageId":"noShadow","endLine":425,"endColumn":52},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 4 column 3.","line":462,"column":39,"nodeType":"Identifier","messageId":"noShadow","endLine":462,"endColumn":42},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 4 column 3.","line":526,"column":35,"nodeType":"Identifier","messageId":"noShadow","endLine":526,"endColumn":38},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 4 column 3.","line":664,"column":37,"nodeType":"Identifier","messageId":"noShadow","endLine":664,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  getFirestore,\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  setDoc,\r\n  updateDoc,\r\n  deleteDoc,\r\n  addDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  getDocs,\r\n  onSnapshot,\r\n  increment,\r\n  writeBatch,\r\n  FirebaseFirestoreTypes,\r\n  limit as fs_limit,\r\n} from '@react-native-firebase/firestore';\r\nimport {Conversation, Message} from 'conversations/models/Message';\r\nimport {FirebaseErrorHandler} from 'shared/helpers/firebase/FirebaseErrorHandler';\r\nimport notificationService from 'shared/services/NotificationService';\r\nimport Config from 'react-native-config';\r\nimport {getAuth} from '@react-native-firebase/auth';\r\n\r\n// Configure backend URL for sending push notifications\r\nconst BACKEND_URL = Config.BACKEND_URL || 'https://learnex-backend.vercel.app';\r\n\r\n/**\r\n * Helper function to clean objects before storing in Firestore\r\n * Removes undefined values which Firestore doesn't allow\r\n */\r\nconst sanitizeForFirestore = (obj: any): any => {\r\n  if (obj === null || obj === undefined || typeof obj !== 'object') {\r\n    return obj;\r\n  }\r\n\r\n  // Handle arrays\r\n  if (Array.isArray(obj)) {\r\n    return obj.map(item => sanitizeForFirestore(item));\r\n  }\r\n\r\n  // Handle objects\r\n  const sanitized: Record<string, any> = {};\r\n  for (const [key, value] of Object.entries(obj)) {\r\n    if (value !== undefined) {\r\n      sanitized[key] = sanitizeForFirestore(value);\r\n    }\r\n  }\r\n  return sanitized;\r\n};\r\n\r\nexport class MessageService {\r\n  messagesCollection = collection(\r\n    getFirestore(),\r\n    'messages',\r\n  ) as FirebaseFirestoreTypes.CollectionReference<Message>;\r\n  private conversationsCollection = collection(\r\n    getFirestore(),\r\n    'conversations',\r\n  ) as FirebaseFirestoreTypes.CollectionReference<Conversation>;\r\n  private userCollection = collection(\r\n    getFirestore(),\r\n    'users',\r\n  ) as FirebaseFirestoreTypes.CollectionReference<any>;\r\n  private errorHandler = new FirebaseErrorHandler();\r\n\r\n  // Create or get a conversation between two users\r\n  async getOrCreateConversation(\r\n    userId1: string,\r\n    userId2: string,\r\n  ): Promise<Conversation> {\r\n    try {\r\n      // Query for existing conversation\r\n      const conversationsQuery = await getDocs(\r\n        query(\r\n          this.conversationsCollection,\r\n          where('participants', 'array-contains', userId1),\r\n        ),\r\n      );\r\n\r\n      // Find conversation with both participants\r\n      const existingConversation = conversationsQuery.docs.find(doc => {\r\n        const data = doc.data() as Conversation;\r\n        return data.participants.includes(userId2);\r\n      });\r\n\r\n      if (existingConversation) {\r\n        const conversationData = existingConversation.data() as Omit<\r\n          Conversation,\r\n          'id'\r\n        >;\r\n        return {\r\n          id: existingConversation.id,\r\n          ...conversationData,\r\n        };\r\n      }\r\n\r\n      // If no existing conversation, create a new one\r\n      // First get user details for both participants\r\n      const [user1Doc, user2Doc] = await Promise.all([\r\n        getDoc(doc(this.userCollection, userId1)),\r\n        getDoc(doc(this.userCollection, userId2)),\r\n      ]);\r\n\r\n      const user1Data = user1Doc.data() || {};\r\n      const user2Data = user2Doc.data() || {};\r\n\r\n      // Create participant details\r\n      const participantDetails: Conversation['participantDetails'] = {\r\n        [userId1]: {\r\n          name: user1Data.fullName || user1Data.username || 'User',\r\n          image: user1Data.image || null,\r\n          lastSeen: Date.now(),\r\n        },\r\n        [userId2]: {\r\n          name: user2Data.fullName || user2Data.username || 'User',\r\n          image: user2Data.image || null,\r\n          lastSeen: user2Data.lastSeen || null,\r\n        },\r\n      };\r\n\r\n      // Create new conversation\r\n      const newConversation: Omit<Conversation, 'id'> = {\r\n        participants: [userId1, userId2],\r\n        participantDetails,\r\n        unreadCount: {\r\n          [userId1]: 0,\r\n          [userId2]: 0,\r\n        },\r\n      };\r\n\r\n      // Sanitize to remove any undefined values\r\n      const sanitizedConversation = sanitizeForFirestore(newConversation);\r\n\r\n      const conversationRef = await addDoc(\r\n        this.conversationsCollection,\r\n        sanitizedConversation,\r\n      );\r\n      return {id: conversationRef.id, ...newConversation};\r\n    } catch (error) {\r\n      throw this.errorHandler.handleError(\r\n        error,\r\n        'Failed to create conversation',\r\n      );\r\n    }\r\n  }\r\n\r\n  // Send a new message\r\n  async sendMessage(\r\n    conversationId: string,\r\n    message: Omit<Message, 'id'>,\r\n    isQrInitiated: boolean = false,\r\n  ): Promise<Message> {\r\n    try {\r\n      // Check if conversation exists first\r\n      const conversationDoc = await getDoc(\r\n        doc(this.conversationsCollection, conversationId),\r\n      );\r\n      if (!conversationDoc.exists()) {\r\n        throw new Error(\r\n          `Conversation ${conversationId} not found. Cannot send message.`,\r\n        );\r\n      }\r\n\r\n      const messageRef = doc(this.messagesCollection);\r\n      const newMessage: Message = {\r\n        id: messageRef.id,\r\n        ...message,\r\n      };\r\n\r\n      // Sanitize to remove any undefined values\r\n      const sanitizedMessage = sanitizeForFirestore(newMessage);\r\n      await setDoc(messageRef, sanitizedMessage);\r\n\r\n      // Update conversation with last message\r\n      await updateDoc(doc(this.conversationsCollection, conversationId), {\r\n        lastMessage: {\r\n          text: message.text,\r\n          timestamp: message.timestamp,\r\n          senderId: message.senderId,\r\n          read: false,\r\n        },\r\n        [`unreadCount.${message.recipientId}`]: increment(1),\r\n      });\r\n\r\n      // Trigger a notification through the local NotificationService\r\n      // This works when the app is in foreground or background\r\n      try {\r\n        // Check if the message is sent by the current user and\r\n        // is intended for someone else (not self-messages)\r\n        const currentUserId = getAuth().currentUser?.uid;\r\n        const isSenderCurrentUser = message.senderId === currentUserId;\r\n        const isRecipientDifferent = message.recipientId !== currentUserId;\r\n\r\n        // Only send notification if the current user is sending to someone else\r\n        if (isSenderCurrentUser && isRecipientDifferent) {\r\n          // Make sure we have sender information for the notification\r\n          let senderName = message.senderName;\r\n          let senderPhoto = message.senderPhoto;\r\n\r\n          // If sender info is missing, try to get it from the current user\r\n          if (!senderName || !senderPhoto) {\r\n            try {\r\n              // Get current user info from Firestore\r\n              const currentUserDoc = await getDoc(\r\n                doc(collection(getFirestore(), 'users'), currentUserId),\r\n              );\r\n\r\n              if (currentUserDoc.exists()) {\r\n                const userData = currentUserDoc.data() || {};\r\n                senderName =\r\n                  senderName ||\r\n                  userData.fullName ||\r\n                  userData.username ||\r\n                  currentUserId;\r\n                senderPhoto =\r\n                  senderPhoto ||\r\n                  userData.photoURL ||\r\n                  userData.profilePicture ||\r\n                  userData.image;\r\n              }\r\n            } catch (err) {\r\n              console.log('Error getting current user data:', err);\r\n              // Continue with what we have\r\n            }\r\n          }\r\n\r\n          console.log('Sending notification with sender info:', {\r\n            senderName,\r\n            senderPhoto,\r\n            isQrInitiated,\r\n          });\r\n\r\n          // Send notification to the recipient via local service\r\n          await notificationService.displayMessageNotification(\r\n            message.senderId,\r\n            senderName || 'User',\r\n            message.text,\r\n            conversationId,\r\n            message.recipientId,\r\n            senderPhoto,\r\n            newMessage.id,\r\n            isQrInitiated,\r\n          );\r\n        }\r\n      } catch (err) {\r\n        console.error('Error sending local notification:', err);\r\n        // Continue even if notification fails - messaging functionality\r\n        // should work independently of notification delivery\r\n      }\r\n\r\n      // Send notification through your backend (optional)\r\n      try {\r\n        const otherUserId = message.recipientId;\r\n        const currentUser = getAuth().currentUser;\r\n\r\n        if (currentUser && otherUserId && otherUserId !== currentUser.uid) {\r\n          // Get current user info to ensure we have correct sender details\r\n          let senderName = message.senderName;\r\n          let senderPhoto = message.senderPhoto;\r\n\r\n          // If sender info is missing, try to get it\r\n          if (!senderName || !senderPhoto) {\r\n            try {\r\n              const currentUserDoc = await getDoc(\r\n                doc(collection(getFirestore(), 'users'), currentUser.uid),\r\n              );\r\n\r\n              if (currentUserDoc.exists()) {\r\n                const userData = currentUserDoc.data() || {};\r\n                senderName =\r\n                  senderName ||\r\n                  userData.fullName ||\r\n                  userData.username ||\r\n                  currentUser.uid;\r\n                senderPhoto =\r\n                  senderPhoto ||\r\n                  userData.photoURL ||\r\n                  userData.profilePicture ||\r\n                  userData.image;\r\n              }\r\n            } catch (err) {\r\n              console.log(\r\n                'Error getting current user data for backend notification:',\r\n                err,\r\n              );\r\n              // Continue with what we have\r\n            }\r\n          }\r\n\r\n          // Add notification metadata for backend with proper sender info\r\n          const notificationPayload = {\r\n            recipientId: otherUserId,\r\n            senderId: currentUser.uid,\r\n            senderName: senderName || 'User',\r\n            senderPhoto: senderPhoto || '',\r\n            message: message.text,\r\n            conversationId: conversationId,\r\n            isQrInitiated: isQrInitiated,\r\n          };\r\n\r\n          console.log(\r\n            'Sending backend notification with payload:',\r\n            notificationPayload,\r\n          );\r\n\r\n          // Check for network connectivity before making the request\r\n          const isConnected = await this.checkNetworkConnectivity();\r\n\r\n          if (isConnected) {\r\n            try {\r\n              // Use a timeout to prevent hanging on backend requests\r\n              const timeoutPromise = new Promise((_, reject) => {\r\n                setTimeout(\r\n                  () =>\r\n                    reject(new Error('Backend notification request timed out')),\r\n                  5000,\r\n                );\r\n              });\r\n\r\n              const fetchPromise = fetch(\r\n                `${BACKEND_URL}/api/notifications/message`,\r\n                {\r\n                  method: 'POST',\r\n                  headers: {\r\n                    'Content-Type': 'application/json',\r\n                  },\r\n                  body: JSON.stringify(notificationPayload),\r\n                },\r\n              );\r\n\r\n              // Race the fetch against the timeout\r\n              const response = (await Promise.race([\r\n                fetchPromise,\r\n                timeoutPromise,\r\n              ])) as Response;\r\n\r\n              if (response.ok) {\r\n                const data = await response.json();\r\n                console.log('Backend notification response:', data);\r\n              } else {\r\n                const errorText = await response.text();\r\n                console.error(\r\n                  `Backend notification failed with status: ${response.status}`,\r\n                );\r\n                console.error(`Error body: ${errorText}`);\r\n\r\n                // If we get a 404 specifically with /batch in the error, it's likely\r\n                // the Vercel routing issue with Firebase batch endpoint\r\n                if (response.status === 404 && errorText.includes('/batch')) {\r\n                  console.log(\r\n                    'Detected Firebase batch endpoint issue with Vercel, using local notification only',\r\n                  );\r\n                  // Continue with message sending despite notification failure\r\n                }\r\n              }\r\n            } catch (error) {\r\n              // This catch block will handle network errors and the 404 batch error\r\n              console.error('Error sending backend notification:', error);\r\n              console.log('Using local notification only');\r\n              // Local notification handled above, so we can safely continue\r\n            }\r\n          } else {\r\n            console.log('Device is offline, using local notification only');\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Error preparing notification:', error);\r\n        // Errors in notification should not prevent message sending\r\n      }\r\n\r\n      return newMessage;\r\n    } catch (error) {\r\n      console.error('MessageService :: sendMessage() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Helper function to check network connectivity\r\n  async checkNetworkConnectivity(): Promise<boolean> {\r\n    try {\r\n      // Create an AbortController with a timeout\r\n      const controller = new AbortController();\r\n      const timeoutId = setTimeout(() => controller.abort(), 3000);\r\n\r\n      // Try to fetch the health check endpoint with the correct URL\r\n      const response = await fetch(`${BACKEND_URL}/api/health`, {\r\n        method: 'GET',\r\n        headers: {'Cache-Control': 'no-cache'},\r\n        signal: controller.signal,\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n      return response.ok;\r\n    } catch (error) {\r\n      // Any error means we're offline\r\n      console.log('Network connectivity check failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Get messages for a conversation\r\n  getMessages(conversationId: string, limit = 50) {\r\n    return query(\r\n      this.messagesCollection,\r\n      where('conversationId', '==', conversationId),\r\n      orderBy('timestamp', 'desc'),\r\n      fs_limit(limit),\r\n    );\r\n  }\r\n\r\n  // Listen to user conversations\r\n  listenToConversations(\r\n    userId: string,\r\n    callback: (conversations: Conversation[]) => void,\r\n  ) {\r\n    return onSnapshot(\r\n      query(\r\n        this.conversationsCollection,\r\n        where('participants', 'array-contains', userId),\r\n        orderBy('lastMessage.timestamp', 'desc'),\r\n      ),\r\n      (snapshot: FirebaseFirestoreTypes.QuerySnapshot<Conversation>) => {\r\n        const conversations = snapshot.docs.map(doc => {\r\n          const data = doc.data() as Omit<Conversation, 'id'>;\r\n          return {\r\n            id: doc.id,\r\n            ...data,\r\n          } as Conversation;\r\n        });\r\n        callback(conversations);\r\n      },\r\n      error => {\r\n        console.error('Error listening to conversations:', error);\r\n      },\r\n    );\r\n  }\r\n\r\n  // Update participant details in conversations (e.g., when profile photo changes)\r\n  async updateParticipantDetails(\r\n    userId: string,\r\n    updates: {name?: string; image?: string},\r\n  ): Promise<void> {\r\n    try {\r\n      // Find all conversations this user is part of\r\n      const conversationsQuery = await getDocs(\r\n        query(\r\n          this.conversationsCollection,\r\n          where('participants', 'array-contains', userId),\r\n        ),\r\n      );\r\n\r\n      if (conversationsQuery.empty) {\r\n        console.log('No conversations found for user', userId);\r\n        return;\r\n      }\r\n\r\n      // Create batch to update all conversations at once\r\n      const batch = writeBatch(getFirestore());\r\n\r\n      conversationsQuery.docs.forEach(doc => {\r\n        // Only update fields that are provided in the updates object\r\n        const updateData: Record<string, any> = {};\r\n\r\n        if (updates.name !== undefined) {\r\n          updateData[`participantDetails.${userId}.name`] = updates.name;\r\n        }\r\n\r\n        if (updates.image !== undefined) {\r\n          updateData[`participantDetails.${userId}.image`] = updates.image;\r\n        }\r\n\r\n        // Skip if no updates to apply\r\n        if (Object.keys(updateData).length > 0) {\r\n          batch.update(doc.ref, updateData);\r\n        }\r\n      });\r\n\r\n      await batch.commit();\r\n      console.log(\r\n        `Updated participant details for user ${userId} in ${conversationsQuery.size} conversations`,\r\n      );\r\n    } catch (error) {\r\n      throw this.errorHandler.handleError(\r\n        error,\r\n        'Failed to update participant details',\r\n      );\r\n    }\r\n  }\r\n\r\n  // Mark messages as read\r\n  async markMessagesAsRead(\r\n    conversationId: string,\r\n    userId: string,\r\n  ): Promise<void> {\r\n    try {\r\n      // First check if the conversation exists\r\n      const conversationDoc = await getDoc(\r\n        doc(this.conversationsCollection, conversationId),\r\n      );\r\n      if (!conversationDoc.exists()) {\r\n        console.warn(\r\n          `Conversation ${conversationId} not found. Cannot mark messages as read.`,\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Update unread count in conversation\r\n      await updateDoc(doc(this.conversationsCollection, conversationId), {\r\n        [`unreadCount.${userId}`]: 0,\r\n      });\r\n\r\n      // Get all unread messages\r\n      const unreadMessages = await getDocs(\r\n        query(\r\n          this.messagesCollection,\r\n          where('conversationId', '==', conversationId),\r\n          where('recipientId', '==', userId),\r\n          where('read', '==', false),\r\n        ),\r\n      );\r\n\r\n      // Create batch to update all messages at once\r\n      const batch = writeBatch(getFirestore());\r\n      unreadMessages.docs.forEach(doc => {\r\n        batch.update(doc.ref, {read: true});\r\n      });\r\n\r\n      await batch.commit();\r\n    } catch (error) {\r\n      throw this.errorHandler.handleError(\r\n        error,\r\n        'Failed to mark messages as read',\r\n      );\r\n    }\r\n  }\r\n\r\n  // Delete a message\r\n  async deleteMessage(messageId: string): Promise<void> {\r\n    try {\r\n      // Check if the message exists\r\n      const messageDoc = await getDoc(doc(this.messagesCollection, messageId));\r\n      if (!messageDoc.exists()) {\r\n        console.warn(`Message ${messageId} not found. Cannot delete message.`);\r\n        return;\r\n      }\r\n\r\n      await deleteDoc(doc(this.messagesCollection, messageId));\r\n    } catch (error) {\r\n      throw this.errorHandler.handleError(error, 'Failed to delete message');\r\n    }\r\n  }\r\n\r\n  // Edit a message\r\n  async editMessage(messageId: string, newText: string): Promise<void> {\r\n    try {\r\n      // Check if the message exists first\r\n      const messageDocRef = doc(this.messagesCollection, messageId);\r\n      const messageDocSnapshot = await getDoc(messageDocRef);\r\n\r\n      if (!messageDocSnapshot.exists()) {\r\n        console.warn(`Message ${messageId} not found. Cannot edit message.`);\r\n        return;\r\n      }\r\n\r\n      const timestamp = new Date().getTime();\r\n      await updateDoc(messageDocRef, {\r\n        text: newText,\r\n        edited: true,\r\n        editedAt: timestamp,\r\n      });\r\n\r\n      // Get the message data\r\n      const messageData = messageDocSnapshot.data() as Message;\r\n\r\n      if (messageData?.conversationId) {\r\n        // Check if the conversation exists\r\n        const conversationDocRef = doc(\r\n          this.conversationsCollection,\r\n          messageData.conversationId,\r\n        );\r\n        const conversationDocSnapshot = await getDoc(conversationDocRef);\r\n\r\n        if (!conversationDocSnapshot.exists()) {\r\n          console.warn(\r\n            `Conversation ${messageData.conversationId} not found. Cannot update last message.`,\r\n          );\r\n          return;\r\n        }\r\n\r\n        const conversationData = conversationDocSnapshot.data() as Conversation;\r\n\r\n        // Update the last message in conversation if this is the last message\r\n        if (\r\n          conversationData?.lastMessage?.senderId === messageData.senderId &&\r\n          conversationData?.lastMessage?.timestamp === messageData.timestamp\r\n        ) {\r\n          await updateDoc(conversationDocRef, {\r\n            'lastMessage.text': newText,\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      throw this.errorHandler.handleError(error, 'Failed to edit message');\r\n    }\r\n  }\r\n\r\n  // Set typing status\r\n  async setTypingStatus(\r\n    conversationId: string,\r\n    userId: string,\r\n    isTyping: boolean,\r\n  ): Promise<void> {\r\n    try {\r\n      // Check if the conversation exists first\r\n      const conversationDoc = await getDoc(\r\n        doc(this.conversationsCollection, conversationId),\r\n      );\r\n      if (!conversationDoc.exists()) {\r\n        console.warn(\r\n          `Conversation ${conversationId} not found. Cannot update typing status.`,\r\n        );\r\n        return;\r\n      }\r\n\r\n      await updateDoc(doc(this.conversationsCollection, conversationId), {\r\n        [`participantDetails.${userId}.typing`]: isTyping,\r\n      });\r\n    } catch (error) {\r\n      throw this.errorHandler.handleError(\r\n        error,\r\n        'Failed to update typing status',\r\n      );\r\n    }\r\n  }\r\n\r\n  // Delete a conversation and all its messages\r\n  async deleteConversation(conversationId: string): Promise<void> {\r\n    try {\r\n      // Check if the conversation exists\r\n      const conversationDoc = await getDoc(\r\n        doc(this.conversationsCollection, conversationId),\r\n      );\r\n      if (!conversationDoc.exists()) {\r\n        console.warn(\r\n          `Conversation ${conversationId} not found. Cannot delete conversation.`,\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Get all messages in the conversation\r\n      const messagesSnapshot = await getDocs(\r\n        query(\r\n          this.messagesCollection,\r\n          where('conversationId', '==', conversationId),\r\n        ),\r\n      );\r\n\r\n      // Create a batch to delete all messages\r\n      const batch = writeBatch(getFirestore());\r\n\r\n      // Add message deletions to batch\r\n      messagesSnapshot.docs.forEach(doc => {\r\n        batch.delete(doc.ref);\r\n      });\r\n\r\n      // Add conversation deletion to batch\r\n      batch.delete(doc(this.conversationsCollection, conversationId));\r\n\r\n      // Commit the batch\r\n      await batch.commit();\r\n    } catch (error) {\r\n      throw this.errorHandler.handleError(\r\n        error,\r\n        'Failed to delete conversation',\r\n      );\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\styles\\Chat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\styles\\ChatHeaderLeft.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\styles\\ChatHeaderRight.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\styles\\ContactList.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\styles\\Conversations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\styles\\LoadingOverlay.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\types\\main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Conversations\\types\\props.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\components\\CaptionInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\components\\DraftBanner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\components\\MediaGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\components\\PermissionStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\components\\TagsInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\components\\UploadProgress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\components\\VisibilityToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\constants\\cloudinary.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\constants\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\hooks\\useCreatePost.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\hooks\\useDraft.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\hooks\\useMediaPicker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\hooks\\usePermissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\screens\\CreatePost.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\services\\CloudinaryService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\services\\PostService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\styles\\CreatePost.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\types\\main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\types\\props.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\utils\\hashtagUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\CreatePost\\utils\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\components\\EventCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\components\\EventContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\components\\EventDetailsHeaderFooter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\components\\EventDetailsSections.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\components\\EventDetailsStates.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\components\\EventLogo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\components\\EventsHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\components\\FilterBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\components\\StateComponents.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\constants\\api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\constants\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\constants\\storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\hooks\\useEventDetails.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has a missing dependency: 'fetchEventDetails'. Either include it or remove the dependency array.","line":55,"column":6,"nodeType":"ArrayExpression","endLine":55,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [fetchEventDetails, id, source]","fix":{"range":[1824,1836],"text":"[fetchEventDetails, id, source]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\hooks\\useEventsAndHackathons.ts","messages":[{"ruleId":"eslint-comments/no-unlimited-disable","severity":1,"message":"Unexpected unlimited 'eslint-disable-next-line' comment. Specify some rule names to disable.","line":73,"column":0,"nodeType":null,"endLine":73,"endColumn":32}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has a missing dependency: 'fetchEvents'. Either include it or remove the dependency array.","line":74,"column":6,"nodeType":"ArrayExpression","endLine":74,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [fetchEvents, navigation]","fix":{"range":[2178,2190],"text":"[fetchEvents, navigation]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {useEffect, useState, useCallback} from 'react';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport {useDispatch} from 'react-redux';\r\nimport {AnyAction} from '@reduxjs/toolkit';\r\nimport {useTypedSelector} from 'hooks/redux/useTypedSelector';\r\nimport {HackathonService} from '../services';\r\nimport {HackathonSummary} from '../types';\r\nimport {showToast} from '../utils';\r\nimport {\r\n  fetchHackathons,\r\n  setFilterType,\r\n  clearHackathonCache,\r\n} from 'shared/reducers/Hackathon';\r\n\r\n/**\r\n * Custom hook for Events and Hackathons screen logic\r\n *\r\n * Encapsulates:\r\n * - Redux state management\r\n * - Event fetching and caching\r\n * - Pull-to-refresh and manual refresh\r\n * - Filter management\r\n * - Navigation\r\n */\r\nexport const useEventsAndHackathons = () => {\r\n  const [refreshing, setRefreshing] = useState<boolean>(false);\r\n  const dispatch = useDispatch();\r\n  const navigation = useNavigation();\r\n\r\n  // Get state from Redux\r\n  const isDark = useTypedSelector(state => state.user.theme) === 'dark';\r\n  const {events, filteredEvents, loading, error, filterType, lastFetched} =\r\n    useTypedSelector(state => state.hackathon);\r\n\r\n  /**\r\n   * Fetch events from the API\r\n   */\r\n  const fetchEvents = useCallback(\r\n    async (forceRefresh = false): Promise<boolean> => {\r\n      try {\r\n        const result = await dispatch(\r\n          fetchHackathons({\r\n            location: 'India',\r\n            forceRefresh: forceRefresh,\r\n          }) as unknown as AnyAction,\r\n        );\r\n\r\n        return result.type.includes('/fulfilled');\r\n      } catch (fetchError) {\r\n        console.error('Error fetching events:', fetchError);\r\n        return false;\r\n      }\r\n    },\r\n    [dispatch],\r\n  );\r\n\r\n  /**\r\n   * Effect for initial load and focus listener\r\n   */\r\n  useEffect(() => {\r\n    console.log('Initial load: Fetching events');\r\n    fetchEvents();\r\n\r\n    // Add listener for when screen comes into focus\r\n    const unsubscribeFocus = navigation.addListener('focus', () => {\r\n      console.log('Events screen focused, fetching data...');\r\n      fetchEvents();\r\n    });\r\n\r\n    return () => {\r\n      unsubscribeFocus();\r\n    };\r\n    // eslint-disable-next-line\r\n  }, [navigation]);\r\n\r\n  /**\r\n   * Handle filter changes\r\n   */\r\n  const handleFilterChange = useCallback(\r\n    (newFilter: string) => {\r\n      dispatch(setFilterType(newFilter));\r\n    },\r\n    [dispatch],\r\n  );\r\n\r\n  /**\r\n   * Navigate to event details\r\n   */\r\n  const navigateToDetails = useCallback(\r\n    (event: HackathonSummary) => {\r\n      // @ts-ignore - Ignoring type error since we know these are the correct params\r\n      navigation.navigate('EventDetails', {\r\n        id: event.id,\r\n        source: event.source,\r\n      });\r\n    },\r\n    [navigation],\r\n  );\r\n\r\n  /**\r\n   * Handle refresh when pull-to-refresh is triggered\r\n   */\r\n  const onRefresh = useCallback(async () => {\r\n    console.log('User triggered Pull-to-Refresh');\r\n    setRefreshing(true);\r\n\r\n    try {\r\n      dispatch(clearHackathonCache());\r\n      const success = await fetchEvents(true);\r\n\r\n      if (success) {\r\n        showToast('Events refreshed successfully!');\r\n      } else {\r\n        showToast('Failed to refresh events. Try again later.', 'long');\r\n      }\r\n    } catch (refreshError) {\r\n      console.error('Error refreshing events:', refreshError);\r\n      showToast(\r\n        'Failed to refresh events. Check your network connection.',\r\n        'long',\r\n      );\r\n    } finally {\r\n      setRefreshing(false);\r\n    }\r\n  }, [dispatch, fetchEvents]);\r\n\r\n  /**\r\n   * Handle manual refresh from the reload button\r\n   */\r\n  const handleManualRefresh = useCallback(async () => {\r\n    console.log('User triggered Manual Refresh');\r\n    showToast('Fetching latest events...');\r\n    setRefreshing(true);\r\n\r\n    try {\r\n      dispatch(clearHackathonCache());\r\n\r\n      // Trigger backend scraping\r\n      try {\r\n        const refreshResult = await HackathonService.refreshEvents({\r\n          waitForCompletion: true,\r\n        });\r\n\r\n        if (refreshResult.success) {\r\n          console.log('Backend scraping successful');\r\n          showToast('Events refreshed successfully!');\r\n        } else {\r\n          console.log('Backend scraping failed:', refreshResult.message);\r\n\r\n          if (\r\n            refreshResult.message &&\r\n            (refreshResult.message.includes('timed out') ||\r\n              refreshResult.message.includes('timeout') ||\r\n              refreshResult.message.includes('429'))\r\n          ) {\r\n            showToast('Scraping service timed out. Try again later.', 'long');\r\n          } else {\r\n            showToast(`Refresh failed: ${refreshResult.message}`, 'long');\r\n          }\r\n        }\r\n      } catch (serverError) {\r\n        console.error('Error during server refresh:', serverError);\r\n        showToast('Server refresh failed.', 'long');\r\n      }\r\n\r\n      // Wait briefly then fetch available data\r\n      await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n      try {\r\n        const result = await dispatch(\r\n          fetchHackathons({\r\n            location: 'India',\r\n            forceRefresh: false,\r\n          }) as unknown as AnyAction,\r\n        );\r\n\r\n        const receivedData =\r\n          result.type.includes('/fulfilled') &&\r\n          result.payload &&\r\n          Array.isArray(result.payload.events) &&\r\n          result.payload.events.length > 0;\r\n\r\n        if (receivedData) {\r\n          console.log(`Loaded ${result.payload.events.length} events`);\r\n        } else {\r\n          showToast('No events found. Try again later.', 'long');\r\n        }\r\n      } catch (fetchError) {\r\n        console.error('Error fetching events after refresh:', fetchError);\r\n        showToast(\r\n          'Failed to load events. Check your network connection.',\r\n          'long',\r\n        );\r\n      }\r\n    } catch (manualRefreshError) {\r\n      console.error('Error refreshing events:', manualRefreshError);\r\n      showToast('Failed to refresh events.', 'long');\r\n    } finally {\r\n      setRefreshing(false);\r\n    }\r\n  }, [dispatch]);\r\n\r\n  /**\r\n   * Handle reset filters and fetch\r\n   */\r\n  const handleResetFilters = useCallback(() => {\r\n    handleFilterChange('all');\r\n    fetchEvents();\r\n  }, [handleFilterChange, fetchEvents]);\r\n\r\n  /**\r\n   * Go back navigation\r\n   */\r\n  const goBack = useCallback(() => {\r\n    navigation.goBack();\r\n  }, [navigation]);\r\n\r\n  return {\r\n    // State\r\n    isDark,\r\n    events,\r\n    filteredEvents,\r\n    loading,\r\n    error,\r\n    filterType,\r\n    lastFetched,\r\n    refreshing,\r\n\r\n    // Actions\r\n    fetchEvents,\r\n    handleFilterChange,\r\n    navigateToDetails,\r\n    onRefresh,\r\n    handleManualRefresh,\r\n    handleResetFilters,\r\n    goBack,\r\n  };\r\n};\r\n\r\nexport default useEventsAndHackathons;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\screens\\EventDetails.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\screens\\EventsAndHackathons.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\services\\hackathonService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'forceRefresh' is assigned a value but never used.","line":19,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\r\nimport {HackathonSummary, HackathonDetails, EventSource} from '../types';\r\nimport {StorageService} from './storageService';\r\nimport {API_BASE_URL} from '../constants';\r\n\r\n/**\r\n * Service for fetching hackathon and event data from the backend API\r\n */\r\nexport class HackathonService {\r\n  private static baseUrl = API_BASE_URL;\r\n  /**\r\n   * Fetches all hackathons with optional location filter\r\n   * @param location Optional location filter (defaults to India)\r\n   * @param forceRefresh Forces a refresh from API, bypassing cache\r\n   * @returns Array of hackathon summaries\r\n   */\r\n  public static async getHackathons(\r\n    // location: string = 'India',\r\n    forceRefresh: boolean = false,\r\n  ): Promise<HackathonSummary[]> {\r\n    try {\r\n      // Always use 'India' as the location\r\n      const finalLocation = 'India';\r\n\r\n      // Check cache first if not forcing a refresh\r\n      // if (!forceRefresh) {\r\n      //   const cachedData =\r\n      //     await StorageService.getCachedHackathons(finalLocation);\r\n\r\n      //   // If we have valid cached data, use it\r\n      //   if (cachedData && cachedData.isSameLocation) {\r\n      //     console.log('Using cached hackathon data');\r\n      //     return cachedData.hackathons;\r\n      //   }\r\n      // }\r\n\r\n      // If we're here, either forceRefresh is true, there's no cache,\r\n      // or the location has changed - fetch from API\r\n      const response = await axios.get(`${this.baseUrl}/hackathons`);\r\n\r\n      // Process the data to ensure image URLs are valid\r\n      const hackathons = response.data.map((hackathon: any) => ({\r\n        ...hackathon,\r\n        imageUrl: this.ensureValidImageUrl(\r\n          hackathon.imageUrl,\r\n          hackathon.source,\r\n        ),\r\n      }));\r\n\r\n      // Cache the fetched data\r\n      await StorageService.cacheHackathons(hackathons, finalLocation);\r\n      return hackathons;\r\n    } catch (error) {\r\n      console.error('Error fetching hackathons:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch details for a specific hackathon\r\n   * @param source Source platform (hackerearth or devfolio)\r\n   * @param id Hackathon ID\r\n   * @returns Promise with hackathon details\r\n   */\r\n  public static async getHackathonDetails(\r\n    source: string,\r\n    id: string,\r\n  ): Promise<HackathonDetails> {\r\n    try {\r\n      // For the new Flask API, the response structure is different\r\n      const response = await axios.get<HackathonDetails>(\r\n        `${API_BASE_URL}/hackathons/${source}/${id}`,\r\n      );\r\n\r\n      console.log(\r\n        'Fetched hackathon details from Flask API:',\r\n        response.data.title,\r\n      );\r\n\r\n      // Process and validate image URL\r\n      const event = response.data;\r\n      if (event.imageUrl) {\r\n        // Fix relative URLs\r\n        if (event.imageUrl && !event.imageUrl.startsWith('http')) {\r\n          if (event.imageUrl.startsWith('/')) {\r\n            // Try to make it an absolute URL based on the source\r\n            if (event.source === EventSource.DEVFOLIO) {\r\n              event.imageUrl = `https://devfolio.co${event.imageUrl}`;\r\n            } else if (event.source === EventSource.HACKEREARTH) {\r\n              event.imageUrl = `https://www.hackerearth.com${event.imageUrl}`;\r\n            }\r\n          } else {\r\n            // Invalid URL - clear it\r\n            event.imageUrl = '';\r\n          }\r\n        }\r\n      }\r\n\r\n      // The Flask API returns the object directly, not wrapped in a response object\r\n      return event;\r\n    } catch (error) {\r\n      console.error('Error fetching hackathon details:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check the status of the refresh operation\r\n   * @returns Status information\r\n   */\r\n  public static async getRefreshStatus(): Promise<{\r\n    isRefreshing: boolean;\r\n    message: string;\r\n    eventCounts: {\r\n      hackerearth: number;\r\n      devfolio: number;\r\n      total: number;\r\n    };\r\n  }> {\r\n    try {\r\n      const response = await axios.get(`${this.baseUrl}/refresh-status`);\r\n      return {\r\n        isRefreshing: response.data.is_refreshing,\r\n        message: response.data.message,\r\n        eventCounts: response.data.event_counts || {\r\n          hackerearth: 0,\r\n          devfolio: 0,\r\n          total: 0,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting refresh status:', error);\r\n      return {\r\n        isRefreshing: false,\r\n        message: 'Error getting refresh status',\r\n        eventCounts: {\r\n          hackerearth: 0,\r\n          devfolio: 0,\r\n          total: 0,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Forces a refresh of events from the server by triggering a new scrape\r\n   * @param options Optional parameters for the refresh\r\n   * @param options.waitForCompletion Whether to wait for the refresh to complete (default: true)\r\n   * @returns Response indicating success or failure\r\n   */\r\n  public static async refreshEvents(options?: {\r\n    waitForCompletion?: boolean;\r\n  }): Promise<{\r\n    success: boolean;\r\n    message: string;\r\n  }> {\r\n    const waitForCompletion = options?.waitForCompletion !== false; // Default to true if not specified\r\n\r\n    try {\r\n      console.log('Forcing server to refresh events by scraping again...');\r\n\r\n      // Call the backend refresh endpoint with force=true to ensure it scrapes data again\r\n      const response = await axios.get(`${this.baseUrl}/refresh?force=true`);\r\n\r\n      if (response.data && response.data.status === 'success') {\r\n        console.log('Server has started refreshing events in background');\r\n\r\n        // Only wait for refresh to complete if waitForCompletion is true\r\n        if (waitForCompletion) {\r\n          // Wait for refresh to complete by polling the status\r\n          console.log('Waiting for backend to refresh data...');\r\n          let isRefreshing = true;\r\n          let attempts = 0;\r\n          const maxAttempts = 20; // Maximum polling attempts\r\n\r\n          while (isRefreshing && attempts < maxAttempts) {\r\n            await new Promise(resolve => setTimeout(resolve, 1500)); // Wait 1.5 seconds between checks\r\n\r\n            // Check status\r\n            attempts++;\r\n            const status = await this.getRefreshStatus();\r\n            isRefreshing = status.isRefreshing;\r\n\r\n            console.log(\r\n              `Refresh status check ${attempts}/${maxAttempts}: ${status.message}`,\r\n            );\r\n\r\n            // If refresh complete, break the loop\r\n            if (!isRefreshing) {\r\n              console.log(\r\n                `Refresh complete! Found ${status.eventCounts.total} events`,\r\n              );\r\n              break;\r\n            }\r\n          }\r\n\r\n          // If we timed out\r\n          if (isRefreshing && attempts >= maxAttempts) {\r\n            console.log(\r\n              'Refresh is taking longer than expected. Continuing anyway...',\r\n            );\r\n          }\r\n        } else {\r\n          console.log(\r\n            'Not waiting for refresh to complete (waitForCompletion=false)',\r\n          );\r\n        }\r\n\r\n        return {success: true, message: response.data.message};\r\n      } else if (response.data && response.data.status === 'in_progress') {\r\n        // A refresh is already in progress\r\n        console.log('A refresh operation is already in progress');\r\n\r\n        // Only wait for existing refresh if waitForCompletion is true\r\n        if (waitForCompletion) {\r\n          // Wait for existing refresh to complete\r\n          console.log('Waiting for existing refresh to complete...');\r\n          let isRefreshing = true;\r\n          let attempts = 0;\r\n          const maxAttempts = 20;\r\n\r\n          while (isRefreshing && attempts < maxAttempts) {\r\n            await new Promise(resolve => setTimeout(resolve, 1500));\r\n\r\n            attempts++;\r\n            const status = await this.getRefreshStatus();\r\n            isRefreshing = status.isRefreshing;\r\n\r\n            console.log(\r\n              `Refresh status check ${attempts}/${maxAttempts}: ${status.message}`,\r\n            );\r\n\r\n            if (!isRefreshing) {\r\n              console.log(\r\n                `Existing refresh complete! Found ${status.eventCounts.total} events`,\r\n              );\r\n              break;\r\n            }\r\n          }\r\n        } else {\r\n          console.log(\r\n            'Not waiting for existing refresh to complete (waitForCompletion=false)',\r\n          );\r\n        }\r\n\r\n        return {success: true, message: 'Used existing refresh operation'};\r\n      } else {\r\n        console.error('Failed to refresh events:', response.data);\r\n        return {\r\n          success: false,\r\n          message: response.data?.message || 'Unknown error occurred',\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.error('Error refreshing events:', error);\r\n      return {\r\n        success: false,\r\n        message:\r\n          error instanceof Error ? error.message : 'Network error occurred',\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensures the image URL is valid and properly formatted\r\n   * @param imageUrl The image URL to validate\r\n   * @param source Optional source of the event (Devfolio or HackerEarth)\r\n   * @returns A valid image URL or empty string\r\n   */\r\n  private static ensureValidImageUrl(\r\n    imageUrl: string,\r\n    source?: EventSource,\r\n  ): string {\r\n    if (!imageUrl) return '';\r\n\r\n    // If it's already a valid URL, return it\r\n    if (imageUrl.startsWith('http')) return imageUrl;\r\n\r\n    // Handle relative URLs\r\n    if (imageUrl.startsWith('/')) {\r\n      // Try to make it an absolute URL based on the source\r\n      if (source === EventSource.DEVFOLIO) {\r\n        return `https://devfolio.co${imageUrl}`;\r\n      } else if (source === EventSource.HACKEREARTH) {\r\n        return `https://www.hackerearth.com${imageUrl}`;\r\n      }\r\n\r\n      // If source is not provided, try to guess from the URL path\r\n      if (imageUrl.includes('devfolio')) {\r\n        return `https://devfolio.co${imageUrl}`;\r\n      } else if (imageUrl.includes('hackerearth')) {\r\n        return `https://www.hackerearth.com${imageUrl}`;\r\n      }\r\n    }\r\n\r\n    // Invalid URL - return empty string\r\n    return '';\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\services\\storageService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\styles\\EventDetails.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\styles\\EventsAndHackathons.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\types\\hackathon.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\types\\props.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\utils\\dateUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\utils\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\EventsAndHackathons\\utils\\toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\GenerateQR\\screens\\QRCode.tsx","messages":[{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'fullName' is already declared in the upper scope on line 25 column 10.","line":31,"column":15,"nodeType":"Identifier","messageId":"noShadow","endLine":31,"endColumn":23},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: \"isDark ? '#1a1a1a' : '#f5f5f5'\" }","line":87,"column":9,"nodeType":"ObjectExpression","endLine":87,"endColumn":60},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: \"isDark ? '#1a1a1a' : '#f5f5f5'\" }","line":96,"column":11,"nodeType":"ObjectExpression","endLine":96,"endColumn":62},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":107,"column":43,"nodeType":"ObjectExpression","endLine":107,"endColumn":80},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: \"isDark ? '#1a1a1a' : '#f5f5f5'\" }","line":124,"column":11,"nodeType":"ObjectExpression","endLine":124,"endColumn":62},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#cccccc' : '#555555'\" }","line":145,"column":36,"nodeType":"ObjectExpression","endLine":145,"endColumn":77},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: \"isDark ? '#2379C2' : '#2379C2'\",\n  opacity: '!qrValue || isSharing ? 0.6 : 1'\n}","line":152,"column":13,"nodeType":"ObjectExpression","endLine":155,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  StatusBar,\r\n  Text,\r\n  TouchableOpacity,\r\n  View,\r\n  Share,\r\n  Platform,\r\n} from 'react-native';\r\nimport React, { useEffect, useState } from 'react';\r\nimport QRCodeView from 'react-native-qrcode-svg';\r\nimport { useNavigation } from '@react-navigation/native';\r\nimport { DrawerNavigationProp } from '@react-navigation/drawer';\r\nimport { useTypedSelector } from 'hooks/redux/useTypedSelector';\r\nimport Icon from 'react-native-vector-icons/Ionicons';\r\nimport { styles } from 'qr-code/styles/QRCode';\r\nimport { SafeAreaView } from 'react-native-safe-area-context';\r\n\r\n// QR code format - uses a specific URI scheme for app deep linking\r\n// Format: learnex://chat/{userId}\r\nconst QRCode = () => {\r\n  const navigation = useNavigation<DrawerNavigationProp<any>>();\r\n  const isDark = useTypedSelector(state => state.user.theme) === 'dark';\r\n  const firebase = useTypedSelector(state => state.firebase.firebase);\r\n  const currentUser = firebase.auth.currentUser();\r\n  const [fullName, setFullName] = useState<string>('');\r\n  const [qrValue, setQrValue] = useState<string>('');\r\n  const [isSharing, setIsSharing] = useState<boolean>(false);\r\n\r\n  useEffect(() => {\r\n    const fetchData = async () => {\r\n      const { fullName } = await firebase.user.getNameUsernamestring();\r\n      setFullName(fullName);\r\n\r\n      // Create a deep link URL with the current user's ID\r\n      // This URL will be used to start a chat with the user when scanned\r\n      if (currentUser && currentUser.uid) {\r\n        const deepLinkUrl = `learnex://chat/${currentUser.uid}`;\r\n        setQrValue(deepLinkUrl);\r\n      }\r\n    };\r\n    fetchData();\r\n  }, [currentUser, firebase.user]);\r\n\r\n  // Function to share the deep link\r\n  const handleShare = async () => {\r\n    if (!qrValue) return;\r\n\r\n    try {\r\n      setIsSharing(true);\r\n\r\n      // Create message for different platforms\r\n      const message = Platform.select({\r\n        ios: `Chat with me on Learnex: ${qrValue}`,\r\n        android: `Chat with me on Learnex: ${qrValue}`,\r\n        default: `Chat with me on Learnex: ${qrValue}`,\r\n      });\r\n\r\n      const result = await Share.share({\r\n        message,\r\n        url: qrValue, // iOS only\r\n        title: 'Share Learnex Chat Link',\r\n      });\r\n\r\n      if (result.action === Share.sharedAction) {\r\n        if (result.activityType) {\r\n          // Shared with activity type of result.activityType\r\n          console.log('Shared with activity type:', result.activityType);\r\n        } else {\r\n          // Shared\r\n          console.log('Shared successfully');\r\n        }\r\n      } else if (result.action === Share.dismissedAction) {\r\n        // Dismissed\r\n        console.log('Share dismissed');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error sharing:', error);\r\n    } finally {\r\n      setIsSharing(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <SafeAreaView\r\n      style={[\r\n        styles.container,\r\n        { backgroundColor: isDark ? '#1a1a1a' : '#f5f5f5' },\r\n      ]}>\r\n      <StatusBar\r\n        barStyle={isDark ? 'light-content' : 'dark-content'}\r\n        backgroundColor={isDark ? '#1a1a1a' : '#f5f5f5'}\r\n      />\r\n      <View\r\n        style={[\r\n          styles.customHeader,\r\n          { backgroundColor: isDark ? '#1a1a1a' : '#f5f5f5' },\r\n        ]}>\r\n        <TouchableOpacity\r\n          style={styles.backButton}\r\n          onPress={() => navigation.goBack()}>\r\n          <Icon\r\n            name=\"arrow-back\"\r\n            size={24}\r\n            color={isDark ? 'white' : 'black'}\r\n          />\r\n        </TouchableOpacity>\r\n        <Text style={[styles.headerTitle, { color: isDark ? 'white' : 'black' }]}>\r\n          Your QR Code\r\n        </Text>\r\n        <TouchableOpacity\r\n          style={styles.shareButton}\r\n          onPress={handleShare}\r\n          disabled={isSharing || !qrValue}>\r\n          <Icon\r\n            name=\"share-social-outline\"\r\n            size={24}\r\n            color={isDark ? 'white' : 'black'}\r\n          />\r\n        </TouchableOpacity>\r\n      </View>\r\n      <View\r\n        style={[\r\n          styles.qrCodeContainer,\r\n          { backgroundColor: isDark ? '#1a1a1a' : '#f5f5f5' },\r\n        ]}>\r\n        <QRCodeView\r\n          ecl=\"M\"\r\n          quietZone={10}\r\n          value={qrValue || 'Loading...'}\r\n          logo={{\r\n            uri:\r\n              currentUser?.photoURL ||\r\n              'https://ui-avatars.com/api/?name==' +\r\n              encodeURIComponent(fullName) ||\r\n              'Anonymous'\r\n          }}\r\n          logoSize={100}\r\n          logoMargin={-20}\r\n          logoBorderRadius={35}\r\n          logoBackgroundColor=\"transparent\"\r\n          size={300}\r\n        />\r\n\r\n        <Text\r\n          style={[styles.infoText, { color: isDark ? '#cccccc' : '#555555' }]}>\r\n          Scan this QR code to start a conversation with me\r\n        </Text>\r\n\r\n        <TouchableOpacity\r\n          style={[\r\n            styles.shareButtonLarge,\r\n            {\r\n              backgroundColor: isDark ? '#2379C2' : '#2379C2',\r\n              opacity: !qrValue || isSharing ? 0.6 : 1,\r\n            },\r\n          ]}\r\n          onPress={handleShare}\r\n          disabled={isSharing || !qrValue}>\r\n          <Icon\r\n            name=\"share-social\"\r\n            size={20}\r\n            color=\"white\"\r\n            style={styles.shareButtonIcon}\r\n          />\r\n          <Text style={styles.shareButtonText}>\r\n            {isSharing ? 'Sharing...' : 'Share Chat Link'}\r\n          </Text>\r\n        </TouchableOpacity>\r\n      </View>\r\n    </SafeAreaView>\r\n  );\r\n};\r\n\r\nexport default QRCode;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\GenerateQR\\styles\\QRCode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\GettingStarted\\screens\\GettingStarted.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\GettingStarted\\styles\\GettingStarted.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\CommentModal.tsx","messages":[{"ruleId":"react/no-unstable-nested-components","severity":1,"message":"Do not define components during render. React will see a new component type on every render and destroy the entire subtrees DOM nodes and state (https://reactjs.org/docs/reconciliation.html#elements-of-different-types). Instead, move this component definition out of the parent component CommentModal and pass data as props.","line":144,"column":31,"nodeType":"ArrowFunctionExpression","endLine":215,"endColumn":4},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'newIsLiked' is already declared in the upper scope on line 237 column 13.","line":256,"column":19,"nodeType":"Identifier","messageId":"noShadow","endLine":256,"endColumn":29},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'newLikes' is already declared in the upper scope on line 238 column 13.","line":257,"column":19,"nodeType":"Identifier","messageId":"noShadow","endLine":257,"endColumn":27},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'newIsLiked' is already declared in the upper scope on line 237 column 13.","line":262,"column":23,"nodeType":"Identifier","messageId":"noShadow","endLine":262,"endColumn":33},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'newLikes' is already declared in the upper scope on line 238 column 13.","line":263,"column":23,"nodeType":"Identifier","messageId":"noShadow","endLine":263,"endColumn":31},{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useCallback has an unnecessary dependency: 'firebase.posts'. Either exclude it or remove the dependency array.","line":350,"column":5,"nodeType":"ArrayExpression","endLine":350,"endColumn":66,"suggestions":[{"desc":"Update the dependencies array to be: [editedText, postId, localComments, comments]","fix":{"range":[11978,12039],"text":"[editedText, postId, localComments, comments]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useCallback has an unnecessary dependency: 'firebase.posts'. Either exclude it or remove the dependency array.","line":415,"column":5,"nodeType":"ArrayExpression","endLine":415,"endColumn":54,"suggestions":[{"desc":"Update the dependencies array to be: [postId, localComments, comments]","fix":{"range":[14300,14349],"text":"[postId, localComments, comments]"}}]},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'replyText' is already declared in the upper scope on line 62 column 10.","line":419,"column":52,"nodeType":"Identifier","messageId":"noShadow","endLine":419,"endColumn":69},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { fontSize: 16 }","line":498,"column":25,"nodeType":"ObjectExpression","endLine":498,"endColumn":41}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useEffect } from 'react';\r\nimport {\r\n  View,\r\n  Modal,\r\n  Text,\r\n  TouchableOpacity,\r\n  ScrollView,\r\n  Image,\r\n  TextInput,\r\n  ActivityIndicator,\r\n  Alert,\r\n  RefreshControl,\r\n  TouchableWithoutFeedback,\r\n  Clipboard,\r\n} from 'react-native';\r\nimport Icon from 'react-native-vector-icons/Feather';\r\nimport MaterialIcons from 'react-native-vector-icons/MaterialIcons';\r\nimport AntDesign from 'react-native-vector-icons/AntDesign';\r\nimport FontAwesome from 'react-native-vector-icons/FontAwesome';\r\nimport { Comment } from 'home/types/post';\r\nimport { useTypedSelector } from 'hooks/redux/useTypedSelector';\r\nimport { formatFirestoreTimestamp } from 'shared/services/utils';\r\nimport { primaryColor } from 'shared/res/strings/eng';\r\nimport { Avatar } from 'react-native-elements';\r\nimport { getUsernameForLogo } from 'shared/helpers/common/stringHelpers';\r\nimport {\r\n  onSnapshot,\r\n  getFirestore,\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  updateDoc,\r\n  deleteDoc,\r\n  addDoc,\r\n} from '@react-native-firebase/firestore';\r\nimport { createStyles } from '../styles/CommentModal.styles';\r\nimport { CommentModalProps } from '../types';\r\n\r\n/**\r\n * CommentModal displays a list of comments and allows users to add new comments\r\n * It supports features like:\r\n * - Viewing all comments\r\n * - Adding a new comment\r\n * - Liking comments\r\n * - Replying to comments\r\n * - Editing/Deleting your own comments\r\n */\r\nconst CommentModal: React.FC<CommentModalProps> = ({\r\n  visible,\r\n  onClose,\r\n  comments,\r\n  isDark,\r\n  onAddComment = async () => { },\r\n  newComment = '',\r\n  setNewComment = () => { },\r\n  isAddingComment = false,\r\n  postId = '',\r\n}) => {\r\n  const [editingCommentId, setEditingCommentId] = useState<string | null>(null);\r\n  const [editedText, setEditedText] = useState('');\r\n  const [replyingTo, setReplyingTo] = useState<Comment | null>(null);\r\n  const [replyText, setReplyText] = useState('');\r\n  const [isAddingReply, setIsAddingReply] = useState(false);\r\n  const [refreshing, setRefreshing] = useState(false);\r\n  const [showOptions, setShowOptions] = useState(false);\r\n  const [selectedComment, setSelectedComment] = useState<Comment | null>(null);\r\n  const firebase = useTypedSelector(state => state.firebase.firebase);\r\n  const currentUser = firebase.currentUser;\r\n  const [localComments, setLocalComments] = useState(comments);\r\n  const [userProfileImages, setUserProfileImages] = useState<\r\n    Record<string, string>\r\n  >({});\r\n\r\n  // Track all unique user IDs in comments\r\n  const userIds = React.useMemo(() => {\r\n    const ids = new Set<string>();\r\n    localComments.forEach(comment => {\r\n      if (comment.userId) ids.add(comment.userId);\r\n      if (comment.replies) {\r\n        comment.replies.forEach(reply => {\r\n          if (reply.userId) ids.add(reply.userId);\r\n        });\r\n      }\r\n    });\r\n    return Array.from(ids);\r\n  }, [localComments]);\r\n\r\n  // Listen for profile image updates for all users in comments\r\n  useEffect(() => {\r\n    if (!userIds.length) return;\r\n\r\n    // Create listeners for each user\r\n    const unsubscribers = userIds.map(userId => {\r\n      const db = getFirestore();\r\n      return onSnapshot(doc(collection(db, 'users'), userId), snapshot => {\r\n        if (snapshot.exists()) {\r\n          const userData = snapshot.data();\r\n          if (userData!.image) {\r\n            setUserProfileImages(prev => ({\r\n              ...prev,\r\n              [userId]: userData!.image,\r\n            }));\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    // Clean up listeners when component unmounts\r\n    return () => {\r\n      unsubscribers.forEach(unsubscribe => {\r\n        unsubscribe();\r\n      });\r\n    };\r\n  }, [userIds]);\r\n\r\n  const styles = createStyles(isDark);\r\n\r\n  // Update local comments when props change\r\n  useEffect(() => {\r\n    setLocalComments(comments);\r\n  }, [comments]);\r\n\r\n  // Handle refresh - pull to refresh comments\r\n  const onRefresh = useCallback(async () => {\r\n    try {\r\n      setRefreshing(true);\r\n      await onAddComment();\r\n    } catch (error) {\r\n      console.error('Error refreshing comments:', error);\r\n      Alert.alert('Error', 'Failed to refresh comments');\r\n    } finally {\r\n      setRefreshing(false);\r\n    }\r\n  }, [onAddComment]);\r\n\r\n  // Handle copy text function\r\n  const handleCopyText = (text: string) => {\r\n    Clipboard.setString(text);\r\n    setShowOptions(false);\r\n    Alert.alert('Success', 'Comment text copied');\r\n  };\r\n\r\n  // Options modal for comment actions (copy, edit, delete)\r\n  const CommentOptionsModal = () => {\r\n    if (!selectedComment) return null;\r\n\r\n    const canEdit = selectedComment.userId === currentUser?.uid;\r\n    const canDelete = selectedComment.userId === currentUser?.uid;\r\n\r\n    return (\r\n      <Modal\r\n        animationType=\"fade\"\r\n        transparent={true}\r\n        visible={showOptions}\r\n        onRequestClose={() => setShowOptions(false)}>\r\n        <TouchableWithoutFeedback onPress={() => setShowOptions(false)}>\r\n          <View style={styles.optionsModalOverlay}>\r\n            <TouchableWithoutFeedback>\r\n              <View style={styles.optionsModalContent}>\r\n                <TouchableOpacity\r\n                  style={styles.optionItem}\r\n                  onPress={() => {\r\n                    handleCopyText(selectedComment.text);\r\n                  }}>\r\n                  <FontAwesome\r\n                    name=\"copy\"\r\n                    size={24}\r\n                    color={isDark ? 'white' : 'black'}\r\n                  />\r\n                  <Text style={styles.optionText}>Copy Text</Text>\r\n                </TouchableOpacity>\r\n\r\n                {canEdit && (\r\n                  <TouchableOpacity\r\n                    style={styles.optionItem}\r\n                    onPress={() => {\r\n                      setEditingCommentId(selectedComment.id);\r\n                      setEditedText(selectedComment.text);\r\n                      setShowOptions(false);\r\n                    }}>\r\n                    <MaterialIcons\r\n                      name=\"edit\"\r\n                      size={24}\r\n                      color={isDark ? 'white' : 'black'}\r\n                    />\r\n                    <Text style={styles.optionText}>Edit Comment</Text>\r\n                  </TouchableOpacity>\r\n                )}\r\n\r\n                {canDelete && (\r\n                  <TouchableOpacity\r\n                    style={[styles.optionItem, styles.lastOptionItem]}\r\n                    onPress={() => {\r\n                      setShowOptions(false);\r\n                      setTimeout(() => {\r\n                        handleDeleteComment(selectedComment.id);\r\n                      }, 300);\r\n                    }}>\r\n                    <MaterialIcons\r\n                      name=\"delete-outline\"\r\n                      size={24}\r\n                      color=\"#FF3B30\"\r\n                    />\r\n                    <Text style={[styles.optionText, styles.dangerOption]}>\r\n                      Delete Comment\r\n                    </Text>\r\n                  </TouchableOpacity>\r\n                )}\r\n              </View>\r\n            </TouchableWithoutFeedback>\r\n          </View>\r\n        </TouchableWithoutFeedback>\r\n      </Modal>\r\n    );\r\n  };\r\n\r\n  // Handle like comment function\r\n  const handleLikeComment = async (commentId: string) => {\r\n    try {\r\n      // Make the API call first\r\n      const db = getFirestore();\r\n      const commentRef = doc(\r\n        collection(db, 'posts', postId, 'comments'),\r\n        commentId,\r\n      );\r\n      const commentSnapshot = await getDoc(commentRef);\r\n\r\n      if (!commentSnapshot.exists()) {\r\n        console.error('Comment not found');\r\n        return;\r\n      }\r\n\r\n      const commentData = commentSnapshot.data();\r\n      const currentLikes = commentData?.likes || 0;\r\n      const isLiked = commentData?.isLiked || false;\r\n\r\n      const newIsLiked = !isLiked;\r\n      const newLikes = newIsLiked ? currentLikes + 1 : currentLikes - 1;\r\n\r\n      await updateDoc(commentRef, {\r\n        likes: newLikes,\r\n        isLiked: newIsLiked,\r\n      });\r\n\r\n      // For replies, you'd need to find the parent comment and then update the reply within its subcollection.\r\n      // This example assumes top-level comments for simplicity.\r\n      // If replies are nested, you'll need to adjust the path accordingly.\r\n\r\n      // Simulate success response for UI update\r\n      const response = { success: true };\r\n\r\n      // Only update UI if the API call succeeds\r\n      if (response.success) {\r\n        const updatedComments = localComments.map(comment => {\r\n          if (comment.id === commentId) {\r\n            const newIsLiked = !comment.isLiked;\r\n            const newLikes = newIsLiked ? comment.likes + 1 : comment.likes - 1;\r\n            return { ...comment, isLiked: newIsLiked, likes: newLikes };\r\n          } else if (comment.replies && comment.replies.length > 0) {\r\n            const updatedReplies = comment.replies.map(reply => {\r\n              if (reply.id === commentId) {\r\n                const newIsLiked = !reply.isLiked;\r\n                const newLikes = newIsLiked ? reply.likes + 1 : reply.likes - 1;\r\n                return { ...reply, isLiked: newIsLiked, likes: newLikes };\r\n              }\r\n              return reply;\r\n            });\r\n            return { ...comment, replies: updatedReplies };\r\n          }\r\n          return comment;\r\n        });\r\n\r\n        // Update the UI only after successful API response\r\n        setLocalComments(updatedComments);\r\n      } else {\r\n        console.error('Like comment failed:', response.error);\r\n        // No UI update if the API call fails\r\n      }\r\n    } catch (error) {\r\n      console.error('Error liking comment:', error);\r\n      // No alert - just log the error\r\n    }\r\n  };\r\n\r\n  // Handle edit comment function\r\n  const handleEditComment = useCallback(\r\n    async (commentId: string) => {\r\n      if (!editedText.trim()) return;\r\n\r\n      try {\r\n        // Update local state immediately for better UX\r\n        const updatedComments = localComments.map(comment => {\r\n          if (comment.id === commentId) {\r\n            return {\r\n              ...comment,\r\n              text: editedText.trim(),\r\n              editedAt: new Date().toISOString(),\r\n            };\r\n          } else if (comment.replies && comment.replies.length > 0) {\r\n            const updatedReplies = comment.replies.map(reply => {\r\n              if (reply.id === commentId) {\r\n                return {\r\n                  ...reply,\r\n                  text: editedText.trim(),\r\n                  editedAt: new Date().toISOString(),\r\n                };\r\n              }\r\n              return reply;\r\n            });\r\n            return { ...comment, replies: updatedReplies };\r\n          }\r\n          return comment;\r\n        });\r\n\r\n        // Update UI immediately\r\n        setLocalComments(updatedComments);\r\n        setEditingCommentId(null);\r\n        setEditedText('');\r\n\r\n        // Then perform the actual edit in the backend\r\n        const db = getFirestore();\r\n        const commentRef = doc(\r\n          collection(db, 'posts', postId, 'comments'),\r\n          commentId,\r\n        );\r\n\r\n        const result = await updateDoc(commentRef, {\r\n          text: editedText.trim(),\r\n          editedAt: new Date().toISOString(),\r\n        })\r\n          .then(() => ({ success: true }))\r\n          .catch(error => ({ success: false, error: error.message }));\r\n\r\n        if (!result.success) {\r\n          Alert.alert('Error', result.error || 'Failed to edit comment');\r\n          // If edit fails, revert to original comments\r\n          setLocalComments(comments);\r\n          setEditingCommentId(commentId);\r\n          setEditedText(editedText);\r\n        }\r\n      } catch (error) {\r\n        console.error('Error editing comment:', error);\r\n        Alert.alert('Error', 'Failed to edit comment');\r\n        // If edit fails, revert to original comments\r\n        setLocalComments(comments);\r\n        setEditingCommentId(commentId);\r\n        setEditedText(editedText);\r\n      }\r\n    },\r\n    [editedText, firebase.posts, postId, localComments, comments],\r\n  );\r\n\r\n  // Handle delete comment function\r\n  const handleDeleteComment = useCallback(\r\n    async (commentId: string) => {\r\n      Alert.alert(\r\n        'Delete Comment',\r\n        'Are you sure you want to delete this comment?',\r\n        [\r\n          {\r\n            text: 'Cancel',\r\n            style: 'cancel',\r\n          },\r\n          {\r\n            text: 'Delete',\r\n            style: 'destructive',\r\n            onPress: async () => {\r\n              try {\r\n                // Update local state immediately for better UX\r\n                const updatedComments = localComments.filter(comment => {\r\n                  if (comment.id === commentId) {\r\n                    return false;\r\n                  } else if (comment.replies && comment.replies.length > 0) {\r\n                    comment.replies = comment.replies.filter(\r\n                      reply => reply.id !== commentId,\r\n                    );\r\n                  }\r\n                  return true;\r\n                });\r\n\r\n                // Update UI immediately\r\n                setLocalComments(updatedComments);\r\n\r\n                // Then perform the actual deletion in the backend\r\n                const db = getFirestore();\r\n                const commentRef = doc(\r\n                  collection(db, 'posts', postId, 'comments'),\r\n                  commentId,\r\n                );\r\n\r\n                const result = await deleteDoc(commentRef)\r\n                  .then(() => ({ success: true }))\r\n                  .catch(error => ({ success: false, error: error.message }));\r\n\r\n                if (!result.success) {\r\n                  Alert.alert(\r\n                    'Error',\r\n                    result.error || 'Failed to delete comment',\r\n                  );\r\n                  // If deletion fails, revert to original comments\r\n                  setLocalComments(comments);\r\n                }\r\n              } catch (error) {\r\n                console.error('Error deleting comment:', error);\r\n                Alert.alert('Error', 'Failed to delete comment');\r\n                // If deletion fails, revert to original comments\r\n                setLocalComments(comments);\r\n              }\r\n            },\r\n          },\r\n        ],\r\n        { cancelable: true },\r\n      );\r\n    },\r\n    [firebase.posts, postId, localComments, comments],\r\n  );\r\n\r\n  // Handle add reply function\r\n  const handleAddReply = async (commentId: string, replyText: string) => {\r\n    if (!replyText.trim()) return;\r\n\r\n    try {\r\n      setIsAddingReply(true);\r\n\r\n      const db = getFirestore();\r\n      const commentRef = doc(\r\n        collection(db, 'posts', postId, 'comments'),\r\n        commentId,\r\n      );\r\n      const repliesCollectionRef = collection(commentRef, 'replies');\r\n\r\n      const newReply = {\r\n        id: doc(repliesCollectionRef).id, // Generate a new ID for the reply\r\n        userId: currentUser?.uid,\r\n        username: currentUser?.displayName || 'Anonymous',\r\n        userImage: currentUser?.photoURL || '',\r\n        text: replyText.trim(),\r\n        timestamp: new Date().toISOString(),\r\n        likes: 0,\r\n        isLiked: false,\r\n      };\r\n\r\n      await addDoc(repliesCollectionRef, newReply);\r\n\r\n      const result = { success: true, reply: newReply };\r\n\r\n      if (result.success) {\r\n        // Update local state with new reply\r\n        const updatedComments = localComments.map(comment => {\r\n          if (comment.id === commentId) {\r\n            const newReplies = comment.replies || [];\r\n            newReplies.push(result.reply);\r\n            return { ...comment, replies: newReplies };\r\n          }\r\n          return comment;\r\n        });\r\n\r\n        setLocalComments(updatedComments);\r\n        setReplyingTo(null);\r\n        setReplyText('');\r\n      } else {\r\n        Alert.alert('Error', result.error || 'Failed to add reply');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error adding reply:', error);\r\n      Alert.alert('Error', 'Failed to add reply');\r\n    } finally {\r\n      setIsAddingReply(false);\r\n    }\r\n  };\r\n\r\n  // Handle cancel edit function\r\n  const handleCancelEdit = () => {\r\n    setEditingCommentId(null);\r\n    setEditedText('');\r\n  };\r\n\r\n  // Render a single comment or reply\r\n  const renderComment = (comment: Comment, isReply = false) => {\r\n    // Get potentially updated user image\r\n    const updatedUserImage = comment.userId\r\n      ? userProfileImages[comment.userId]\r\n      : null;\r\n    const displayImage = updatedUserImage || comment.userImage;\r\n\r\n    return (\r\n      <View\r\n        key={comment.id}\r\n        style={[styles.commentItem, isReply && styles.replyItem]}>\r\n        {displayImage ? (\r\n          <Image source={{ uri: displayImage }} style={styles.commentAvatar} />\r\n        ) : (\r\n          <Avatar\r\n            rounded\r\n            title={getUsernameForLogo(comment.username)}\r\n            size={40}\r\n            containerStyle={[styles.commentAvatar, styles.commentAvatarWithBg]}\r\n            titleStyle={{ fontSize: 16 }}\r\n          />\r\n        )}\r\n\r\n        <View style={styles.commentContent}>\r\n          <View style={styles.commentHeader}>\r\n            <Text style={styles.commentUsername}>{comment.username}</Text>\r\n          </View>\r\n\r\n          {editingCommentId === comment.id ? (\r\n            <View style={styles.editContainer}>\r\n              <TextInput\r\n                style={styles.editInput}\r\n                value={editedText}\r\n                onChangeText={setEditedText}\r\n                multiline\r\n                placeholder=\"Edit your comment...\"\r\n                placeholderTextColor={isDark ? '#8e8e8e' : '#666666'}\r\n              />\r\n              <View style={styles.editActions}>\r\n                <TouchableOpacity\r\n                  style={styles.editButton}\r\n                  onPress={handleCancelEdit}>\r\n                  <Text style={styles.editButtonText}>Cancel</Text>\r\n                </TouchableOpacity>\r\n                <TouchableOpacity\r\n                  style={[styles.editButton, styles.saveButton]}\r\n                  onPress={() => handleEditComment(comment.id)}>\r\n                  <Text style={styles.saveButtonText}>Save</Text>\r\n                </TouchableOpacity>\r\n              </View>\r\n            </View>\r\n          ) : (\r\n            <>\r\n              <Text style={styles.commentText}>{comment.text}</Text>\r\n              <View style={styles.commentMeta}>\r\n                <Text style={styles.commentTimestamp}>\r\n                  {isReply && typeof comment.timestamp === 'string'\r\n                    ? comment.timestamp\r\n                    : typeof comment.timestamp === 'string' &&\r\n                      comment.timestamp.includes('-')\r\n                      ? 'just now'\r\n                      : typeof comment.timestamp === 'string'\r\n                        ? comment.timestamp\r\n                        : formatFirestoreTimestamp(comment.timestamp)}\r\n                  {comment.editedAt && ' (edited)'}\r\n                </Text>\r\n                <Text style={styles.commentLikes}>{comment.likes} likes</Text>\r\n                {/* Only show Reply button for main comments, not for replies */}\r\n                {!isReply && (\r\n                  <TouchableOpacity\r\n                    onPress={() => setReplyingTo(comment)}\r\n                    style={styles.replyButtonContainer}>\r\n                    <Text style={styles.commentLikes}>Reply</Text>\r\n                  </TouchableOpacity>\r\n                )}\r\n              </View>\r\n            </>\r\n          )}\r\n        </View>\r\n\r\n        <TouchableOpacity\r\n          style={styles.likeButton}\r\n          onPress={() => handleLikeComment(comment.id)}>\r\n          <AntDesign\r\n            name={comment.isLiked ? 'heart' : 'hearto'}\r\n            size={16}\r\n            color={comment.isLiked ? 'red' : isDark ? '#8e8e8e' : '#666666'}\r\n          />\r\n        </TouchableOpacity>\r\n\r\n        <TouchableOpacity\r\n          style={styles.optionsButtonContainer}\r\n          onPress={() => {\r\n            setSelectedComment(comment);\r\n            setShowOptions(true);\r\n          }}>\r\n          <Icon\r\n            name=\"more-vertical\"\r\n            size={16}\r\n            color={isDark ? '#8e8e8e' : '#666666'}\r\n          />\r\n        </TouchableOpacity>\r\n      </View>\r\n    );\r\n  };\r\n\r\n  // Render all replies for a comment\r\n  const renderReplies = (comment: Comment) => {\r\n    if (!comment.replies || comment.replies.length === 0) return null;\r\n\r\n    return (\r\n      <View style={styles.replyContainer}>\r\n        {comment.replies.map(reply => renderComment(reply, true))}\r\n      </View>\r\n    );\r\n  };\r\n\r\n  return (\r\n    <Modal\r\n      animationType=\"slide\"\r\n      transparent\r\n      visible={visible}\r\n      onRequestClose={onClose}>\r\n      <View style={styles.modalContainer}>\r\n        <View style={styles.modalContent}>\r\n          <View style={styles.header}>\r\n            <TouchableOpacity style={styles.closeButton} onPress={onClose}>\r\n              <Icon name=\"x\" size={24} color={isDark ? 'white' : 'black'} />\r\n            </TouchableOpacity>\r\n            <Text style={styles.headerText}>Comments</Text>\r\n            <View style={styles.placeholder} />\r\n          </View>\r\n\r\n          <ScrollView\r\n            style={styles.commentsContainer}\r\n            refreshControl={\r\n              <RefreshControl\r\n                refreshing={refreshing}\r\n                onRefresh={onRefresh}\r\n                tintColor={isDark ? 'white' : primaryColor}\r\n                colors={[primaryColor]}\r\n              />\r\n            }\r\n            showsVerticalScrollIndicator={true}>\r\n            {localComments.length > 0 ? (\r\n              localComments.map(comment => (\r\n                <React.Fragment key={comment.id}>\r\n                  {renderComment(comment)}\r\n                  {renderReplies(comment)}\r\n                </React.Fragment>\r\n              ))\r\n            ) : (\r\n              <View style={styles.emptyStateContainer}>\r\n                <Text style={styles.emptyStateText}>\r\n                  No comments yet. Be the first to comment!\r\n                </Text>\r\n              </View>\r\n            )}\r\n          </ScrollView>\r\n\r\n          {replyingTo && (\r\n            <View style={styles.replyingToContainer}>\r\n              <Text style={styles.replyingToText}>\r\n                Replying to {replyingTo.username}\r\n              </Text>\r\n              <TouchableOpacity onPress={() => setReplyingTo(null)}>\r\n                <Icon\r\n                  name=\"x\"\r\n                  size={16}\r\n                  color={isDark ? '#8e8e8e' : '#666666'}\r\n                />\r\n              </TouchableOpacity>\r\n            </View>\r\n          )}\r\n\r\n          <View style={styles.commentInputContainer}>\r\n            <View style={styles.inputWrapper}>\r\n              <TextInput\r\n                style={styles.commentInput}\r\n                placeholder={replyingTo ? 'Add a reply...' : 'Add a comment...'}\r\n                placeholderTextColor={isDark ? '#8e8e8e' : '#666666'}\r\n                value={replyingTo ? replyText : newComment}\r\n                onChangeText={replyingTo ? setReplyText : setNewComment}\r\n                multiline\r\n              />\r\n              <TouchableOpacity\r\n                style={[\r\n                  styles.postButton,\r\n                  (replyingTo ? !replyText.trim() : !newComment.trim()) &&\r\n                  styles.disabledPostButton,\r\n                ]}\r\n                disabled={\r\n                  replyingTo\r\n                    ? isAddingReply || !replyText.trim()\r\n                    : isAddingComment || !newComment.trim()\r\n                }\r\n                onPress={async () => {\r\n                  if (replyingTo) {\r\n                    await handleAddReply(replyingTo.id, replyText);\r\n                  } else {\r\n                    await onAddComment();\r\n                  }\r\n                }}>\r\n                {replyingTo ? (\r\n                  isAddingReply ? (\r\n                    <ActivityIndicator size=\"small\" color=\"white\" />\r\n                  ) : (\r\n                    <Icon name=\"send\" size={16} color=\"white\" />\r\n                  )\r\n                ) : isAddingComment ? (\r\n                  <ActivityIndicator size=\"small\" color=\"white\" />\r\n                ) : (\r\n                  <Icon name=\"send\" size={16} color=\"white\" />\r\n                )}\r\n              </TouchableOpacity>\r\n            </View>\r\n          </View>\r\n        </View>\r\n        <CommentOptionsModal />\r\n      </View>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nexport default CommentModal;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\FullPostModal.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook React.useMemo has missing dependencies: 'renderImageContent' and 'renderVideoContent'. Either include them or remove the dependency array. If 'renderVideoContent' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":89,"column":6,"nodeType":"ArrayExpression","endLine":89,"endColumn":33,"suggestions":[{"desc":"Update the dependencies array to be: [allMedia, modalMediaIndex, renderVideoContent, renderImageContent]","fix":{"range":[2852,2879],"text":"[allMedia, modalMediaIndex, renderVideoContent, renderImageContent]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook React.useMemo has missing dependencies: 'styles.dot' and 'styles.paginationDots'. Either include them or remove the dependency array.","line":108,"column":6,"nodeType":"ArrayExpression","endLine":108,"endColumn":33,"suggestions":[{"desc":"Update the dependencies array to be: [allMedia, modalMediaIndex, styles.dot, styles.paginationDots]","fix":{"range":[3489,3516],"text":"[allMedia, modalMediaIndex, styles.dot, styles.paginationDots]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\HomeHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\Post.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\PostOptionsModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\Post\\PostActions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\Post\\PostFooter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\Post\\PostHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\Post\\PostMedia.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\Post\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\Post\\hooks\\usePostComments.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\Post\\hooks\\usePostLike.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\Post\\hooks\\usePostMedia.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\Post\\hooks\\usePostSave.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\Post\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\components\\Post\\utils\\postHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\constants\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\constants\\ui.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\screens\\Home.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\services\\CommentService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\styles\\CommentModal.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\styles\\Home.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\styles\\Post.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\types\\post.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Home\\types\\props.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\components\\ChatHeader.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { marginRight: 8 }","line":45,"column":32,"nodeType":"ObjectExpression","endLine":48,"endColumn":26},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { tintColor: 'white' }","line":56,"column":40,"nodeType":"ObjectExpression","endLine":60,"endColumn":34},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { marginRight: 12 }","line":70,"column":54,"nodeType":"ObjectExpression","endLine":70,"endColumn":73},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { fontSize: 14, marginRight: 8 }","line":76,"column":36,"nodeType":"ObjectExpression","endLine":76,"endColumn":91}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport {\r\n    View,\r\n    Text,\r\n    TouchableOpacity,\r\n    Switch,\r\n    Image,\r\n    Animated,\r\n    Dimensions,\r\n} from 'react-native';\r\nimport LinearGradient from 'react-native-linear-gradient';\r\nimport Ionicons from 'react-native-vector-icons/Ionicons';\r\nimport { LexAIMode } from 'lex-ai/types/lexAITypes';\r\nimport { styles } from 'lex-ai/styles/LexAI.styles';\r\nimport { ThemeColors } from '../types/lexAI.types';\r\n\r\nconst { width: SCREEN_WIDTH } = Dimensions.get('window');\r\n\r\ninterface ChatHeaderProps {\r\n    colors: ThemeColors;\r\n    isDarkMode: boolean;\r\n    currentMode: LexAIMode;\r\n    spin: Animated.AnimatedInterpolation<string>;\r\n    iconScale: Animated.Value;\r\n    onHistoryPress: () => void;\r\n    onToggleMode: () => void;\r\n}\r\n\r\nexport const ChatHeader: React.FC<ChatHeaderProps> = ({\r\n    colors,\r\n    isDarkMode,\r\n    currentMode,\r\n    spin,\r\n    iconScale,\r\n    onHistoryPress,\r\n    onToggleMode,\r\n}) => {\r\n    return (\r\n        <LinearGradient\r\n            colors={isDarkMode ? ['#1A2740', '#15213A'] : ['#E9F2FF', '#DAEAFF']}\r\n            style={styles.enhancedHeader}>\r\n            <View style={styles.headerContent}>\r\n                <View style={styles.headerTitleArea}>\r\n                    <Animated.View\r\n                        style={{\r\n                            marginRight: 8,\r\n                            transform: [{ rotate: spin }, { scale: iconScale }],\r\n                        }}>\r\n                        <LinearGradient\r\n                            colors={\r\n                                isDarkMode ? ['#4E7CF6', '#6A5AE0'] : ['#3E7BFA', '#6A5AE0']\r\n                            }\r\n                            style={styles.headerIcon}>\r\n                            <Image\r\n                                source={require('shared/res/pngs/lexai.png')}\r\n                                style={{\r\n                                    width: Math.min(SCREEN_WIDTH * 0.045, 18),\r\n                                    height: Math.min(SCREEN_WIDTH * 0.045, 18),\r\n                                    tintColor: 'white',\r\n                                }}\r\n                            />\r\n                        </LinearGradient>\r\n                    </Animated.View>\r\n                    <Text style={[styles.headerTitle, { color: colors.text }]}>\r\n                        LexAI {currentMode === LexAIMode.AGENT ? 'Assistant' : 'Chat'}\r\n                    </Text>\r\n                </View>\r\n                <View style={styles.headerControls}>\r\n                    <TouchableOpacity\r\n                        style={[styles.headerButton, { marginRight: 12 }]}\r\n                        onPress={onHistoryPress}>\r\n                        <Ionicons name=\"time-outline\" size={22} color={colors.primary} />\r\n                    </TouchableOpacity>\r\n                    <View style={styles.modeToggleContainer}>\r\n                        <Text\r\n                            style={{ color: colors.subtext, fontSize: 14, marginRight: 8 }}>\r\n                            {currentMode === LexAIMode.AGENT ? 'Agent' : 'Chat'}\r\n                        </Text>\r\n                        <Switch\r\n                            value={currentMode === LexAIMode.AGENT}\r\n                            onValueChange={onToggleMode}\r\n                            trackColor={{ false: '#767577', true: colors.primary }}\r\n                            thumbColor={'#f4f3f4'}\r\n                            style={{ transform: [{ scaleX: 0.7 }, { scaleY: 0.7 }] }}\r\n                        />\r\n                    </View>\r\n                </View>\r\n            </View>\r\n        </LinearGradient>\r\n    );\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\components\\ChatInput.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { marginTop: 10 }","line":45,"column":20,"nodeType":"ObjectExpression","endLine":45,"endColumn":37},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: 'isDarkMode\\r\\n' +\n    \"                            ? 'rgba(20, 30, 48, 0.85)'\\r\\n\" +\n    \"                            : 'rgba(230, 240, 255, 0.85)'\",\n  borderTopWidth: 1,\n  borderTopColor: 'isDarkMode\\r\\n' +\n    \"                            ? 'rgba(26, 39, 64, 0.8)'\\r\\n\" +\n    \"                            : 'rgba(218, 234, 255, 0.8)'\"\n}","line":49,"column":21,"nodeType":"ObjectExpression","endLine":57,"endColumn":22},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: 'isDarkMode\\r\\n' +\n    \"                                    ? 'rgba(15, 25, 40, 0.7)'\\r\\n\" +\n    \"                                    : 'rgba(255, 255, 255, 0.7)'\",\n  borderColor: 'isDarkMode\\r\\n' +\n    \"                                    ? 'rgba(36, 54, 86, 0.7)'\\r\\n\" +\n    \"                                    : 'rgba(199, 221, 255, 0.7)'\"\n}","line":63,"column":29,"nodeType":"ObjectExpression","endLine":70,"endColumn":30},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { position: 'relative' }","line":83,"column":34,"nodeType":"ObjectExpression","endLine":83,"endColumn":58},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  position: 'absolute',\n  width: 60,\n  height: 60,\n  borderRadius: 30,\n  backgroundColor: \"currentMode === LexAIMode.AGENT ? '#3E7BFA' : '#FF375F'\",\n  opacity: '!isButtonDisabled ? glowOpacity : 0',\n  zIndex: -1\n}","line":85,"column":36,"nodeType":"ObjectExpression","endLine":95,"endColumn":30},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  shadowColor: 'isButtonDisabled\\r\\n' +\n    \"                                                ? 'transparent'\\r\\n\" +\n    '                                                : currentMode === LexAIMode.AGENT\\r\\n' +\n    \"                                                    ? '#3E7BFA'\\r\\n\" +\n    \"                                                    : '#FF375F'\",\n  shadowOpacity: 'isDarkMode ? 0.5 : 0.4',\n  shadowRadius: 8,\n  elevation: 5\n}","line":121,"column":41,"nodeType":"ObjectExpression","endLine":131,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport {\r\n    View,\r\n    TextInput,\r\n    TouchableOpacity,\r\n    KeyboardAvoidingView,\r\n    Platform,\r\n    Animated,\r\n} from 'react-native';\r\nimport LinearGradient from 'react-native-linear-gradient';\r\nimport Ionicons from 'react-native-vector-icons/Ionicons';\r\nimport { LexAIMode } from 'lex-ai/types/lexAITypes';\r\nimport { styles } from 'lex-ai/styles/LexAI.styles';\r\nimport { ThemeColors } from '../types/lexAI.types';\r\n\r\ninterface ChatInputProps {\r\n    colors: ThemeColors;\r\n    isDarkMode: boolean;\r\n    currentMode: LexAIMode;\r\n    inputMessage: string;\r\n    isButtonDisabled: boolean;\r\n    inputRef: React.RefObject<TextInput | null>;\r\n    sendButtonScale: Animated.Value;\r\n    sendRotation: Animated.AnimatedInterpolation<string>;\r\n    glowOpacity: Animated.AnimatedInterpolation<number>;\r\n    onChangeText: (text: string) => void;\r\n    onSendPress: () => void;\r\n}export const ChatInput: React.FC<ChatInputProps> = ({\r\n    colors,\r\n    isDarkMode,\r\n    currentMode,\r\n    inputMessage,\r\n    isButtonDisabled,\r\n    inputRef,\r\n    sendButtonScale,\r\n    sendRotation,\r\n    glowOpacity,\r\n    onChangeText,\r\n    onSendPress,\r\n}) => {\r\n    return (\r\n        <KeyboardAvoidingView\r\n            behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\r\n            keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 20}\r\n            style={{ marginTop: 10 }}>\r\n            <View\r\n                style={[\r\n                    styles.inputContainer,\r\n                    {\r\n                        backgroundColor: isDarkMode\r\n                            ? 'rgba(20, 30, 48, 0.85)'\r\n                            : 'rgba(230, 240, 255, 0.85)',\r\n                        borderTopWidth: 1,\r\n                        borderTopColor: isDarkMode\r\n                            ? 'rgba(26, 39, 64, 0.8)'\r\n                            : 'rgba(218, 234, 255, 0.8)',\r\n                    },\r\n                ]}>\r\n                <View style={styles.inputRow}>\r\n                    <View\r\n                        style={[\r\n                            styles.inputWrapper,\r\n                            {\r\n                                backgroundColor: isDarkMode\r\n                                    ? 'rgba(15, 25, 40, 0.7)'\r\n                                    : 'rgba(255, 255, 255, 0.7)',\r\n                                borderColor: isDarkMode\r\n                                    ? 'rgba(36, 54, 86, 0.7)'\r\n                                    : 'rgba(199, 221, 255, 0.7)',\r\n                            },\r\n                        ]}>\r\n                        <TextInput\r\n                            style={[styles.input, { color: colors.text }]}\r\n                            placeholder=\"Ask me anything...\"\r\n                            placeholderTextColor={colors.subtext}\r\n                            value={inputMessage}\r\n                            onChangeText={onChangeText}\r\n                            multiline\r\n                            numberOfLines={1}\r\n                            ref={inputRef}\r\n                        />\r\n                    </View>\r\n                    <View style={{ position: 'relative' }}>\r\n                        <Animated.View\r\n                            style={{\r\n                                position: 'absolute',\r\n                                width: 60,\r\n                                height: 60,\r\n                                borderRadius: 30,\r\n                                backgroundColor:\r\n                                    currentMode === LexAIMode.AGENT ? '#3E7BFA' : '#FF375F',\r\n                                opacity: !isButtonDisabled ? glowOpacity : 0,\r\n                                transform: [{ translateX: -7.5 }, { translateY: -7.5 }],\r\n                                zIndex: -1,\r\n                            }}\r\n                        />\r\n                        <Animated.View\r\n                            style={{\r\n                                transform: [\r\n                                    { scale: sendButtonScale },\r\n                                    { rotate: sendRotation },\r\n                                ],\r\n                            }}>\r\n                            <TouchableOpacity\r\n                                onPress={onSendPress}\r\n                                disabled={isButtonDisabled}\r\n                                activeOpacity={0.8}>\r\n                                <LinearGradient\r\n                                    colors={\r\n                                        isButtonDisabled\r\n                                            ? [\r\n                                                isDarkMode ? '#3A3A3C' : '#D1D1D6',\r\n                                                isDarkMode ? '#2C2C2E' : '#C7C7CC',\r\n                                            ]\r\n                                            : currentMode === LexAIMode.AGENT\r\n                                                ? ['#4E7CF6', '#3E7BFA', '#2563EB']\r\n                                                : ['#FF375F', '#FF2D55', '#E31B60']\r\n                                    }\r\n                                    style={[\r\n                                        styles.sendButton,\r\n                                        {\r\n                                            shadowColor: isButtonDisabled\r\n                                                ? 'transparent'\r\n                                                : currentMode === LexAIMode.AGENT\r\n                                                    ? '#3E7BFA'\r\n                                                    : '#FF375F',\r\n                                            shadowOffset: { width: 0, height: 3 },\r\n                                            shadowOpacity: isDarkMode ? 0.5 : 0.4,\r\n                                            shadowRadius: 8,\r\n                                            elevation: 5,\r\n                                        },\r\n                                    ]}\r\n                                    start={{ x: 0, y: 0 }}\r\n                                    end={{ x: 1, y: 1 }}>\r\n                                    <Ionicons\r\n                                        name=\"send\"\r\n                                        size={20}\r\n                                        color=\"#fff\"\r\n                                        style={{\r\n                                            transform: [{ translateX: -1 }],\r\n                                        }}\r\n                                    />\r\n                                </LinearGradient>\r\n                            </TouchableOpacity>\r\n                        </Animated.View>\r\n                    </View>\r\n                </View>\r\n            </View>\r\n        </KeyboardAvoidingView>\r\n    );\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\components\\EmptyState.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  borderTopColor: 'isDarkMode\\r\\n' +\n    \"                            ? 'rgba(255,255,255,0.1)'\\r\\n\" +\n    \"                            : 'rgba(0,0,0,0.05)'\"\n}","line":27,"column":21,"nodeType":"ObjectExpression","endLine":31,"endColumn":22},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: 'isDarkMode\\r\\n' +\n    \"                                    ? 'rgba(10, 132, 255, 0.15)'\\r\\n\" +\n    \"                                    : '#EFF6FF'\",\n  borderColor: 'isDarkMode\\r\\n' +\n    \"                                    ? 'rgba(62, 123, 250, 0.3)'\\r\\n\" +\n    \"                                    : '#DBEAFE'\"\n}","line":38,"column":29,"nodeType":"ObjectExpression","endLine":45,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { View, Text, TouchableOpacity } from 'react-native';\r\nimport { styles } from 'lex-ai/styles/LexAI.styles';\r\nimport { ThemeColors } from '../types/lexAI.types';\r\n\r\ninterface EmptyStateProps {\r\n    colors: ThemeColors;\r\n    isDarkMode: boolean;\r\n    greeting: string;\r\n    suggestions: string[];\r\n    onSuggestionPress: (suggestion: string) => void;\r\n}\r\n\r\nexport const EmptyState: React.FC<EmptyStateProps> = ({\r\n    colors,\r\n    isDarkMode,\r\n    greeting,\r\n    suggestions,\r\n    onSuggestionPress,\r\n}) => {\r\n    return (\r\n        <View style={styles.emptyContainer}>\r\n            <Text style={[styles.emptyText, { color: colors.text }]}>{greeting}</Text>\r\n            <View\r\n                style={[\r\n                    styles.suggestionsContainer,\r\n                    {\r\n                        borderTopColor: isDarkMode\r\n                            ? 'rgba(255,255,255,0.1)'\r\n                            : 'rgba(0,0,0,0.05)',\r\n                    },\r\n                ]}>\r\n                {suggestions.map((suggestion, index) => (\r\n                    <TouchableOpacity\r\n                        key={`suggestion-${index}`}\r\n                        style={[\r\n                            styles.suggestionChip,\r\n                            {\r\n                                backgroundColor: isDarkMode\r\n                                    ? 'rgba(10, 132, 255, 0.15)'\r\n                                    : '#EFF6FF',\r\n                                borderColor: isDarkMode\r\n                                    ? 'rgba(62, 123, 250, 0.3)'\r\n                                    : '#DBEAFE',\r\n                            },\r\n                        ]}\r\n                        onPress={() => onSuggestionPress(suggestion)}>\r\n                        <Text style={[styles.suggestionText, { color: colors.primary }]}>\r\n                            {suggestion}\r\n                        </Text>\r\n                    </TouchableOpacity>\r\n                ))}\r\n            </View>\r\n        </View>\r\n    );\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\components\\HistoryDrawer.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: 'isDarkMode\\r\\n' +\n    \"                                ? 'rgba(10, 20, 35, 0.7)'\\r\\n\" +\n    \"                                : 'rgba(0, 0, 0, 0.5)'\"\n}","line":63,"column":25,"nodeType":"ObjectExpression","endLine":67,"endColumn":26},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: \"isDarkMode ? '#121C2E' : '#F5F9FF'\",\n  borderTopLeftRadius: 16,\n  borderBottomLeftRadius: 16\n}","line":75,"column":25,"nodeType":"ObjectExpression","endLine":81,"endColumn":26},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { borderBottomWidth: 0, paddingVertical: 18, borderTopLeftRadius: 16 }","line":89,"column":29,"nodeType":"ObjectExpression","endLine":93,"endColumn":30},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { flexDirection: 'row', alignItems: 'center' }","line":97,"column":38,"nodeType":"ObjectExpression","endLine":97,"endColumn":84},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  width: 32,\n  height: 32,\n  borderRadius: 16,\n  justifyContent: 'center',\n  alignItems: 'center',\n  marginRight: 12\n}","line":102,"column":40,"nodeType":"ObjectExpression","endLine":109,"endColumn":34},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDarkMode ? '#FFFFFF' : '#16213E'\",\n  fontSize: 20,\n  fontWeight: '600'\n}","line":115,"column":37,"nodeType":"ObjectExpression","endLine":119,"endColumn":38},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  width: 36,\n  height: 36,\n  borderRadius: 18,\n  backgroundColor: 'isDarkMode\\r\\n' +\n    \"                                    ? 'rgba(255,255,255,0.1)'\\r\\n\" +\n    \"                                    : 'rgba(0,0,0,0.05)'\",\n  justifyContent: 'center',\n  alignItems: 'center'\n}","line":125,"column":36,"nodeType":"ObjectExpression","endLine":134,"endColumn":30},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  borderBottomWidth: 'isDarkMode ? 1 : 0',\n  borderBottomColor: 'isDarkMode\\r\\n' +\n    \"                                                ? 'rgba(255,255,255,0.07)'\\r\\n\" +\n    \"                                                : 'transparent'\",\n  marginHorizontal: 8,\n  marginVertical: 4\n}","line":156,"column":41,"nodeType":"ObjectExpression","endLine":167,"endColumn":42},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  borderRadius: 12,\n  padding: 14,\n  borderLeftWidth: 'isActive ? 3 : 0',\n  borderLeftColor: \"item.mode === LexAIMode.AGENT ? '#3E7BFA' : '#FF375F'\",\n  shadowColor: \"isActive ? '#3E7BFA' : 'transparent'\",\n  shadowOpacity: 'isActive ? 0.2 : 0',\n  shadowRadius: 4\n}","line":172,"column":45,"nodeType":"ObjectExpression","endLine":189,"endColumn":46},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: 'isDarkMode\\r\\n' +\n    \"                                                                ? 'rgba(255,255,255,0.7)'\\r\\n\" +\n    \"                                                                : 'rgba(0,0,0,0.6)'\",\n  fontSize: 12,\n  fontWeight: \"isActive ? '500' : 'normal'\"\n}","line":201,"column":57,"nodeType":"ObjectExpression","endLine":207,"endColumn":58},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  paddingHorizontal: 8,\n  paddingVertical: 4,\n  borderRadius: 12,\n  flexDirection: 'row',\n  alignItems: 'center'\n}","line":217,"column":60,"nodeType":"ObjectExpression","endLine":223,"endColumn":54},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: '#FFFFFF', fontSize: 11, fontWeight: '600' }","line":227,"column":64,"nodeType":"ObjectExpression","endLine":231,"endColumn":58},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDarkMode ? colors.text : '#16213E'\",\n  fontWeight: \"isActive ? '500' : 'normal'\",\n  fontSize: 14,\n  marginTop: 6,\n  opacity: 'isActive ? 1 : 0.85'\n}","line":239,"column":53,"nodeType":"ObjectExpression","endLine":245,"endColumn":54},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { flexDirection: 'row', alignItems: 'center', marginTop: 6 }","line":251,"column":56,"nodeType":"ObjectExpression","endLine":255,"endColumn":50},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { marginRight: 4 }","line":264,"column":60,"nodeType":"ObjectExpression","endLine":264,"endColumn":78},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: 'isDarkMode\\r\\n' +\n    \"                                                                ? 'rgba(255,255,255,0.6)'\\r\\n\" +\n    \"                                                                : 'rgba(0,0,0,0.5)'\",\n  fontSize: 12\n}","line":269,"column":57,"nodeType":"ObjectExpression","endLine":274,"endColumn":58},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: 'isDarkMode\\r\\n' +\n    \"                                                ? 'rgba(28, 39, 57, 0.8)'\\r\\n\" +\n    \"                                                : 'rgba(243, 244, 246, 0.8)'\",\n  borderRadius: 22,\n  width: 38,\n  height: 38,\n  justifyContent: 'center',\n  alignItems: 'center',\n  margin: 8,\n  shadowColor: '#000',\n  shadowOpacity: 0.2,\n  shadowRadius: 2\n}","line":287,"column":48,"nodeType":"ObjectExpression","endLine":301,"endColumn":42},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { padding: 12, paddingTop: 16 }","line":315,"column":29,"nodeType":"ObjectExpression","endLine":318,"endColumn":30},{"ruleId":"react/no-unstable-nested-components","severity":1,"message":"Do not define components during render. React will see a new component type on every render and destroy the entire subtrees DOM nodes and state (https://reactjs.org/docs/reconciliation.html#elements-of-different-types). Instead, move this component definition out of the parent component HistoryDrawer and pass data as props. If you want to allow component creation in props, set allowAsProps option to true.","line":321,"column":45,"nodeType":"ArrowFunctionExpression","endLine":382,"endColumn":26},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  justifyContent: 'center',\n  alignItems: 'center',\n  padding: 30,\n  marginTop: 30\n}","line":325,"column":37,"nodeType":"ObjectExpression","endLine":330,"endColumn":38},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  width: 80,\n  height: 80,\n  borderRadius: 40,\n  justifyContent: 'center',\n  alignItems: 'center',\n  marginBottom: 20\n}","line":338,"column":44,"nodeType":"ObjectExpression","endLine":345,"endColumn":38},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDarkMode ? 'rgba(255,255,255,0.8)' : '#16213E'\",\n  fontSize: 18,\n  fontWeight: '600',\n  marginBottom: 8\n}","line":359,"column":41,"nodeType":"ObjectExpression","endLine":364,"endColumn":42},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: 'isDarkMode\\r\\n' +\n    \"                                            ? 'rgba(255,255,255,0.5)'\\r\\n\" +\n    \"                                            : 'rgba(0,0,0,0.5)'\",\n  fontSize: 14,\n  textAlign: 'center',\n  lineHeight: 20,\n  maxWidth: '80%'\n}","line":369,"column":44,"nodeType":"ObjectExpression","endLine":377,"endColumn":38},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  margin: 16,\n  borderRadius: 14,\n  shadowColor: '#3E7BFA',\n  shadowOpacity: 'isDarkMode ? 0.4 : 0.3',\n  shadowRadius: 8,\n  elevation: 5\n}","line":387,"column":32,"nodeType":"ObjectExpression","endLine":395,"endColumn":26},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  width: '100%',\n  flexDirection: 'row',\n  justifyContent: 'center',\n  alignItems: 'center',\n  padding: 16\n}","line":399,"column":36,"nodeType":"ObjectExpression","endLine":405,"endColumn":30},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  width: 28,\n  height: 28,\n  borderRadius: 14,\n  backgroundColor: 'rgba(255,255,255,0.25)',\n  justifyContent: 'center',\n  alignItems: 'center',\n  marginRight: 12\n}","line":409,"column":40,"nodeType":"ObjectExpression","endLine":417,"endColumn":34},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: '#FFFFFF', fontSize: 16, fontWeight: '600' }","line":421,"column":40,"nodeType":"ObjectExpression","endLine":425,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":27,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport {\r\n    View,\r\n    Text,\r\n    TouchableOpacity,\r\n    Modal,\r\n    Animated,\r\n} from 'react-native';\r\nimport { LegendList } from '@legendapp/list';\r\nimport LinearGradient from 'react-native-linear-gradient';\r\nimport Ionicons from 'react-native-vector-icons/Ionicons';\r\nimport { LexAIConversation, LexAIMode } from 'lex-ai/types/lexAITypes';\r\nimport { styles } from 'lex-ai/styles/LexAI.styles';\r\nimport { ThemeColors } from '../types/lexAI.types';\r\nimport { formatDate, getConversationPreview } from '../utils/lexAI.utils';\r\n\r\ninterface HistoryDrawerProps {\r\n    showHistory: boolean;\r\n    isDarkMode: boolean;\r\n    colors: ThemeColors;\r\n    historyTranslateX: Animated.Value;\r\n    historyOpacity: Animated.Value;\r\n    allConversations: LexAIConversation[];\r\n    currentConversationId: string | undefined;\r\n    historyItemAnimations: {\r\n        getAnimation: (id: string) => {\r\n            scale: Animated.Value;\r\n            opacity: Animated.Value;\r\n            translateX: Animated.Value;\r\n        };\r\n        animateItem: (id: string) => void;\r\n    };\r\n    onHideHistory: () => void;\r\n    onSelectConversation: (conversation: LexAIConversation) => void;\r\n    onDeleteConversation: (conversation: LexAIConversation) => void;\r\n    onNewConversation: () => void;\r\n}\r\n\r\nexport const HistoryDrawer: React.FC<HistoryDrawerProps> = ({\r\n    showHistory,\r\n    isDarkMode,\r\n    colors,\r\n    historyTranslateX,\r\n    historyOpacity,\r\n    allConversations,\r\n    currentConversationId,\r\n    historyItemAnimations,\r\n    onHideHistory,\r\n    onSelectConversation,\r\n    onDeleteConversation,\r\n    onNewConversation,\r\n}) => {\r\n    return (\r\n        <Modal\r\n            visible={showHistory}\r\n            transparent={true}\r\n            animationType=\"none\"\r\n            onRequestClose={onHideHistory}>\r\n            <View style={styles.historyModalContainer}>\r\n                <TouchableOpacity\r\n                    style={[\r\n                        styles.historyBackdrop,\r\n                        {\r\n                            backgroundColor: isDarkMode\r\n                                ? 'rgba(10, 20, 35, 0.7)'\r\n                                : 'rgba(0, 0, 0, 0.5)',\r\n                        },\r\n                    ]}\r\n                    activeOpacity={1}\r\n                    onPress={onHideHistory}\r\n                />\r\n                <Animated.View\r\n                    style={[\r\n                        styles.historyDrawer,\r\n                        {\r\n                            backgroundColor: isDarkMode ? '#121C2E' : '#F5F9FF',\r\n                            transform: [{ translateX: historyTranslateX }],\r\n                            opacity: historyOpacity,\r\n                            borderTopLeftRadius: 16,\r\n                            borderBottomLeftRadius: 16,\r\n                        },\r\n                    ]}>\r\n                    <LinearGradient\r\n                        colors={\r\n                            isDarkMode ? ['#1A2740', '#15213A'] : ['#E9F2FF', '#DAEAFF']\r\n                        }\r\n                        style={[\r\n                            styles.historyHeader,\r\n                            {\r\n                                borderBottomWidth: 0,\r\n                                paddingVertical: 18,\r\n                                borderTopLeftRadius: 16,\r\n                            },\r\n                        ]}\r\n                        start={{ x: 0, y: 0 }}\r\n                        end={{ x: 1, y: 1 }}>\r\n                        <View style={{ flexDirection: 'row', alignItems: 'center' }}>\r\n                            <LinearGradient\r\n                                colors={\r\n                                    isDarkMode ? ['#4E7CF6', '#6A5AE0'] : ['#3E7BFA', '#6A5AE0']\r\n                                }\r\n                                style={{\r\n                                    width: 32,\r\n                                    height: 32,\r\n                                    borderRadius: 16,\r\n                                    justifyContent: 'center',\r\n                                    alignItems: 'center',\r\n                                    marginRight: 12,\r\n                                }}>\r\n                                <Ionicons name=\"time-outline\" size={18} color=\"#FFFFFF\" />\r\n                            </LinearGradient>\r\n                            <Text\r\n                                style={[\r\n                                    styles.historyTitle,\r\n                                    {\r\n                                        color: isDarkMode ? '#FFFFFF' : '#16213E',\r\n                                        fontSize: 20,\r\n                                        fontWeight: '600',\r\n                                    },\r\n                                ]}>\r\n                                Chat History\r\n                            </Text>\r\n                        </View>\r\n                        <TouchableOpacity\r\n                            style={{\r\n                                width: 36,\r\n                                height: 36,\r\n                                borderRadius: 18,\r\n                                backgroundColor: isDarkMode\r\n                                    ? 'rgba(255,255,255,0.1)'\r\n                                    : 'rgba(0,0,0,0.05)',\r\n                                justifyContent: 'center',\r\n                                alignItems: 'center',\r\n                            }}\r\n                            onPress={onHideHistory}>\r\n                            <Ionicons\r\n                                name=\"close\"\r\n                                size={20}\r\n                                color={isDarkMode ? '#FFFFFF' : '#16213E'}\r\n                            />\r\n                        </TouchableOpacity>\r\n                    </LinearGradient>\r\n\r\n                    <LegendList\r\n                        data={allConversations}\r\n                        keyExtractor={item => item.id}\r\n                        estimatedItemSize={80}\r\n                        recycleItems={true}\r\n                        renderItem={({ item }) => {\r\n                            const animation = historyItemAnimations.getAnimation(item.id);\r\n                            const isActive = item.id === currentConversationId;\r\n                            return (\r\n                                <Animated.View\r\n                                    style={[\r\n                                        styles.historyItemContainer,\r\n                                        {\r\n                                            transform: [\r\n                                                { scale: animation.scale },\r\n                                                { translateX: animation.translateX },\r\n                                            ],\r\n                                            borderBottomWidth: isDarkMode ? 1 : 0,\r\n                                            borderBottomColor: isDarkMode\r\n                                                ? 'rgba(255,255,255,0.07)'\r\n                                                : 'transparent',\r\n                                            marginHorizontal: 8,\r\n                                            marginVertical: 4,\r\n                                        },\r\n                                    ]}>\r\n                                    <TouchableOpacity\r\n                                        style={[\r\n                                            styles.historyItem,\r\n                                            {\r\n                                                backgroundColor: isActive\r\n                                                    ? isDarkMode\r\n                                                        ? 'rgba(62, 123, 250, 0.2)'\r\n                                                        : 'rgba(62, 123, 250, 0.1)'\r\n                                                    : isDarkMode\r\n                                                        ? 'rgba(255, 255, 255, 0.03)'\r\n                                                        : 'rgba(255, 255, 255, 0.7)',\r\n                                                borderRadius: 12,\r\n                                                padding: 14,\r\n                                                borderLeftWidth: isActive ? 3 : 0,\r\n                                                borderLeftColor:\r\n                                                    item.mode === LexAIMode.AGENT ? '#3E7BFA' : '#FF375F',\r\n                                                shadowColor: isActive ? '#3E7BFA' : 'transparent',\r\n                                                shadowOffset: { width: 0, height: 2 },\r\n                                                shadowOpacity: isActive ? 0.2 : 0,\r\n                                                shadowRadius: 4,\r\n                                            },\r\n                                        ]}\r\n                                        onPress={() => {\r\n                                            historyItemAnimations.animateItem(item.id);\r\n                                            onSelectConversation(item);\r\n                                        }}\r\n                                        activeOpacity={0.7}>\r\n                                        <View style={styles.historyItemContent}>\r\n                                            <View style={styles.historyItemHeader}>\r\n                                                <Text\r\n                                                    style={[\r\n                                                        styles.historyItemDate,\r\n                                                        {\r\n                                                            color: isDarkMode\r\n                                                                ? 'rgba(255,255,255,0.7)'\r\n                                                                : 'rgba(0,0,0,0.6)',\r\n                                                            fontSize: 12,\r\n                                                            fontWeight: isActive ? '500' : 'normal',\r\n                                                        },\r\n                                                    ]}>\r\n                                                    {formatDate(item.updatedAt)}\r\n                                                </Text>\r\n                                                <LinearGradient\r\n                                                    colors={\r\n                                                        item.mode === LexAIMode.AGENT\r\n                                                            ? ['#4E7CF6', '#3E7BFA']\r\n                                                            : ['#FF375F', '#FF2D55']\r\n                                                    }\r\n                                                    style={{\r\n                                                        paddingHorizontal: 8,\r\n                                                        paddingVertical: 4,\r\n                                                        borderRadius: 12,\r\n                                                        flexDirection: 'row',\r\n                                                        alignItems: 'center',\r\n                                                    }}\r\n                                                    start={{ x: 0, y: 0 }}\r\n                                                    end={{ x: 1, y: 0 }}>\r\n                                                    <Text\r\n                                                        style={{\r\n                                                            color: '#FFFFFF',\r\n                                                            fontSize: 11,\r\n                                                            fontWeight: '600',\r\n                                                        }}>\r\n                                                        {item.mode === LexAIMode.AGENT ? 'Agent' : 'Chat'}\r\n                                                    </Text>\r\n                                                </LinearGradient>\r\n                                            </View>\r\n                                            <Text\r\n                                                style={[\r\n                                                    styles.historyItemPreview,\r\n                                                    {\r\n                                                        color: isDarkMode ? colors.text : '#16213E',\r\n                                                        fontWeight: isActive ? '500' : 'normal',\r\n                                                        fontSize: 14,\r\n                                                        marginTop: 6,\r\n                                                        opacity: isActive ? 1 : 0.85,\r\n                                                    },\r\n                                                ]}\r\n                                                numberOfLines={2}>\r\n                                                {getConversationPreview(item)}\r\n                                            </Text>\r\n                                            <View\r\n                                                style={{\r\n                                                    flexDirection: 'row',\r\n                                                    alignItems: 'center',\r\n                                                    marginTop: 6,\r\n                                                }}>\r\n                                                <Ionicons\r\n                                                    name=\"chatbubble-outline\"\r\n                                                    size={12}\r\n                                                    color={\r\n                                                        isDarkMode\r\n                                                            ? 'rgba(255,255,255,0.6)'\r\n                                                            : 'rgba(0,0,0,0.5)'\r\n                                                    }\r\n                                                    style={{ marginRight: 4 }}\r\n                                                />\r\n                                                <Text\r\n                                                    style={[\r\n                                                        styles.historyItemCount,\r\n                                                        {\r\n                                                            color: isDarkMode\r\n                                                                ? 'rgba(255,255,255,0.6)'\r\n                                                                : 'rgba(0,0,0,0.5)',\r\n                                                            fontSize: 12,\r\n                                                        },\r\n                                                    ]}>\r\n                                                    {\r\n                                                        item.messages.filter(m => m.role !== 'system')\r\n                                                            .length\r\n                                                    }{' '}\r\n                                                    messages\r\n                                                </Text>\r\n                                            </View>\r\n                                        </View>\r\n                                    </TouchableOpacity>\r\n\r\n                                    <TouchableOpacity\r\n                                        style={{\r\n                                            backgroundColor: isDarkMode\r\n                                                ? 'rgba(28, 39, 57, 0.8)'\r\n                                                : 'rgba(243, 244, 246, 0.8)',\r\n                                            borderRadius: 22,\r\n                                            width: 38,\r\n                                            height: 38,\r\n                                            justifyContent: 'center',\r\n                                            alignItems: 'center',\r\n                                            margin: 8,\r\n                                            shadowColor: '#000',\r\n                                            shadowOffset: { width: 0, height: 1 },\r\n                                            shadowOpacity: 0.2,\r\n                                            shadowRadius: 2,\r\n                                        }}\r\n                                        onPress={() => onDeleteConversation(item)}\r\n                                        activeOpacity={0.7}>\r\n                                        <Ionicons\r\n                                            name=\"trash-outline\"\r\n                                            size={18}\r\n                                            color={isDarkMode ? '#FF375F' : '#FF3B30'}\r\n                                        />\r\n                                    </TouchableOpacity>\r\n                                </Animated.View>\r\n                            );\r\n                        }}\r\n                        contentContainerStyle={[\r\n                            styles.historyList,\r\n                            {\r\n                                padding: 12,\r\n                                paddingTop: 16,\r\n                            },\r\n                        ]}\r\n                        showsVerticalScrollIndicator={false}\r\n                        ListEmptyComponent={() => (\r\n                            <View\r\n                                style={[\r\n                                    styles.emptyHistoryContainer,\r\n                                    {\r\n                                        justifyContent: 'center',\r\n                                        alignItems: 'center',\r\n                                        padding: 30,\r\n                                        marginTop: 30,\r\n                                    },\r\n                                ]}>\r\n                                <LinearGradient\r\n                                    colors={\r\n                                        isDarkMode\r\n                                            ? ['rgba(62, 123, 250, 0.15)', 'rgba(62, 123, 250, 0.05)']\r\n                                            : ['rgba(62, 123, 250, 0.1)', 'rgba(62, 123, 250, 0.03)']\r\n                                    }\r\n                                    style={{\r\n                                        width: 80,\r\n                                        height: 80,\r\n                                        borderRadius: 40,\r\n                                        justifyContent: 'center',\r\n                                        alignItems: 'center',\r\n                                        marginBottom: 20,\r\n                                    }}>\r\n                                    <Ionicons\r\n                                        name=\"chatbubbles-outline\"\r\n                                        size={40}\r\n                                        color={\r\n                                            isDarkMode\r\n                                                ? 'rgba(255,255,255,0.3)'\r\n                                                : 'rgba(62,123,250,0.5)'\r\n                                        }\r\n                                    />\r\n                                </LinearGradient>\r\n                                <Text\r\n                                    style={[\r\n                                        styles.emptyHistoryText,\r\n                                        {\r\n                                            color: isDarkMode ? 'rgba(255,255,255,0.8)' : '#16213E',\r\n                                            fontSize: 18,\r\n                                            fontWeight: '600',\r\n                                            marginBottom: 8,\r\n                                        },\r\n                                    ]}>\r\n                                    No conversations yet\r\n                                </Text>\r\n                                <Text\r\n                                    style={{\r\n                                        color: isDarkMode\r\n                                            ? 'rgba(255,255,255,0.5)'\r\n                                            : 'rgba(0,0,0,0.5)',\r\n                                        fontSize: 14,\r\n                                        textAlign: 'center',\r\n                                        lineHeight: 20,\r\n                                        maxWidth: '80%',\r\n                                    }}>\r\n                                    Start a new conversation with LexAI to see your chat history\r\n                                    here\r\n                                </Text>\r\n                            </View>\r\n                        )}\r\n                    />\r\n\r\n                    <LinearGradient\r\n                        colors={['#3E7BFA', '#6A5AE0']}\r\n                        style={{\r\n                            margin: 16,\r\n                            borderRadius: 14,\r\n                            shadowColor: '#3E7BFA',\r\n                            shadowOffset: { width: 0, height: 4 },\r\n                            shadowOpacity: isDarkMode ? 0.4 : 0.3,\r\n                            shadowRadius: 8,\r\n                            elevation: 5,\r\n                        }}\r\n                        start={{ x: 0, y: 0 }}\r\n                        end={{ x: 1, y: 0 }}>\r\n                        <TouchableOpacity\r\n                            style={{\r\n                                width: '100%',\r\n                                flexDirection: 'row',\r\n                                justifyContent: 'center',\r\n                                alignItems: 'center',\r\n                                padding: 16,\r\n                            }}\r\n                            onPress={onNewConversation}\r\n                            activeOpacity={0.8}>\r\n                            <View\r\n                                style={{\r\n                                    width: 28,\r\n                                    height: 28,\r\n                                    borderRadius: 14,\r\n                                    backgroundColor: 'rgba(255,255,255,0.25)',\r\n                                    justifyContent: 'center',\r\n                                    alignItems: 'center',\r\n                                    marginRight: 12,\r\n                                }}>\r\n                                <Ionicons name=\"add\" size={20} color=\"#FFFFFF\" />\r\n                            </View>\r\n                            <Text\r\n                                style={{\r\n                                    color: '#FFFFFF',\r\n                                    fontSize: 16,\r\n                                    fontWeight: '600',\r\n                                }}>\r\n                                New Conversation\r\n                            </Text>\r\n                        </TouchableOpacity>\r\n                    </LinearGradient>\r\n                </Animated.View>\r\n            </View>\r\n        </Modal>\r\n    );\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\components\\LoadingBubble.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { borderWidth: 1 }","line":43,"column":21,"nodeType":"ObjectExpression","endLine":47,"endColumn":22},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { height: 40 }","line":67,"column":25,"nodeType":"ObjectExpression","endLine":67,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { View, Animated } from 'react-native';\r\nimport { styles } from 'lex-ai/styles/LexAI.styles';\r\nimport { ThemeColors } from '../types/lexAI.types';\r\nimport { LoadingDots } from './LoadingDots';\r\n\r\ninterface LoadingBubbleProps {\r\n    isLoading: boolean;\r\n    isStreaming: boolean;\r\n    colors: ThemeColors;\r\n    dot1Opacity: Animated.AnimatedInterpolation<number>;\r\n    dot1Scale: Animated.AnimatedInterpolation<number>;\r\n    dot1TranslateY: Animated.AnimatedInterpolation<number>;\r\n    dot2Opacity: Animated.AnimatedInterpolation<number>;\r\n    dot2Scale: Animated.AnimatedInterpolation<number>;\r\n    dot2TranslateY: Animated.AnimatedInterpolation<number>;\r\n    dot3Opacity: Animated.AnimatedInterpolation<number>;\r\n    dot3Scale: Animated.AnimatedInterpolation<number>;\r\n    dot3TranslateY: Animated.AnimatedInterpolation<number>;\r\n}\r\n\r\nexport const LoadingBubble: React.FC<LoadingBubbleProps> = ({\r\n    isLoading,\r\n    isStreaming,\r\n    colors,\r\n    dot1Opacity,\r\n    dot1Scale,\r\n    dot1TranslateY,\r\n    dot2Opacity,\r\n    dot2Scale,\r\n    dot2TranslateY,\r\n    dot3Opacity,\r\n    dot3Scale,\r\n    dot3TranslateY,\r\n}) => {\r\n    if (!isLoading && !isStreaming) return null;\r\n\r\n    return (\r\n        <View style={styles.loadingContainer}>\r\n            <View\r\n                style={[\r\n                    styles.loadingBubble,\r\n                    {\r\n                        backgroundColor: colors.aiBubble,\r\n                        borderColor: colors.primary,\r\n                        borderWidth: 1,\r\n                    },\r\n                ]}>\r\n                <LoadingDots\r\n                    primaryColor={colors.primary}\r\n                    dot1Opacity={dot1Opacity}\r\n                    dot1Scale={dot1Scale}\r\n                    dot1TranslateY={dot1TranslateY}\r\n                    dot2Opacity={dot2Opacity}\r\n                    dot2Scale={dot2Scale}\r\n                    dot2TranslateY={dot2TranslateY}\r\n                    dot3Opacity={dot3Opacity}\r\n                    dot3Scale={dot3Scale}\r\n                    dot3TranslateY={dot3TranslateY}\r\n                />\r\n            </View>\r\n        </View>\r\n    );\r\n};\r\n\r\nexport const FooterSpacer: React.FC = () => {\r\n    return <View style={{ height: 40 }} />;\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\components\\LoadingDots.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  flexDirection: 'row',\n  alignItems: 'center',\n  justifyContent: 'flex-start',\n  height: 20\n}","line":31,"column":16,"nodeType":"ObjectExpression","endLine":36,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { View, Animated } from 'react-native';\r\nimport { styles } from 'lex-ai/styles/LexAI.styles';\r\n\r\ninterface LoadingDotsProps {\r\n    primaryColor: string;\r\n    dot1Opacity: Animated.AnimatedInterpolation<number>;\r\n    dot1Scale: Animated.AnimatedInterpolation<number>;\r\n    dot1TranslateY: Animated.AnimatedInterpolation<number>;\r\n    dot2Opacity: Animated.AnimatedInterpolation<number>;\r\n    dot2Scale: Animated.AnimatedInterpolation<number>;\r\n    dot2TranslateY: Animated.AnimatedInterpolation<number>;\r\n    dot3Opacity: Animated.AnimatedInterpolation<number>;\r\n    dot3Scale: Animated.AnimatedInterpolation<number>;\r\n    dot3TranslateY: Animated.AnimatedInterpolation<number>;\r\n}\r\n\r\nexport const LoadingDots: React.FC<LoadingDotsProps> = ({\r\n    primaryColor,\r\n    dot1Opacity,\r\n    dot1Scale,\r\n    dot1TranslateY,\r\n    dot2Opacity,\r\n    dot2Scale,\r\n    dot2TranslateY,\r\n    dot3Opacity,\r\n    dot3Scale,\r\n    dot3TranslateY,\r\n}) => (\r\n    <View\r\n        style={{\r\n            flexDirection: 'row',\r\n            alignItems: 'center',\r\n            justifyContent: 'flex-start',\r\n            height: 20,\r\n        }}>\r\n        <Animated.View\r\n            style={[\r\n                styles.loadingDot,\r\n                {\r\n                    backgroundColor: primaryColor,\r\n                    opacity: dot1Opacity,\r\n                    transform: [{ scale: dot1Scale }, { translateY: dot1TranslateY }],\r\n                },\r\n            ]}\r\n        />\r\n        <Animated.View\r\n            style={[\r\n                styles.loadingDot,\r\n                {\r\n                    backgroundColor: primaryColor,\r\n                    opacity: dot2Opacity,\r\n                    transform: [{ scale: dot2Scale }, { translateY: dot2TranslateY }],\r\n                },\r\n            ]}\r\n        />\r\n        <Animated.View\r\n            style={[\r\n                styles.loadingDot,\r\n                {\r\n                    backgroundColor: primaryColor,\r\n                    opacity: dot3Opacity,\r\n                    transform: [{ scale: dot3Scale }, { translateY: dot3TranslateY }],\r\n                },\r\n            ]}\r\n        />\r\n    </View>\r\n);\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\components\\MessageBubble.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { tintColor: 'white' }","line":51,"column":36,"nodeType":"ObjectExpression","endLine":55,"endColumn":30},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: 'isUser\\r\\n' +\n    \"                                                    ? 'rgba(255,255,255,0.8)'\\r\\n\" +\n    '                                                    : colors.primary'\n}","line":95,"column":45,"nodeType":"ObjectExpression","endLine":99,"endColumn":46},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: 'isUser\\r\\n' +\n    \"                                                            ? 'rgba(255,255,255,0.6)'\\r\\n\" +\n    '                                                            : colors.subtext'\n}","line":119,"column":53,"nodeType":"ObjectExpression","endLine":123,"endColumn":54},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: 'isUser\\r\\n' +\n    \"                                                                ? 'rgba(255,255,255,0.8)'\\r\\n\" +\n    '                                                                : colors.text'\n}","line":131,"column":57,"nodeType":"ObjectExpression","endLine":135,"endColumn":58},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isUser ? 'rgba(255,255,255,0.7)' : colors.subtext\" }","line":159,"column":25,"nodeType":"ObjectExpression","endLine":159,"endColumn":85}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport {\r\n    View,\r\n    Text,\r\n    TouchableOpacity,\r\n    Linking,\r\n    Image,\r\n    Dimensions,\r\n} from 'react-native';\r\nimport LinearGradient from 'react-native-linear-gradient';\r\nimport { LexAIMessage } from 'lex-ai/types/lexAITypes';\r\nimport { styles } from 'lex-ai/styles/LexAI.styles';\r\nimport { SearchResult, LexAIMessageWithLinks, ThemeColors } from '../types/lexAI.types';\r\nimport { logDebug } from 'lex-ai/utils/common';\r\n\r\nconst { width: SCREEN_WIDTH } = Dimensions.get('window');\r\n\r\ninterface MessageBubbleProps {\r\n    item: LexAIMessage | LexAIMessageWithLinks;\r\n    colors: ThemeColors;\r\n    isDarkMode: boolean;\r\n    debugMode?: boolean;\r\n}\r\n\r\nexport const MessageBubble: React.FC<MessageBubbleProps> = ({\r\n    item,\r\n    colors,\r\n    isDarkMode,\r\n    debugMode = false,\r\n}) => {\r\n    const isUser = item.role === 'user';\r\n\r\n    // Check if message has links (for search results)\r\n    const hasLinks = 'links' in item && item.links && item.links.length > 0;\r\n\r\n    return (\r\n        <View\r\n            style={[\r\n                styles.messageBubble,\r\n                isUser ? styles.userMessage : styles.assistantMessage,\r\n            ]}>\r\n            {!isUser && (\r\n                <View style={styles.avatarContainer}>\r\n                    <LinearGradient\r\n                        colors={['#3E7BFA', '#6A5AE0']}\r\n                        style={styles.avatar}\r\n                        start={{ x: 0, y: 0 }}\r\n                        end={{ x: 1, y: 1 }}>\r\n                        <Image\r\n                            source={require('shared/res/pngs/lexai.png')}\r\n                            style={{\r\n                                width: Math.min(SCREEN_WIDTH * 0.045, 18),\r\n                                height: Math.min(SCREEN_WIDTH * 0.045, 18),\r\n                                tintColor: 'white',\r\n                            }}\r\n                        />\r\n                    </LinearGradient>\r\n                </View>\r\n            )}\r\n            <View\r\n                style={[\r\n                    styles.messageContent,\r\n                    isUser\r\n                        ? [\r\n                            styles.userMessageContent,\r\n                            { backgroundColor: colors.userBubble },\r\n                        ]\r\n                        : [\r\n                            styles.assistantMessageContent,\r\n                            {\r\n                                backgroundColor: isDarkMode\r\n                                    ? colors.aiBubble\r\n                                    : 'rgba(255, 255, 255, 0.9)',\r\n                            },\r\n                        ],\r\n                ]}>\r\n                {hasLinks ? (\r\n                    // Render message with clickable links\r\n                    <View>\r\n                        <Text\r\n                            style={[\r\n                                styles.messageText,\r\n                                isUser ? styles.userMessageText : { color: colors.text },\r\n                            ]}>\r\n                            {item.content.split('\\n\\n')[0]} {/* Show the header text */}\r\n                        </Text>\r\n\r\n                        {/* Render each search result as a clickable link */}\r\n                        {(item as LexAIMessageWithLinks).links?.map(\r\n                            (link: SearchResult, index: number) => (\r\n                                <View key={index} style={styles.searchResultItem}>\r\n                                    <Text\r\n                                        style={[\r\n                                            styles.searchResultIndex,\r\n                                            {\r\n                                                color: isUser\r\n                                                    ? 'rgba(255,255,255,0.8)'\r\n                                                    : colors.primary,\r\n                                            },\r\n                                        ]}>\r\n                                        {index + 1}.\r\n                                    </Text>\r\n                                    <View style={styles.searchResultContent}>\r\n                                        <TouchableOpacity\r\n                                            onPress={() => {\r\n                                                logDebug(`Opening URL: ${link.url}`);\r\n                                                Linking.openURL(link.url);\r\n                                            }}>\r\n                                            <Text\r\n                                                style={[\r\n                                                    styles.searchResultTitle,\r\n                                                    { color: colors.primary },\r\n                                                ]}>\r\n                                                {link.title}\r\n                                            </Text>\r\n                                            <Text\r\n                                                style={[\r\n                                                    styles.searchResultUrl,\r\n                                                    {\r\n                                                        color: isUser\r\n                                                            ? 'rgba(255,255,255,0.6)'\r\n                                                            : colors.subtext,\r\n                                                    },\r\n                                                ]}>\r\n                                                {link.url}\r\n                                            </Text>\r\n                                            {link.snippet && (\r\n                                                <Text\r\n                                                    style={[\r\n                                                        styles.searchResultSnippet,\r\n                                                        {\r\n                                                            color: isUser\r\n                                                                ? 'rgba(255,255,255,0.8)'\r\n                                                                : colors.text,\r\n                                                        },\r\n                                                    ]}>\r\n                                                    {link.snippet}\r\n                                                </Text>\r\n                                            )}\r\n                                        </TouchableOpacity>\r\n                                    </View>\r\n                                </View>\r\n                            ),\r\n                        )}\r\n                    </View>\r\n                ) : (\r\n                    // Render regular message\r\n                    <Text\r\n                        style={[\r\n                            styles.messageText,\r\n                            isUser ? styles.userMessageText : { color: colors.text },\r\n                        ]}>\r\n                        {item.content}\r\n                    </Text>\r\n                )}\r\n                <Text\r\n                    style={[\r\n                        styles.timestamp,\r\n                        { color: isUser ? 'rgba(255,255,255,0.7)' : colors.subtext },\r\n                    ]}>\r\n                    {new Date(item.timestamp).toLocaleTimeString([], {\r\n                        hour: '2-digit',\r\n                        minute: '2-digit',\r\n                    })}\r\n                    {debugMode && ` [ID: ${item.id.slice(0, 4)}]`}\r\n                </Text>\r\n            </View>\r\n        </View>\r\n    );\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\constants\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\constants\\lexAI.constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\hooks\\useLexAIAnimations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\hooks\\useLexAIConversation.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has a missing dependency: 'currentMode'. Either include it or remove the dependency array.","line":134,"column":6,"nodeType":"ArrayExpression","endLine":134,"endColumn":16,"suggestions":[{"desc":"Update the dependencies array to be: [currentMode, dispatch]","fix":{"range":[4638,4648],"text":"[currentMode, dispatch]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\hooks\\useLexAIMessaging.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\hooks\\useLexAIToolExecution.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\reducers\\LexAI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\screens\\LexAI.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\services\\LexAIFirestoreService.ts","messages":[{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":77,"column":45,"nodeType":"Identifier","messageId":"noShadow","endLine":77,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {getAuth} from '@react-native-firebase/auth';\r\nimport {\r\n  getFirestore,\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  setDoc,\r\n  updateDoc,\r\n  deleteDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  getDocs,\r\n  serverTimestamp,\r\n  Timestamp,\r\n  FirebaseFirestoreTypes,\r\n} from '@react-native-firebase/firestore';\r\nimport {LexAIConversation} from 'lex-ai/types/lexAITypes';\r\n\r\n/**\r\n * Service class to handle LexAI data storage in Firestore.\r\n * Replaces the AsyncStorage implementation with Firestore.\r\n */\r\nexport class LexAIFirestoreService {\r\n  private conversationsCollection = collection(\r\n    getFirestore(),\r\n    'lexai_conversations',\r\n  ) as FirebaseFirestoreTypes.CollectionReference<LexAIConversation>;\r\n\r\n  /**\r\n   * Save a conversation to Firestore\r\n   */\r\n  async saveConversation(conversation: LexAIConversation): Promise<void> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Add userId to the conversation document for security rules\r\n      const conversationWithUser = {\r\n        ...conversation,\r\n        userId,\r\n        // Convert timestamp numbers to Firestore timestamps\r\n        firestoreCreatedAt: Timestamp.fromMillis(conversation.createdAt),\r\n        firestoreUpdatedAt: Timestamp.fromMillis(conversation.updatedAt),\r\n      };\r\n\r\n      // Use the conversation ID as the document ID\r\n      await setDoc(\r\n        doc(this.conversationsCollection, conversation.id),\r\n        conversationWithUser,\r\n      );\r\n    } catch (error) {\r\n      console.error('Error saving LexAI conversation to Firestore:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load all conversations for the current user from Firestore\r\n   */\r\n  async loadConversations(): Promise<LexAIConversation[]> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      const conversationsQuery = query(\r\n        this.conversationsCollection,\r\n        where('userId', '==', userId),\r\n        orderBy('firestoreUpdatedAt', 'desc'),\r\n      );\r\n      const conversationsSnapshot = await getDocs(conversationsQuery);\r\n\r\n      return conversationsSnapshot.docs.map(doc => {\r\n        const data = doc.data();\r\n        // Return the conversation with original createdAt/updatedAt properties\r\n        return {\r\n          id: doc.id,\r\n          title: data.title,\r\n          messages: data.messages,\r\n          createdAt: data.createdAt,\r\n          updatedAt: data.updatedAt,\r\n          mode: data.mode,\r\n        } as LexAIConversation;\r\n      });\r\n    } catch (error) {\r\n      console.error('Error loading LexAI conversations from Firestore:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a specific conversation by ID\r\n   */\r\n  async getConversation(\r\n    conversationId: string,\r\n  ): Promise<LexAIConversation | null> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      const docRef = doc(this.conversationsCollection, conversationId);\r\n      const docSnap = await getDoc(docRef);\r\n\r\n      if (docSnap.exists) {\r\n        const data = docSnap.data();\r\n        // Verify ownership\r\n        if (data?.userId !== userId) {\r\n          console.warn('Unauthorized access to conversation');\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          id: docSnap.id,\r\n          title: data.title,\r\n          messages: data.messages,\r\n          createdAt: data.createdAt,\r\n          updatedAt: data.updatedAt,\r\n          mode: data.mode,\r\n        } as LexAIConversation;\r\n      }\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error getting LexAI conversation from Firestore:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a conversation from Firestore\r\n   */\r\n  async deleteConversation(conversationId: string): Promise<void> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Verify the conversation belongs to the current user\r\n      const conversationDoc = await getDoc(\r\n        doc(this.conversationsCollection, conversationId),\r\n      );\r\n      if (\r\n        !conversationDoc.exists() ||\r\n        conversationDoc.data()?.userId !== userId\r\n      ) {\r\n        throw new Error('Conversation not found or unauthorized');\r\n      }\r\n\r\n      await deleteDoc(doc(this.conversationsCollection, conversationId));\r\n    } catch (error) {\r\n      console.error('Error deleting LexAI conversation from Firestore:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the active conversation ID from Firestore\r\n   */\r\n  async getActiveConversationId(): Promise<string | null> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        return null;\r\n      }\r\n\r\n      // Store active conversation ID in the user's document\r\n      const userDoc = await getDoc(\r\n        doc(collection(getFirestore(), 'users'), userId),\r\n      );\r\n      if (userDoc.exists()) {\r\n        return userDoc.data()?.lexai_active_conversation || null;\r\n      }\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error getting active LexAI conversation ID:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the active conversation ID in Firestore\r\n   */\r\n  async setActiveConversationId(conversationId: string): Promise<void> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Store active conversation ID in the user's document\r\n      await updateDoc(doc(collection(getFirestore(), 'users'), userId), {\r\n        lexai_active_conversation: conversationId,\r\n        updatedAt: serverTimestamp(),\r\n      });\r\n    } catch (error) {\r\n      console.error('Error setting active LexAI conversation ID:', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new LexAIFirestoreService();\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\styles\\LexAI.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\types\\lexAI.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\types\\lexAITypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\utils\\common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\utils\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\LexAI\\utils\\lexAI.utils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'timeGreeting' is assigned a value but never used.","line":60,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":60,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\r\nimport Config from 'react-native-config';\r\nimport {LexAIConversation} from 'lex-ai/types/lexAITypes';\r\nimport {SearchResult} from '../types/lexAI.types';\r\nimport {logDebug} from 'lex-ai/utils/common';\r\n\r\n/**\r\n * Format date for history display\r\n */\r\nexport const formatDate = (timestamp: number): string => {\r\n  const date = new Date(timestamp);\r\n  const today = new Date();\r\n  const yesterday = new Date();\r\n  yesterday.setDate(yesterday.getDate() - 1);\r\n\r\n  if (date.toDateString() === today.toDateString()) {\r\n    return `Today, ${date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}`;\r\n  } else if (date.toDateString() === yesterday.toDateString()) {\r\n    return `Yesterday, ${date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}`;\r\n  } else {\r\n    return date.toLocaleDateString([], {\r\n      month: 'short',\r\n      day: 'numeric',\r\n      hour: '2-digit',\r\n      minute: '2-digit',\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Get conversation preview - last user message or default text\r\n */\r\nexport const getConversationPreview = (conv: LexAIConversation): string => {\r\n  // Find the last non-system message\r\n  const userMessages = conv.messages.filter(m => m.role === 'user');\r\n  if (userMessages.length > 0) {\r\n    const lastUserMessage = userMessages[userMessages.length - 1];\r\n    return lastUserMessage.content.length > 40\r\n      ? lastUserMessage.content.substring(0, 40) + '...'\r\n      : lastUserMessage.content;\r\n  }\r\n\r\n  // If no user messages, return a default\r\n  return 'New conversation';\r\n};\r\n\r\n/**\r\n * Get greeting message based on time of day and mode\r\n */\r\nexport const getGreeting = (userName: string, isAgentMode: boolean): string => {\r\n  // Get the current hour to determine time of day\r\n  const currentHour = new Date().getHours();\r\n  // Create time-based greeting\r\n  let timeGreeting = '';\r\n  if (currentHour >= 5 && currentHour < 12) {\r\n    timeGreeting = `Good morning, ${userName}!`;\r\n  } else if (currentHour >= 12 && currentHour < 18) {\r\n    timeGreeting = `Good afternoon, ${userName}!`;\r\n  } else {\r\n    timeGreeting = `Good evening, ${userName}!`;\r\n  }\r\n\r\n  // Add mode-specific message after the time greeting\r\n  if (isAgentMode) {\r\n    return `Hi! I'm LexAI in Agent Mode. I can help with tasks, navigation and searches. How can I assist?`;\r\n  } else {\r\n    return `Hi! I'm LexAI in Chat Mode. What would you like to talk about?`;\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch search results from Google Custom Search API\r\n */\r\nexport const fetchSearchResults = async (\r\n  query: string,\r\n): Promise<SearchResult[]> => {\r\n  logDebug(`Fetching search results for: ${query}`);\r\n\r\n  try {\r\n    // Using Google Custom Search JSON API\r\n    // To set up:\r\n    // 1. Create a Google Cloud project: https://console.cloud.google.com/\r\n    // 2. Enable the Custom Search API\r\n    // 3. Create API credentials\r\n    // 4. Create a Custom Search Engine: https://cse.google.com/cse/all\r\n\r\n    // Get the API keys from environment variables or config\r\n    // Add these to your .env file or configuration\r\n    const apiKey = Config.GOOGLE_SEARCH_API_KEY || 'YOUR_GOOGLE_API_KEY';\r\n    const searchEngineId =\r\n      Config.GOOGLE_SEARCH_ENGINE_ID || 'YOUR_SEARCH_ENGINE_ID';\r\n\r\n    // Check if keys are properly configured\r\n    if (\r\n      apiKey === 'YOUR_GOOGLE_API_KEY' ||\r\n      searchEngineId === 'YOUR_SEARCH_ENGINE_ID'\r\n    ) {\r\n      logDebug('Google Search API keys not configured', {\r\n        apiKeyConfigured: apiKey !== 'YOUR_GOOGLE_API_KEY',\r\n        searchEngineIdConfigured: searchEngineId !== 'YOUR_SEARCH_ENGINE_ID',\r\n      });\r\n      // If keys aren't configured, fall back to a direct Google search\r\n      return [\r\n        {\r\n          title: `Search results for \"${query}\"`,\r\n          url: `https://www.google.com/search?q=${encodeURIComponent(query)}`,\r\n          snippet: `Click here to see search results for \"${query}\"`,\r\n        },\r\n      ];\r\n    }\r\n\r\n    const url = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${searchEngineId}&q=${encodeURIComponent(query)}`;\r\n\r\n    const response = await axios.get(url);\r\n\r\n    // Check if we got valid results\r\n    if (\r\n      response.status !== 200 ||\r\n      !response.data.items ||\r\n      !response.data.items.length\r\n    ) {\r\n      logDebug('No search results or invalid response', {\r\n        status: response.status,\r\n        hasItems: !!response.data.items,\r\n      });\r\n      return [];\r\n    }\r\n\r\n    // Map Google's response format to our SearchResult interface\r\n    return response.data.items\r\n      .map((item: any) => ({\r\n        title: item.title,\r\n        url: item.link,\r\n        snippet: item.snippet,\r\n      }))\r\n      .slice(0, 5); // Limit to 5 results for better UX\r\n  } catch (error) {\r\n    logDebug('Error in Google Search API call', {error: String(error)});\r\n    console.error('Google Search API Error:', error);\r\n\r\n    // Fallback to direct Google search if API call fails\r\n    return [\r\n      {\r\n        title: `Search results for \"${query}\"`,\r\n        url: `https://www.google.com/search?q=${encodeURIComponent(query)}`,\r\n        snippet: `Click here to see search results for \"${query}\"`,\r\n      },\r\n    ];\r\n  }\r\n};\r\n\r\n/**\r\n * Check if message is a direct search command\r\n */\r\nexport const isDirectSearchCommand = (message: string): boolean => {\r\n  return message.toLowerCase().startsWith('search ');\r\n};\r\n\r\n/**\r\n * Check if message is a post search request\r\n */\r\nexport const isPostSearchRequest = (message: string): boolean => {\r\n  const lowerMessage = message.toLowerCase();\r\n  return (\r\n    lowerMessage.startsWith('find posts ') ||\r\n    lowerMessage.startsWith('search posts ') ||\r\n    lowerMessage.startsWith('look for posts ') ||\r\n    lowerMessage.includes(' posts about ') ||\r\n    lowerMessage.includes('post with ')\r\n  );\r\n};\r\n\r\n/**\r\n * Extract search query from a search command\r\n */\r\nexport const extractSearchQuery = (message: string): string => {\r\n  let searchQuery = message;\r\n  const lowerMessage = message.toLowerCase();\r\n\r\n  if (lowerMessage.startsWith('search ')) {\r\n    searchQuery = message.substring(7);\r\n  } else if (lowerMessage.startsWith('find ')) {\r\n    searchQuery = message.substring(5);\r\n  } else if (lowerMessage.startsWith('look up ')) {\r\n    searchQuery = message.substring(8);\r\n  }\r\n\r\n  return searchQuery.trim();\r\n};\r\n\r\n/**\r\n * Extract post search query from a post search request\r\n */\r\nexport const extractPostSearchQuery = (message: string): string => {\r\n  let searchQuery = message;\r\n  const lowerMessage = message.toLowerCase();\r\n\r\n  if (lowerMessage.startsWith('find posts ')) {\r\n    searchQuery = message.substring(11);\r\n  } else if (lowerMessage.startsWith('search posts ')) {\r\n    searchQuery = message.substring(13);\r\n  } else if (lowerMessage.startsWith('look for posts ')) {\r\n    searchQuery = message.substring(15);\r\n  } else if (lowerMessage.includes(' posts about ')) {\r\n    searchQuery = message.substring(lowerMessage.indexOf(' posts about ') + 13);\r\n  } else if (lowerMessage.includes('post with ')) {\r\n    searchQuery = message.substring(lowerMessage.indexOf('post with ') + 10);\r\n  }\r\n\r\n  return searchQuery.trim();\r\n};\r\n\r\n/**\r\n * Check if a search query likely refers to posts\r\n */\r\nexport const isLikelyPostSearch = (query: string): boolean => {\r\n  const postKeywords = [\r\n    'post',\r\n    'posts',\r\n    'article',\r\n    'articles',\r\n    'tutorial',\r\n    'content',\r\n  ];\r\n  return postKeywords.some(keyword => query.toLowerCase().includes(keyword));\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\Chat.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\ChatInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\ChatMessageItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\ChatPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\ControlBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\CreateRoomForm.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { flexDirection: 'row' }","line":63,"column":30,"nodeType":"ObjectExpression","endLine":63,"endColumn":54},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { flex: 1 }","line":69,"column":29,"nodeType":"ObjectExpression","endLine":69,"endColumn":40},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":75,"column":39,"nodeType":"ObjectExpression","endLine":75,"endColumn":76},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#888888' : '#666666'\" }","line":76,"column":39,"nodeType":"ObjectExpression","endLine":76,"endColumn":80},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: \"isDark ? '#333' : '#f0f0f0'\",\n  borderColor: \"isDark ? '#444' : '#ddd'\"\n}","line":88,"column":33,"nodeType":"ObjectExpression","endLine":91,"endColumn":34},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDark ? '#ff3b30' : '#ff3b30'\",\n  marginVertical: 'auto',\n  fontSize: 18,\n  paddingBottom: 3\n}","line":95,"column":40,"nodeType":"ObjectExpression","endLine":100,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { View, Text, TextInput, TouchableOpacity } from 'react-native';\r\nimport { CreateRoomFormProps } from '../types';\r\nimport { styles } from '../styles/Room';\r\n\r\n/**\r\n * Form component for creating a new meeting room\r\n */\r\nexport const CreateRoomForm: React.FC<CreateRoomFormProps> = ({\r\n    meetingRoom,\r\n    onMeetingRoomChange,\r\n    selectedTask,\r\n    onShowTaskModal,\r\n    onClearTask,\r\n    onCreateRoom,\r\n    loading,\r\n    isDark,\r\n}) => {\r\n    return (\r\n        <View style={styles.form}>\r\n            <View style={styles.inputGroup}>\r\n                <Text style={[styles.label, isDark && styles.darkText]}>\r\n                    Meeting Title\r\n                </Text>\r\n                <TextInput\r\n                    style={[\r\n                        styles.input,\r\n                        isDark && styles.darkInput,\r\n                        isDark && styles.darkText,\r\n                    ]}\r\n                    placeholder=\"Enter meeting title\"\r\n                    placeholderTextColor={isDark ? '#888888' : '#666666'}\r\n                    value={meetingRoom.title}\r\n                    onChangeText={text => onMeetingRoomChange({ title: text })}\r\n                />\r\n            </View>\r\n\r\n            <View style={styles.inputGroup}>\r\n                <Text style={[styles.label, isDark && styles.darkText]}>\r\n                    Description\r\n                </Text>\r\n                <TextInput\r\n                    style={[\r\n                        styles.input,\r\n                        styles.textArea,\r\n                        isDark && styles.darkInput,\r\n                        isDark && styles.darkText,\r\n                    ]}\r\n                    placeholder=\"Enter meeting description\"\r\n                    placeholderTextColor={isDark ? '#888888' : '#666666'}\r\n                    multiline\r\n                    numberOfLines={4}\r\n                    value={meetingRoom.description}\r\n                    onChangeText={text => onMeetingRoomChange({ description: text })}\r\n                />\r\n            </View>\r\n\r\n            {/* Task selection */}\r\n            <View style={styles.inputGroup}>\r\n                <Text style={[styles.label, isDark && styles.darkText]}>\r\n                    Associated Team Task (Optional)\r\n                </Text>\r\n                <View style={{ flexDirection: 'row' }}>\r\n                    <TouchableOpacity\r\n                        style={[\r\n                            styles.input,\r\n                            styles.taskSelector,\r\n                            isDark && styles.darkInput,\r\n                            { flex: 1 },\r\n                        ]}\r\n                        onPress={onShowTaskModal}>\r\n                        <Text\r\n                            style={[\r\n                                selectedTask\r\n                                    ? { color: isDark ? 'white' : 'black' }\r\n                                    : { color: isDark ? '#888888' : '#666666' },\r\n                            ]}>\r\n                            {selectedTask\r\n                                ? selectedTask.title\r\n                                : 'Select a team task for this meeting'}\r\n                        </Text>\r\n                    </TouchableOpacity>\r\n\r\n                    {selectedTask && (\r\n                        <TouchableOpacity\r\n                            style={[\r\n                                styles.clearButton,\r\n                                {\r\n                                    backgroundColor: isDark ? '#333' : '#f0f0f0',\r\n                                    borderColor: isDark ? '#444' : '#ddd',\r\n                                },\r\n                            ]}\r\n                            onPress={onClearTask}>\r\n                            <Text\r\n                                style={{\r\n                                    color: isDark ? '#ff3b30' : '#ff3b30',\r\n                                    marginVertical: 'auto',\r\n                                    fontSize: 18,\r\n                                    paddingBottom: 3,\r\n                                }}>\r\n                                \r\n                            </Text>\r\n                        </TouchableOpacity>\r\n                    )}\r\n                </View>\r\n            </View>\r\n\r\n            <View style={styles.inputGroup}>\r\n                <Text style={[styles.label, isDark && styles.darkText]}>\r\n                    Duration (minutes)\r\n                </Text>\r\n                <TextInput\r\n                    style={[\r\n                        styles.input,\r\n                        isDark && styles.darkInput,\r\n                        isDark && styles.darkText,\r\n                    ]}\r\n                    placeholder=\"Enter meeting duration\"\r\n                    placeholderTextColor={isDark ? '#888888' : '#666666'}\r\n                    keyboardType=\"number-pad\"\r\n                    value={meetingRoom.duration.toString()}\r\n                    onChangeText={text =>\r\n                        onMeetingRoomChange({ duration: parseInt(text, 10) || 0 })\r\n                    }\r\n                />\r\n            </View>\r\n\r\n            <View style={styles.inputGroup}>\r\n                <Text style={[styles.label, isDark && styles.darkText]}>Capacity</Text>\r\n                <TextInput\r\n                    style={[\r\n                        styles.input,\r\n                        isDark && styles.darkInput,\r\n                        isDark && styles.darkText,\r\n                    ]}\r\n                    placeholder=\"Enter participant capacity\"\r\n                    placeholderTextColor={isDark ? '#888888' : '#666666'}\r\n                    keyboardType=\"number-pad\"\r\n                    value={meetingRoom.capacity.toString()}\r\n                    onChangeText={text =>\r\n                        onMeetingRoomChange({ capacity: parseInt(text, 10) || 0 })\r\n                    }\r\n                />\r\n            </View>\r\n\r\n            <TouchableOpacity\r\n                style={[styles.button, loading && styles.buttonDisabled]}\r\n                onPress={onCreateRoom}\r\n                disabled={loading}>\r\n                <Text style={styles.buttonText}>\r\n                    {loading ? 'Creating...' : 'Create Meeting'}\r\n                </Text>\r\n            </TouchableOpacity>\r\n        </View>\r\n    );\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\EditMessageModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\EmptyState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\JoinRoomForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\MessageContextMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\MessageReactionsMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\ParticipantGrid.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { zIndex: 'isPinned ? 10 : 1' }","line":59,"column":21,"nodeType":"ObjectExpression","endLine":63,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { View, Dimensions } from 'react-native';\r\nimport { LegendList } from '@legendapp/list';\r\nimport ParticipantItem from './ParticipantItem';\r\nimport { ParticipantGridProps } from '../types';\r\nimport { calculateGridLayout, calculateUnpinnedLayout } from '../utils/layout';\r\nimport { styles } from '../styles/RoomComponent.styles';\r\n\r\nconst ParticipantGrid: React.FC<ParticipantGridProps> = ({\r\n    participants,\r\n    currentUserId,\r\n    pinnedParticipantId,\r\n    participantStates,\r\n    isAudioEnabled,\r\n    isVideoEnabled,\r\n    onPinParticipant,\r\n}) => {\r\n    const { height } = Dimensions.get('window');\r\n    const totalParticipants = participants.length;\r\n\r\n    // Check if any participant is screen sharing\r\n    const screenSharingParticipant = participants.find(\r\n        p => participantStates.get(p.id)?.isScreenSharing,\r\n    );\r\n\r\n    const screenSharingId = screenSharingParticipant?.id;\r\n\r\n    // Calculate layout\r\n    const layout = calculateGridLayout(\r\n        totalParticipants,\r\n        screenSharingId,\r\n        pinnedParticipantId,\r\n        height,\r\n    );\r\n\r\n    // If there's a pinned participant and multiple participants, calculate unpinned layout\r\n    const unpinnedLayout =\r\n        pinnedParticipantId && totalParticipants > 1\r\n            ? calculateUnpinnedLayout(totalParticipants - 1, height)\r\n            : null;\r\n\r\n    const renderGridItem = ({ item, index }: { item: any; index: number }) => {\r\n        const isItemScreenSharing = participantStates.get(\r\n            item.id,\r\n        )?.isScreenSharing;\r\n        const isPinned =\r\n            item.id === pinnedParticipantId ||\r\n            (item.id === currentUserId && isItemScreenSharing);\r\n        const isCurrentUser = item.id === currentUserId;\r\n\r\n        // Determine which layout to use\r\n        const isPinnedItem = index === 0 && pinnedParticipantId === item.id;\r\n        const currentLayout = isPinnedItem ? layout : unpinnedLayout || layout;\r\n\r\n        return (\r\n            <View\r\n                style={[\r\n                    styles.participantWrapper,\r\n                    {\r\n                        width: `${100 / currentLayout.numColumns}%`,\r\n                        height: currentLayout.itemHeight,\r\n                        zIndex: isPinned ? 10 : 1,\r\n                    },\r\n                ]}>\r\n                <ParticipantItem\r\n                    participant={item}\r\n                    isCurrentUser={isCurrentUser}\r\n                    isPinned={isPinned}\r\n                    isAudioEnabled={isAudioEnabled}\r\n                    isVideoEnabled={isVideoEnabled}\r\n                    onLongPress={onPinParticipant}\r\n                />\r\n            </View>\r\n        );\r\n    };\r\n\r\n    return (\r\n        <LegendList\r\n            data={participants}\r\n            renderItem={renderGridItem}\r\n            keyExtractor={item => item.id}\r\n            style={styles.participantsList}\r\n            contentContainerStyle={styles.participantsListContent}\r\n            showsVerticalScrollIndicator={true}\r\n            numColumns={layout.numColumns}\r\n            key={layout.numColumns}\r\n            estimatedItemSize={300}\r\n        />\r\n    );\r\n};\r\n\r\nexport default ParticipantGrid;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\ParticipantItem.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { flex: 1 }","line":39,"column":20,"nodeType":"ObjectExpression","endLine":39,"endColumn":31},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: 'rgba(0,0,0,0.2)' }","line":46,"column":48,"nodeType":"ObjectExpression","endLine":46,"endColumn":86},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: \"isPinned ? '#1f1f1f' : 'rgba(0,0,0,0.2)'\" }","line":60,"column":29,"nodeType":"ObjectExpression","endLine":60,"endColumn":90}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { View, Text, TouchableOpacity } from 'react-native';\r\nimport { RTCView } from 'react-native-webrtc';\r\nimport Icon from 'react-native-vector-icons/MaterialIcons';\r\nimport ReactionText from 'room/components/common/ReactionText';\r\nimport { ParticipantItemProps } from '../types';\r\nimport { getAvatarInfo } from '../utils/avatar';\r\nimport { styles } from '../styles/RoomComponent.styles';\r\n\r\nconst ParticipantItem: React.FC<ParticipantItemProps> = ({\r\n    participant,\r\n    isCurrentUser,\r\n    isPinned = false,\r\n    isAudioEnabled,\r\n    isVideoEnabled,\r\n    onLongPress,\r\n}) => {\r\n    const participantState = participant.state || {};\r\n    const isVideoOn = isCurrentUser\r\n        ? isVideoEnabled\r\n        : (participantState.isVideoEnabled ?? true);\r\n    const isAudioOn = isCurrentUser\r\n        ? isAudioEnabled\r\n        : (participantState.isAudioEnabled ?? true);\r\n    const isParticipantHandRaised = participantState.isHandRaised ?? false;\r\n    const isParticipantSpeaking = participantState.isSpeaking ?? false;\r\n    const hasThumbsUp = participantState.isThumbsUp ?? false;\r\n    const hasThumbsDown = participantState.isThumbsDown ?? false;\r\n    const isClapping = participantState.isClapping ?? false;\r\n    const isWaving = participantState.isWaving ?? false;\r\n    const isSmiling = participantState.isSmiling ?? false;\r\n\r\n    const avatarInfo = getAvatarInfo(participant.id, participant.name);\r\n\r\n    return (\r\n        <TouchableOpacity\r\n            onLongPress={() => onLongPress(participant.id)}\r\n            activeOpacity={1}\r\n            style={{ flex: 1 }}>\r\n            <View\r\n                style={[\r\n                    styles.participantContainer,\r\n                    isParticipantSpeaking && styles.participantSpeakingContainer,\r\n                    styles.participantPinnedContainer,\r\n                    isCurrentUser && styles.currentUserContainer,\r\n                    !isPinned && !isVideoOn && { backgroundColor: 'rgba(0,0,0,0.2)' },\r\n                ]}>\r\n                {/* RTCView or Placeholder */}\r\n                {participant.stream && isVideoOn ? (\r\n                    <RTCView\r\n                        streamURL={participant.stream.toURL()}\r\n                        style={styles.participantVideo}\r\n                        objectFit=\"cover\"\r\n                        mirror={isCurrentUser}\r\n                    />\r\n                ) : (\r\n                    <View\r\n                        style={[\r\n                            styles.videoPlaceholder,\r\n                            { backgroundColor: isPinned ? '#1f1f1f' : 'rgba(0,0,0,0.2)' },\r\n                        ]}>\r\n                        <View\r\n                            style={[\r\n                                styles.avatarCircle,\r\n                                { backgroundColor: avatarInfo.backgroundColor },\r\n                                isParticipantSpeaking && styles.avatarCircleSpeaking,\r\n                            ]}>\r\n                            <Text style={[styles.avatarText, { color: avatarInfo.textColor }]}>\r\n                                {avatarInfo.initials}\r\n                            </Text>\r\n                        </View>\r\n                    </View>\r\n                )}\r\n\r\n                {/* Indicators */}\r\n                {!isAudioOn && (\r\n                    <View style={styles.audioOffIndicator}>\r\n                        <Icon name=\"mic-off\" size={20} color=\"#fff\" />\r\n                    </View>\r\n                )}\r\n                {isParticipantSpeaking && isAudioOn && (\r\n                    <View style={styles.speakingIndicator}>\r\n                        <Icon name=\"volume-up\" size={20} color=\"#fff\" />\r\n                    </View>\r\n                )}\r\n                {isParticipantHandRaised && (\r\n                    <View style={styles.handRaisedIndicator}>\r\n                        <ReactionText text=\"\" />\r\n                    </View>\r\n                )}\r\n                {hasThumbsUp && (\r\n                    <View style={styles.reactionIndicator}>\r\n                        <ReactionText text=\"\" />\r\n                    </View>\r\n                )}\r\n                {hasThumbsDown && (\r\n                    <View style={[styles.reactionIndicator, styles.thumbsDownIndicator]}>\r\n                        <ReactionText text=\"\" />\r\n                    </View>\r\n                )}\r\n                {isClapping && (\r\n                    <View style={[styles.reactionIndicator, styles.clappingIndicator]}>\r\n                        <ReactionText text=\"\" />\r\n                    </View>\r\n                )}\r\n                {isSmiling && (\r\n                    <View style={[styles.reactionIndicator, styles.clappingIndicator]}>\r\n                        <ReactionText text=\"\" />\r\n                    </View>\r\n                )}\r\n                {isWaving && (\r\n                    <View style={[styles.reactionIndicator, styles.wavingIndicator]}>\r\n                        <Text className=\"text-2xl font-bold\"></Text>\r\n                    </View>\r\n                )}\r\n\r\n                {/* Name Tag */}\r\n                <View\r\n                    style={[\r\n                        styles.nameTag,\r\n                        isCurrentUser && styles.currentUserNameTag,\r\n                        isParticipantSpeaking && styles.speakingNameTag,\r\n                    ]}>\r\n                    <View style={styles.nameTagContent}>\r\n                        {isCurrentUser && (\r\n                            <View style={styles.youIndicator}>\r\n                                <Text style={styles.youIndicatorText}>YOU</Text>\r\n                            </View>\r\n                        )}\r\n                        <Text\r\n                            style={[\r\n                                styles.nameText,\r\n                                isCurrentUser && styles.currentUserNameText,\r\n                            ]}>\r\n                            {participant.name}\r\n                        </Text>\r\n                        {participant.email && (\r\n                            <Text\r\n                                style={styles.emailText}\r\n                                numberOfLines={1}\r\n                                ellipsizeMode=\"middle\">\r\n                                {participant.email}\r\n                            </Text>\r\n                        )}\r\n                    </View>\r\n                </View>\r\n\r\n                {/* Pin indicator */}\r\n                {isPinned && (\r\n                    <View style={styles.pinnedIndicator}>\r\n                        <Icon name=\"push-pin\" size={16} color=\"#fff\" />\r\n                    </View>\r\n                )}\r\n            </View>\r\n        </TouchableOpacity>\r\n    );\r\n};\r\n\r\nexport default ParticipantItem;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\ParticipantsPanel.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":61,"column":29,"nodeType":"ObjectExpression","endLine":61,"endColumn":66}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { View, TouchableOpacity, Text, Animated } from 'react-native';\r\nimport { LegendList } from '@legendapp/list';\r\nimport Icon from 'react-native-vector-icons/MaterialIcons';\r\nimport AntDesign from 'react-native-vector-icons/AntDesign';\r\nimport { ParticipantsPanelProps } from '../types';\r\nimport { getAvatarInfo } from '../utils/avatar';\r\nimport { styles } from '../styles/RoomComponent.styles';\r\n\r\nconst ParticipantsPanel: React.FC<ParticipantsPanelProps> = ({\r\n    participants,\r\n    currentUserId,\r\n    pinnedParticipantId,\r\n    participantStates: _participantStates,\r\n    isAudioEnabled,\r\n    isVideoEnabled,\r\n    isDark,\r\n    showParticipants,\r\n    participantsPanelOpacity,\r\n    onClose,\r\n    onPinParticipant,\r\n}) => {\r\n    const renderParticipantListItem = ({ item }: { item: any }) => {\r\n        const participantState = item.state || {};\r\n        const isCurrentUser = item.id === currentUserId;\r\n        const isVideoOn = isCurrentUser\r\n            ? isVideoEnabled\r\n            : (participantState.isVideoEnabled ?? true);\r\n        const isAudioOn = isCurrentUser\r\n            ? isAudioEnabled\r\n            : (participantState.isAudioEnabled ?? true);\r\n        const isParticipantSpeaking = participantState.isSpeaking ?? false;\r\n        const isMicMuted = !isAudioOn;\r\n        const isVideoMuted = !isVideoOn;\r\n\r\n        const avatarInfo = getAvatarInfo(item.id, item.name);\r\n\r\n        return (\r\n            <TouchableOpacity\r\n                style={styles.participantListItem}\r\n                onPress={() => onPinParticipant(item.id)}>\r\n                <View style={styles.participantListItemAvatarContainer}>\r\n                    <View\r\n                        style={[\r\n                            styles.participantListItemAvatar,\r\n                            { backgroundColor: avatarInfo.backgroundColor },\r\n                        ]}>\r\n                        <Text\r\n                            style={[\r\n                                styles.participantListItemAvatarText,\r\n                                { color: avatarInfo.textColor },\r\n                            ]}>\r\n                            {avatarInfo.initials}\r\n                        </Text>\r\n                    </View>\r\n                </View>\r\n                <View style={styles.participantListItemInfo}>\r\n                    <Text\r\n                        style={[\r\n                            styles.participantListItemName,\r\n                            { color: isDark ? 'white' : 'black' },\r\n                        ]}\r\n                        numberOfLines={1}>\r\n                        {item.name} {isCurrentUser && '(You)'}\r\n                    </Text>\r\n                    {item.email && (\r\n                        <Text\r\n                            style={styles.participantListItemEmail}\r\n                            numberOfLines={1}\r\n                            ellipsizeMode=\"middle\">\r\n                            {item.email}\r\n                        </Text>\r\n                    )}\r\n                </View>\r\n                <View style={styles.participantListItemActions}>\r\n                    {isParticipantSpeaking && (\r\n                        <Icon name=\"volume-up\" size={22} color=\"#4285f4\" />\r\n                    )}\r\n                    {isMicMuted ? (\r\n                        <Icon name=\"mic-off\" size={22} color=\"#d66b6b\" />\r\n                    ) : (\r\n                        <Icon name=\"mic\" size={22} color=\"#9aa0a6\" />\r\n                    )}\r\n                    {isVideoMuted ? (\r\n                        <Icon name=\"videocam-off\" size={22} color=\"#d66b6b\" />\r\n                    ) : (\r\n                        <Icon name=\"videocam\" size={22} color=\"#9aa0a6\" />\r\n                    )}\r\n                    <TouchableOpacity\r\n                        onPress={() => onPinParticipant(item.id)}\r\n                        style={styles.participantListItemMoreButton}>\r\n                        <AntDesign\r\n                            name=\"pushpin\"\r\n                            size={22}\r\n                            color={pinnedParticipantId === item.id ? '#2196f3' : '#9aa0a6'}\r\n                        />\r\n                    </TouchableOpacity>\r\n                </View>\r\n            </TouchableOpacity>\r\n        );\r\n    };\r\n\r\n    if (!showParticipants) {\r\n        return null;\r\n    }\r\n\r\n    return (\r\n        <Animated.View\r\n            style={[\r\n                styles.fullScreenPanel,\r\n                isDark ? styles.fullScreenPanelDark : styles.fullScreenPanelLight,\r\n                { opacity: participantsPanelOpacity },\r\n            ]}>\r\n            <View style={[styles.panelHeader, isDark && styles.panelHeaderDark]}>\r\n                <TouchableOpacity onPress={onClose} style={styles.backButton}>\r\n                    <Icon name=\"arrow-back\" size={24} color={isDark ? '#fff' : '#000'} />\r\n                </TouchableOpacity>\r\n                <Text style={[styles.panelTitle, isDark && styles.panelTitleDark]}>\r\n                    Participants ({participants.length})\r\n                </Text>\r\n            </View>\r\n\r\n            <LegendList\r\n                data={participants}\r\n                renderItem={renderParticipantListItem}\r\n                keyExtractor={item => item.id}\r\n                style={[styles.participantsList, isDark && styles.participantsListDark]}\r\n                estimatedItemSize={70}\r\n                recycleItems={true}\r\n            />\r\n        </Animated.View>\r\n    );\r\n};\r\n\r\nexport default ParticipantsPanel;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\QuickMessagesMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\ReactionsMenu.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'View' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { View, TouchableOpacity, Text, Animated } from 'react-native';\r\nimport { ReactionsMenuProps } from '../types';\r\nimport { styles } from '../styles/RoomComponent.styles';\r\n\r\nconst ReactionsMenu: React.FC<ReactionsMenuProps> = ({\r\n    showReactions,\r\n    reactionsMenuOpacity,\r\n    onReaction,\r\n}) => {\r\n    if (!showReactions) {\r\n        return null;\r\n    }\r\n\r\n    return (\r\n        <Animated.View\r\n            style={[styles.reactionsMenu, { opacity: reactionsMenuOpacity }]}>\r\n            <TouchableOpacity\r\n                style={styles.reactionButton}\r\n                onPress={() => onReaction('thumbsUp')}>\r\n                <Text className=\"text-2xl font-bold\"></Text>\r\n            </TouchableOpacity>\r\n\r\n            <TouchableOpacity\r\n                style={styles.reactionButton}\r\n                onPress={() => onReaction('thumbsDown')}>\r\n                <Text className=\"text-2xl font-bold\"></Text>\r\n            </TouchableOpacity>\r\n\r\n            <TouchableOpacity\r\n                style={styles.reactionButton}\r\n                onPress={() => onReaction('clapping')}>\r\n                <Text className=\"text-2xl font-bold\"></Text>\r\n            </TouchableOpacity>\r\n\r\n            <TouchableOpacity\r\n                style={styles.reactionButton}\r\n                onPress={() => onReaction('smiling')}>\r\n                <Text className=\"text-2xl font-bold\"></Text>\r\n            </TouchableOpacity>\r\n        </Animated.View>\r\n    );\r\n};\r\n\r\nexport default ReactionsMenu;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\Room.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has a missing dependency: 'uiState'. Either include it or remove the dependency array.","line":55,"column":6,"nodeType":"ArrayExpression","endLine":55,"endColumn":40,"suggestions":[{"desc":"Update the dependencies array to be: [participantStates, currentUserId, uiState]","fix":{"range":[2019,2053],"text":"[participantStates, currentUserId, uiState]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState, useMemo, useCallback } from 'react';\r\nimport { View, TouchableOpacity, KeyboardAvoidingView, Platform, Animated } from 'react-native';\r\nimport { SafeAreaView } from 'react-native-safe-area-context';\r\nimport { UserService } from 'shared/services/UserService';\r\nimport { RoomProps } from '../types';\r\nimport { useRoomUIState } from '../hooks';\r\nimport ParticipantGrid from './ParticipantGrid';\r\nimport ControlBar from './ControlBar';\r\nimport ChatPanel from './ChatPanel';\r\nimport ReactionsMenu from './ReactionsMenu';\r\nimport ParticipantsPanel from './ParticipantsPanel';\r\nimport EmptyState from './EmptyState';\r\nimport QuickMessagesMenu from './QuickMessagesMenu';\r\nimport MessageReactionsMenu from './MessageReactionsMenu';\r\nimport { styles } from '../styles/RoomComponent.styles';\r\n\r\nconst Room: React.FC<RoomProps> = ({\r\n  meeting,\r\n  localStream,\r\n  remoteStreams,\r\n  onToggleAudio,\r\n  onToggleVideo,\r\n  onEndCall,\r\n  onSendMessage,\r\n  onMessageReaction,\r\n  messages,\r\n  isAudioEnabled,\r\n  isVideoEnabled,\r\n  isDark = false,\r\n  currentUserId,\r\n  currentUserName,\r\n  onRaiseHand,\r\n  onReaction,\r\n  participantStates,\r\n  isConnecting,\r\n  onFlipCamera,\r\n  isFrontCamera: propIsFrontCamera,\r\n}) => {\r\n  const [pinnedParticipantId, setPinnedParticipantId] = useState<string | null>(null);\r\n  const [userInfoCache, setUserInfoCache] = useState<Map<string, { email: string | null; fullName: string | null; username: string | null }>>(new Map());\r\n  const [localIsFrontCamera, setLocalIsFrontCamera] = useState(true);\r\n\r\n  const userService = useMemo(() => new UserService(), []);\r\n  const currentIsFrontCamera = propIsFrontCamera !== undefined ? propIsFrontCamera : localIsFrontCamera;\r\n\r\n  // Use UI state hook\r\n  const uiState = useRoomUIState();\r\n\r\n  // Update local hand raised state when participant states change\r\n  useEffect(() => {\r\n    const myState = participantStates.get(currentUserId);\r\n    if (myState) {\r\n      uiState.setIsHandRaised(myState.isHandRaised);\r\n    }\r\n  }, [participantStates, currentUserId]);\r\n\r\n  // Fetch and cache user info\r\n  const getUserInfo = useCallback(\r\n    async (userId: string) => {\r\n      if (userInfoCache.has(userId)) {\r\n        return userInfoCache.get(userId);\r\n      }\r\n\r\n      const userInfo = await userService.getUserInfoById(userId);\r\n      setUserInfoCache(prev => {\r\n        const newCache = new Map(prev);\r\n        newCache.set(userId, userInfo);\r\n        return newCache;\r\n      });\r\n\r\n      return userInfo;\r\n    },\r\n    [userInfoCache, userService],\r\n  );\r\n\r\n  useEffect(() => {\r\n    remoteStreams.forEach(async stream => {\r\n      const participantId = stream.participantId || stream.id;\r\n      if (participantId && !userInfoCache.has(participantId)) {\r\n        await getUserInfo(participantId);\r\n      }\r\n    });\r\n  }, [remoteStreams, getUserInfo, userInfoCache]);\r\n\r\n  // Action handlers\r\n  const handleRaiseHand = () => {\r\n    const newRaisedState = !uiState.isHandRaised;\r\n    uiState.setIsHandRaised(newRaisedState);\r\n    onRaiseHand(newRaisedState);\r\n  };\r\n\r\n  const handleReaction = (reaction: 'thumbsUp' | 'thumbsDown' | 'clapping' | 'waving' | 'smiling') => {\r\n    onReaction(reaction);\r\n    uiState.toggleReactionsMenu();\r\n  };\r\n\r\n  const handleMessageReaction = (reactionType: string) => {\r\n    if (uiState.selectedMessage) {\r\n      onMessageReaction(uiState.selectedMessage, reactionType);\r\n      uiState.closeMessageReactions();\r\n    }\r\n  };\r\n\r\n  const handleSendQuickMessage = (text: string) => {\r\n    onSendMessage(text);\r\n    uiState.toggleQuickMessagesMenu();\r\n  };\r\n\r\n  const handleFlipCamera = () => {\r\n    if (localStream && onFlipCamera) {\r\n      if (Platform.OS === 'android' || Platform.OS === 'ios') {\r\n        const Vibration = require('react-native').Vibration;\r\n        Vibration.vibrate(50);\r\n      }\r\n\r\n      const animateButtonPress = Animated.sequence([\r\n        Animated.timing(new Animated.Value(1), {\r\n          toValue: 0.8,\r\n          duration: 100,\r\n          useNativeDriver: true,\r\n        }),\r\n        Animated.timing(new Animated.Value(0.8), {\r\n          toValue: 1,\r\n          duration: 100,\r\n          useNativeDriver: true,\r\n        }),\r\n      ]);\r\n      animateButtonPress.start();\r\n\r\n      onFlipCamera();\r\n      setLocalIsFrontCamera(!currentIsFrontCamera);\r\n    } else if (localStream) {\r\n      localStream.getVideoTracks().forEach((track: any) => {\r\n        if (typeof track._switchCamera === 'function') {\r\n          track._switchCamera();\r\n          setLocalIsFrontCamera(!currentIsFrontCamera);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  const handlePinParticipant = (participantId: string) => {\r\n    if (pinnedParticipantId === participantId) {\r\n      setPinnedParticipantId(null);\r\n    } else {\r\n      setPinnedParticipantId(participantId);\r\n    }\r\n  };\r\n\r\n  // Get all participants with their info\r\n  const getAllParticipants = () => {\r\n    const participantsMap = new Map();\r\n\r\n    participantsMap.set(currentUserId, {\r\n      id: currentUserId,\r\n      name: currentUserName,\r\n      isLocal: true,\r\n      stream: localStream,\r\n    });\r\n\r\n    remoteStreams.forEach(stream => {\r\n      const participantId = stream.participantId || stream.id;\r\n      if (participantId) {\r\n        const userInfo = userInfoCache.get(participantId);\r\n        participantsMap.set(participantId, {\r\n          id: participantId,\r\n          name: userInfo?.fullName || userInfo?.username || `User ${participantId.substring(0, 5)}`,\r\n          isLocal: false,\r\n          stream: stream,\r\n        });\r\n      }\r\n    });\r\n\r\n    participantStates.forEach((state, id) => {\r\n      if (id !== currentUserId && !participantsMap.has(id)) {\r\n        const userInfo = userInfoCache.get(id);\r\n        participantsMap.set(id, {\r\n          id: id,\r\n          name: userInfo?.fullName || userInfo?.username || `User ${id.substring(0, 5)}`,\r\n          isLocal: false,\r\n          state: state,\r\n        });\r\n      } else if (participantsMap.has(id)) {\r\n        const participant = participantsMap.get(id);\r\n        participantsMap.set(id, {\r\n          ...participant,\r\n          state: state,\r\n        });\r\n      }\r\n    });\r\n\r\n    let participantsArray = Array.from(participantsMap.values());\r\n\r\n    if (pinnedParticipantId) {\r\n      const pinnedIndex = participantsArray.findIndex(p => p.id === pinnedParticipantId);\r\n      if (pinnedIndex > -1) {\r\n        const [pinnedParticipant] = participantsArray.splice(pinnedIndex, 1);\r\n        participantsArray.unshift(pinnedParticipant);\r\n      }\r\n    }\r\n\r\n    return participantsArray;\r\n  };\r\n\r\n  const getOrderedParticipantsForList = () => {\r\n    const allParticipants = getAllParticipants();\r\n    const currentUser = allParticipants.find(p => p.id === currentUserId);\r\n    const otherParticipants = allParticipants.filter(p => p.id !== currentUserId);\r\n    return currentUser ? [currentUser, ...otherParticipants] : allParticipants;\r\n  };\r\n\r\n  const participants = getAllParticipants();\r\n  const showEmptyState = !localStream || (remoteStreams.length === 0 && participantStates.size <= 1);\r\n\r\n  return (\r\n    <SafeAreaView style={[styles.container, isDark && styles.darkContainer]}>\r\n      <KeyboardAvoidingView\r\n        behavior={Platform.OS === 'ios' ? 'padding' : undefined}\r\n        style={styles.keyboardAvoidingView}>\r\n        <View style={styles.mainContainer}>\r\n          <TouchableOpacity\r\n            activeOpacity={1}\r\n            style={[styles.touchableContainer, isDark && styles.darkTouchableContainer]}\r\n            onPress={() => uiState.setIsControlsVisible(true)}>\r\n\r\n            <View style={styles.participantsGrid}>\r\n              {localStream && (\r\n                <ParticipantGrid\r\n                  participants={participants}\r\n                  currentUserId={currentUserId}\r\n                  pinnedParticipantId={pinnedParticipantId}\r\n                  participantStates={participantStates}\r\n                  isAudioEnabled={isAudioEnabled}\r\n                  isVideoEnabled={isVideoEnabled}\r\n                  onPinParticipant={handlePinParticipant}\r\n                />\r\n              )}\r\n\r\n              {showEmptyState && (\r\n                <EmptyState\r\n                  isConnecting={isConnecting}\r\n                  meetingTitle={meeting.title}\r\n                  roomCode={meeting.roomCode}\r\n                />\r\n              )}\r\n            </View>\r\n\r\n            <ControlBar\r\n              isControlsVisible={uiState.isControlsVisible}\r\n              isAudioEnabled={isAudioEnabled}\r\n              isVideoEnabled={isVideoEnabled}\r\n              isHandRaised={uiState.isHandRaised}\r\n              showChat={uiState.showChat}\r\n              showReactions={uiState.showReactions}\r\n              showParticipants={uiState.showParticipants}\r\n              showMoreControls={uiState.showMoreControls}\r\n              isFrontCamera={currentIsFrontCamera}\r\n              meetingTitle={meeting.title}\r\n              roomCode={meeting.roomCode}\r\n              onToggleAudio={onToggleAudio}\r\n              onToggleVideo={onToggleVideo}\r\n              onFlipCamera={handleFlipCamera}\r\n              onRaiseHand={handleRaiseHand}\r\n              onToggleChat={uiState.toggleChat}\r\n              onToggleReactions={uiState.toggleReactionsMenu}\r\n              onToggleParticipants={uiState.toggleParticipantsPanel}\r\n              onToggleMoreControls={uiState.setShowMoreControls}\r\n              onEndCall={onEndCall}\r\n            />\r\n          </TouchableOpacity>\r\n\r\n          <ReactionsMenu\r\n            showReactions={uiState.showReactions}\r\n            reactionsMenuOpacity={uiState.reactionsMenuOpacity}\r\n            onReaction={handleReaction}\r\n          />\r\n\r\n          <ChatPanel\r\n            messages={messages}\r\n            currentUserId={currentUserId}\r\n            isDark={isDark}\r\n            showChat={uiState.showChat}\r\n            chatPanelOpacity={uiState.chatPanelOpacity}\r\n            onClose={uiState.toggleChat}\r\n            onSendMessage={onSendMessage}\r\n            onLongPressMessage={uiState.handleLongPressMessage}\r\n            onToggleQuickMessages={uiState.toggleQuickMessagesMenu}\r\n          />\r\n\r\n          <QuickMessagesMenu\r\n            showQuickMessages={uiState.showQuickMessages}\r\n            quickMessagesMenuOpacity={uiState.quickMessagesMenuOpacity}\r\n            onClose={uiState.toggleQuickMessagesMenu}\r\n            onSendQuickMessage={handleSendQuickMessage}\r\n          />\r\n\r\n          <MessageReactionsMenu\r\n            showMessageReactions={uiState.showMessageReactions}\r\n            onClose={uiState.closeMessageReactions}\r\n            onReaction={handleMessageReaction}\r\n          />\r\n\r\n          <ParticipantsPanel\r\n            participants={getOrderedParticipantsForList()}\r\n            currentUserId={currentUserId}\r\n            pinnedParticipantId={pinnedParticipantId}\r\n            participantStates={participantStates}\r\n            isAudioEnabled={isAudioEnabled}\r\n            isVideoEnabled={isVideoEnabled}\r\n            isDark={isDark}\r\n            showParticipants={uiState.showParticipants}\r\n            participantsPanelOpacity={uiState.participantsPanelOpacity}\r\n            onClose={uiState.toggleParticipantsPanel}\r\n            onPinParticipant={handlePinParticipant}\r\n          />\r\n        </View>\r\n      </KeyboardAvoidingView>\r\n    </SafeAreaView>\r\n  );\r\n};\r\n\r\nexport default Room;","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\RoomLoadingIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\TabSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\TaskListItem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'StyleSheet' is defined but never used.","line":2,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":50},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: \"item.completed ? '#34C759' : '#1a9cd8'\" }","line":70,"column":29,"nodeType":"ObjectExpression","endLine":73,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { View, Text, TouchableOpacity, StyleSheet } from 'react-native';\r\nimport { TaskListItemProps } from '../types';\r\nimport { getPriorityColor } from '../utils/helpers';\r\nimport { styles } from '../styles/Room';\r\n\r\n/**\r\n * Component for rendering an individual task item in the task list\r\n */\r\nexport const TaskListItem: React.FC<TaskListItemProps> = ({\r\n    item,\r\n    onPress,\r\n    isDark,\r\n}) => {\r\n    return (\r\n        <TouchableOpacity\r\n            style={[\r\n                styles.taskItem,\r\n                isDark ? styles.taskItemBgDark : styles.taskItemBgLight,\r\n            ]}\r\n            onPress={() => onPress(item)}>\r\n            <View>\r\n                <Text\r\n                    style={[\r\n                        styles.taskItemTitle,\r\n                        isDark ? styles.textWhite : styles.textBlack,\r\n                    ]}>\r\n                    {item.title}\r\n                </Text>\r\n                {item.description ? (\r\n                    <Text\r\n                        style={[\r\n                            styles.taskItemDescription,\r\n                            isDark ? styles.descriptionTextDark : styles.descriptionTextLight,\r\n                        ]}\r\n                        numberOfLines={2}>\r\n                        {item.description}\r\n                    </Text>\r\n                ) : null}\r\n                <View style={styles.taskItemMetaRow}>\r\n                    <View style={styles.flexRow}>\r\n                        <Text\r\n                            style={[\r\n                                styles.taskItemDate,\r\n                                isDark ? styles.dateTextDark : styles.dateTextLight,\r\n                            ]}>\r\n                            {item.dueDate}\r\n                        </Text>\r\n                        <Text\r\n                            style={[\r\n                                styles.taskItemPriority,\r\n                                { color: getPriorityColor(item.priority) },\r\n                            ]}>\r\n                            {item.priority.toUpperCase()}\r\n                        </Text>\r\n                    </View>\r\n                    <Text style={styles.taskItemMemberBadge}>\r\n                        {item.collaborators?.length || 0} Members\r\n                    </Text>\r\n                </View>\r\n                {/* Progress bar */}\r\n                <View\r\n                    style={[\r\n                        styles.taskItemProgressTrack,\r\n                        isDark ? styles.progressTrackBgDark : styles.progressTrackBgLight,\r\n                    ]}>\r\n                    <View\r\n                        style={[\r\n                            styles.taskItemProgressFill,\r\n                            {\r\n                                width: `${item.progress || 0}%`,\r\n                                backgroundColor: item.completed ? '#34C759' : '#1a9cd8',\r\n                            },\r\n                        ]}\r\n                    />\r\n                </View>\r\n            </View>\r\n        </TouchableOpacity>\r\n    );\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\TaskSelectionModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\common\\MessageReactionIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\components\\common\\ReactionText.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\constants\\common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\constants\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\hooks\\useChatActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\hooks\\useChatMessages.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\hooks\\useRoomActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\hooks\\useRoomChat.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has missing dependencies: 'subscribeToMessages' and 'unsubscribeMessages'. Either include them or remove the dependency array.","line":102,"column":6,"nodeType":"ArrayExpression","endLine":102,"endColumn":17,"suggestions":[{"desc":"Update the dependencies array to be: [meetingId, subscribeToMessages, unsubscribeMessages]","fix":{"range":[3107,3118],"text":"[meetingId, subscribeToMessages, unsubscribeMessages]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\hooks\\useRoomConnection.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has missing dependencies: 'connectionAttempts', 'currentUser?.uid', 'meeting.participants', 'meetingService', 'onMeetingEnded', 'setupAudioLevelDetection', 'streamsByParticipant', and 'webRTCService'. Either include them or remove the dependency array. If 'onMeetingEnded' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":322,"column":6,"nodeType":"ArrayExpression","endLine":322,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [connectionAttempts, currentUser?.uid, meeting.id, meeting.participants, meetingService, onMeetingEnded, setupAudioLevelDetection, streamsByParticipant, webRTCService]","fix":{"range":[12130,12142],"text":"[connectionAttempts, currentUser?.uid, meeting.id, meeting.participants, meetingService, onMeetingEnded, setupAudioLevelDetection, streamsByParticipant, webRTCService]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\hooks\\useRoomForm.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\hooks\\useRoomMedia.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'WebRTCService' is defined but never used.","line":3,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {useState, useCallback} from 'react';\r\nimport {Alert} from 'react-native';\r\nimport {WebRTCService} from 'room/services/WebRTCService';\r\nimport {getAuth} from '@react-native-firebase/auth';\r\nimport {\r\n  ExtendedMediaStream,\r\n  UseRoomMediaParams,\r\n  UseRoomMediaReturn,\r\n} from '../types';\r\n\r\nexport const useRoomMedia = ({\r\n  meetingId,\r\n  localStream,\r\n  setLocalStream,\r\n  webRTCService,\r\n}: UseRoomMediaParams): UseRoomMediaReturn => {\r\n  const currentUser = getAuth().currentUser;\r\n\r\n  const [isAudioEnabled, setIsAudioEnabled] = useState(true);\r\n  const [isVideoEnabled, setIsVideoEnabled] = useState(true);\r\n  // Track camera facing mode for persistence across component re-renders\r\n  const [isFrontCamera, setIsFrontCamera] = useState(true);\r\n\r\n  const handleToggleAudio = useCallback(async () => {\r\n    if (localStream) {\r\n      const audioTracks = localStream.getAudioTracks();\r\n      if (audioTracks.length > 0) {\r\n        const audioTrack = audioTracks[0];\r\n        audioTrack.enabled = !audioTrack.enabled;\r\n        setIsAudioEnabled(audioTrack.enabled);\r\n\r\n        // Update participant state in Firestore\r\n        await webRTCService.updateLocalParticipantState(meetingId, {\r\n          isAudioEnabled: audioTrack.enabled,\r\n        });\r\n      }\r\n    }\r\n  }, [localStream, meetingId, webRTCService]);\r\n\r\n  const handleToggleVideo = useCallback(async () => {\r\n    if (localStream) {\r\n      const videoTracks = localStream.getVideoTracks();\r\n      if (videoTracks.length > 0) {\r\n        const videoTrack = videoTracks[0];\r\n        videoTrack.enabled = !videoTrack.enabled;\r\n        setIsVideoEnabled(videoTrack.enabled);\r\n\r\n        // Update participant state in Firestore\r\n        await webRTCService.updateLocalParticipantState(meetingId, {\r\n          isVideoEnabled: videoTrack.enabled,\r\n        });\r\n      }\r\n    }\r\n  }, [localStream, meetingId, webRTCService]);\r\n\r\n  // Handle camera flip between front and back\r\n  const handleFlipCamera = useCallback(async () => {\r\n    if (localStream) {\r\n      const videoTracks = localStream.getVideoTracks();\r\n      if (videoTracks.length > 0) {\r\n        try {\r\n          console.log(\r\n            `Flipping camera from ${isFrontCamera ? 'front' : 'back'} to ${isFrontCamera ? 'back' : 'front'}`,\r\n          );\r\n\r\n          // Use the native _switchCamera method available in react-native-webrtc\r\n          videoTracks.forEach(track => {\r\n            if (typeof track._switchCamera === 'function') {\r\n              track._switchCamera();\r\n              // Update camera facing mode state\r\n              setIsFrontCamera(!isFrontCamera);\r\n              console.log(\r\n                `Camera flipped successfully to ${!isFrontCamera ? 'front' : 'back'}`,\r\n              );\r\n            } else {\r\n              console.warn('_switchCamera method not available on this track');\r\n\r\n              // Fallback approach for browsers or platforms without _switchCamera\r\n              // This would require reinitializing the camera with opposite facing mode\r\n              // but is not implemented in this example as it requires renegotiation\r\n            }\r\n          });\r\n        } catch (error) {\r\n          console.error('Error flipping camera:', error);\r\n        }\r\n      } else {\r\n        console.warn('No video tracks available to flip camera');\r\n        Alert.alert('Camera Error', 'No video available to switch cameras');\r\n      }\r\n    } else {\r\n      console.warn('No local stream available to flip camera');\r\n      Alert.alert('Camera Error', 'Camera not initialized');\r\n    }\r\n  }, [localStream, isFrontCamera]);\r\n\r\n  // Add a function to handle local stream updates and renegotiate connections as needed\r\n  const handleLocalStreamUpdate = useCallback(\r\n    (stream: ExtendedMediaStream | null) => {\r\n      if (!stream) return;\r\n\r\n      try {\r\n        // Add participant ID if not already set\r\n        if (!stream.participantId) {\r\n          stream.participantId = currentUser?.uid;\r\n        }\r\n\r\n        console.log('Updating local stream:', stream.id);\r\n        console.log(\r\n          'Stream tracks:',\r\n          stream\r\n            .getTracks()\r\n            .map(t => `${t.kind}:${t.enabled}`)\r\n            .join(', '),\r\n        );\r\n\r\n        // Update the local stream in WebRTCService - this will trigger renegotiation\r\n        webRTCService\r\n          .updateLocalStream(stream, meetingId)\r\n          .then(() => {\r\n            console.log(\r\n              'Local stream updated successfully and connections renegotiated',\r\n            );\r\n          })\r\n          .catch((error: Error) => {\r\n            console.error('Error updating local stream:', error);\r\n          });\r\n\r\n        // Update local state\r\n        setLocalStream(stream);\r\n      } catch (error) {\r\n        console.error('Error in handleLocalStreamUpdate:', error);\r\n      }\r\n    },\r\n    [currentUser?.uid, meetingId, setLocalStream, webRTCService],\r\n  );\r\n\r\n  return {\r\n    isAudioEnabled,\r\n    isVideoEnabled,\r\n    isFrontCamera,\r\n    handleToggleAudio,\r\n    handleToggleVideo,\r\n    handleFlipCamera,\r\n    handleLocalStreamUpdate,\r\n  };\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\hooks\\useRoomNavigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\hooks\\useRoomUIState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\hooks\\useTaskSelection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\screens\\Room.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\screens\\RoomScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\services\\MeetingService.ts","messages":[{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":509,"column":37,"nodeType":"Identifier","messageId":"noShadow","endLine":509,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {getAuth} from '@react-native-firebase/auth';\r\nimport {\r\n  getFirestore,\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  updateDoc,\r\n  deleteDoc,\r\n  addDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  limit,\r\n  getDocs,\r\n  onSnapshot,\r\n  serverTimestamp,\r\n  arrayUnion,\r\n  arrayRemove,\r\n  writeBatch,\r\n  FirebaseFirestoreTypes,\r\n} from '@react-native-firebase/firestore';\r\nimport {generateRoomCode} from 'shared/helpers/common/roomCodeGenerator';\r\nimport {Meeting, MeetingError} from '../types';\r\n\r\nexport class MeetingService {\r\n  private meetingsCollection = collection(\r\n    getFirestore(),\r\n    'meetings',\r\n  ) as FirebaseFirestoreTypes.CollectionReference<Meeting>;\r\n  private unsubscribeMeeting: (() => void) | null = null;\r\n  private endTimeCheckInterval: NodeJS.Timeout | null = null;\r\n  private retryAttempts = 3;\r\n  private retryDelay = 1000; // 1 second\r\n\r\n  private async retryOperation<T>(\r\n    operation: () => Promise<T>,\r\n    customError?: string,\r\n  ): Promise<T> {\r\n    let lastError: Error | null = null;\r\n    for (let attempt = 1; attempt <= this.retryAttempts; attempt++) {\r\n      try {\r\n        return await operation();\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n        if (attempt < this.retryAttempts) {\r\n          await new Promise(resolve =>\r\n            setTimeout(resolve, this.retryDelay * attempt),\r\n          );\r\n        }\r\n      }\r\n    }\r\n    throw this.createError(\r\n      customError || 'Operation failed after multiple attempts',\r\n      lastError,\r\n    );\r\n  }\r\n\r\n  private createError(message: string, originalError?: any): MeetingError {\r\n    const error: MeetingError = new Error(message);\r\n    if (originalError) {\r\n      error.code = originalError.code;\r\n      error.details = originalError;\r\n    }\r\n    return error;\r\n  }\r\n\r\n  private validateMeetingData(meetingData: Partial<Meeting>): void {\r\n    if (!meetingData.title?.trim()) {\r\n      throw this.createError('Meeting title is required');\r\n    }\r\n    if (!meetingData.duration && meetingData.duration !== 0) {\r\n      throw this.createError('Meeting duration is required');\r\n    }\r\n    if (meetingData.duration < 1) {\r\n      throw this.createError('Meeting duration must be at least 1 minute');\r\n    }\r\n    if (meetingData.duration > 100) {\r\n      throw this.createError('Meeting duration cannot exceed 100 minutes');\r\n    }\r\n    if (meetingData.maxParticipants && meetingData.maxParticipants < 2) {\r\n      throw this.createError('Maximum participants must be at least 2');\r\n    }\r\n  }\r\n  /**\r\n   * Create a new meeting\r\n   */\r\n  async createMeeting(\r\n    meetingData: Omit<\r\n      Meeting,\r\n      'id' | 'status' | 'participants' | 'createdAt' | 'updatedAt' | 'roomCode'\r\n    >,\r\n  ): Promise<string> {\r\n    return this.retryOperation(async () => {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw this.createError('User not authenticated');\r\n      }\r\n\r\n      this.validateMeetingData(meetingData);\r\n\r\n      const meeting = {\r\n        ...meetingData,\r\n        host: userId,\r\n        status: 'scheduled',\r\n        participants: [userId],\r\n        roomCode: generateRoomCode(),\r\n        settings: {\r\n          ...meetingData.settings,\r\n          muteOnEntry: meetingData.settings?.muteOnEntry ?? true,\r\n          allowChat: meetingData.settings?.allowChat ?? true,\r\n          allowScreenShare: meetingData.settings?.allowScreenShare ?? true,\r\n          recordingEnabled: meetingData.settings?.recordingEnabled ?? false,\r\n        },\r\n        createdAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp(),\r\n      };\r\n\r\n      const docRef = await addDoc(this.meetingsCollection, meeting);\r\n      return docRef.id;\r\n    }, 'Failed to create meeting');\r\n  }\r\n\r\n  /**\r\n   * Join an existing meeting\r\n   */\r\n  async joinMeeting(meetingId: string): Promise<void> {\r\n    return this.retryOperation(async () => {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw this.createError('User not authenticated');\r\n      }\r\n\r\n      const meetingRef = doc(this.meetingsCollection, meetingId);\r\n      const meetingDoc = await getDoc(meetingRef);\r\n\r\n      if (!meetingDoc.exists()) {\r\n        throw this.createError('Meeting not found');\r\n      }\r\n\r\n      const meetingData = meetingDoc.data() as Meeting;\r\n\r\n      if (\r\n        meetingData.status === 'completed' ||\r\n        meetingData.status === 'cancelled'\r\n      ) {\r\n        throw this.createError('Meeting has ended');\r\n      }\r\n\r\n      if (meetingData.isPrivate && meetingData.host !== userId) {\r\n        throw this.createError('This is a private meeting');\r\n      }\r\n\r\n      if (\r\n        meetingData.maxParticipants &&\r\n        meetingData.participants.length >= meetingData.maxParticipants\r\n      ) {\r\n        console.warn(\r\n          `Meeting ${meetingId} has reached maximum participants limit of ${meetingData.maxParticipants}`,\r\n        );\r\n        throw this.createError(\r\n          `Meeting has reached maximum participants limit of ${meetingData.maxParticipants}`,\r\n        );\r\n      }\r\n\r\n      await updateDoc(meetingRef, {\r\n        participants: arrayUnion(userId),\r\n        status: 'active',\r\n        updatedAt: serverTimestamp(),\r\n      });\r\n    }, 'Failed to join meeting');\r\n  }\r\n\r\n  /**\r\n   * Leave a meeting\r\n   */\r\n  async leaveMeeting(meetingId: string): Promise<void> {\r\n    return this.retryOperation(async () => {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw this.createError('User not authenticated');\r\n      }\r\n\r\n      const meetingRef = doc(this.meetingsCollection, meetingId);\r\n      const meetingDoc = await getDoc(meetingRef);\r\n\r\n      if (!meetingDoc.exists()) {\r\n        throw this.createError('Meeting not found');\r\n      }\r\n\r\n      const meetingData = meetingDoc.data() as Meeting;\r\n\r\n      // If host leaves, end the meeting for everyone\r\n      if (meetingData.host === userId) {\r\n        await this.endMeeting(meetingId);\r\n        return;\r\n      }\r\n\r\n      // Clean up participant state data from Firestore\r\n      try {\r\n        await deleteDoc(\r\n          doc(\r\n            collection(this.meetingsCollection, meetingId, 'participantStates'),\r\n            userId,\r\n          ),\r\n        );\r\n        console.log(\r\n          `Deleted participant state for ${userId} in meeting ${meetingId}`,\r\n        );\r\n      } catch (error) {\r\n        console.error('Error deleting participant state:', error);\r\n        // Continue with removal from participants list even if state deletion fails\r\n      }\r\n\r\n      await updateDoc(meetingRef, {\r\n        participants: arrayRemove(userId),\r\n        updatedAt: serverTimestamp(),\r\n      });\r\n    }, 'Failed to leave meeting');\r\n  }\r\n\r\n  /**\r\n   * End a meeting (host only)\r\n   */\r\n  async endMeeting(meetingId: string): Promise<void> {\r\n    return this.retryOperation(async () => {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw this.createError('User not authenticated');\r\n      }\r\n\r\n      const meetingRef = doc(this.meetingsCollection, meetingId);\r\n      const meetingDoc = await getDoc(meetingRef);\r\n\r\n      if (!meetingDoc.exists()) {\r\n        throw this.createError('Meeting not found');\r\n      }\r\n\r\n      const meetingData = meetingDoc.data() as Meeting;\r\n      if (meetingData.host !== userId) {\r\n        throw this.createError('Only the host can end the meeting');\r\n      }\r\n\r\n      // Delete all participant states for this meeting\r\n      try {\r\n        // Create a reference to the participant states subcollection\r\n        const participantStatesRef = collection(\r\n          getFirestore(),\r\n          'meetings',\r\n          meetingId,\r\n          'participantStates',\r\n        );\r\n        const participantStatesSnapshot = await getDocs(participantStatesRef);\r\n\r\n        // Delete each document\r\n        const batch = writeBatch(getFirestore());\r\n        participantStatesSnapshot.forEach(\r\n          (docSnapshot: FirebaseFirestoreTypes.QueryDocumentSnapshot) => {\r\n            batch.delete(docSnapshot.ref);\r\n          },\r\n        );\r\n        await batch.commit();\r\n\r\n        console.log(\r\n          `Deleted ${participantStatesSnapshot.size} participant states for meeting ${meetingId}`,\r\n        );\r\n      } catch (error) {\r\n        console.error('Error deleting participant states:', error);\r\n        // Continue with meeting end even if state deletion fails\r\n      }\r\n\r\n      await updateDoc(meetingRef, {\r\n        status: 'completed',\r\n        updatedAt: serverTimestamp(),\r\n      });\r\n    }, 'Failed to end meeting');\r\n  }\r\n\r\n  /**\r\n   * Update meeting settings\r\n   */\r\n  async updateMeetingSettings(\r\n    meetingId: string,\r\n    settings: Partial<Meeting['settings']>,\r\n  ): Promise<void> {\r\n    return this.retryOperation(async () => {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw this.createError('User not authenticated');\r\n      }\r\n\r\n      const meetingRef = doc(this.meetingsCollection, meetingId);\r\n      const meetingDoc = await getDoc(meetingRef);\r\n\r\n      if (!meetingDoc.exists()) {\r\n        throw this.createError('Meeting not found');\r\n      }\r\n\r\n      const meetingData = meetingDoc.data() as Meeting;\r\n      if (meetingData.host !== userId) {\r\n        throw this.createError('Only the host can update meeting settings');\r\n      }\r\n\r\n      await updateDoc(meetingRef, {\r\n        settings: {...meetingData.settings, ...settings},\r\n        updatedAt: serverTimestamp(),\r\n      });\r\n    }, 'Failed to update meeting settings');\r\n  }\r\n\r\n  /**\r\n   * Check if meeting should end based on end time\r\n   */\r\n  private async checkMeetingEndTime(meetingId: string): Promise<boolean> {\r\n    try {\r\n      const meetingDoc = await getDoc(doc(this.meetingsCollection, meetingId));\r\n      if (!meetingDoc.exists()) return false;\r\n\r\n      const meetingData = meetingDoc.data() as Meeting;\r\n      const now = new Date();\r\n      const endTime = new Date(\r\n        meetingData.duration * 60000 + meetingData.createdAt.toMillis(),\r\n      );\r\n\r\n      return endTime <= now;\r\n    } catch (error) {\r\n      console.error('Error checking meeting end time:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start monitoring meeting end time\r\n   */\r\n  startEndTimeMonitoring(meetingId: string, onMeetingEnd: () => void): void {\r\n    // Clear any existing interval\r\n    if (this.endTimeCheckInterval) {\r\n      clearInterval(this.endTimeCheckInterval);\r\n    }\r\n\r\n    // Check every minute if meeting should end\r\n    this.endTimeCheckInterval = setInterval(async () => {\r\n      try {\r\n        const shouldEnd = await this.checkMeetingEndTime(meetingId);\r\n        if (shouldEnd) {\r\n          await this.endMeeting(meetingId);\r\n          onMeetingEnd();\r\n          this.stopEndTimeMonitoring();\r\n        }\r\n      } catch (error) {\r\n        console.error('Error in end time monitoring:', error);\r\n      }\r\n    }, 60000); // Check every minute\r\n  }\r\n\r\n  /**\r\n   * Stop monitoring meeting end time\r\n   */\r\n  stopEndTimeMonitoring(): void {\r\n    if (this.endTimeCheckInterval) {\r\n      clearInterval(this.endTimeCheckInterval);\r\n      this.endTimeCheckInterval = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe to meeting updates with end time monitoring\r\n   */\r\n  subscribeMeeting(\r\n    meetingId: string,\r\n    onUpdate: (meeting: Meeting) => void,\r\n    onError: (error: MeetingError) => void,\r\n  ): void {\r\n    try {\r\n      if (this.unsubscribeMeeting) {\r\n        this.unsubscribeMeeting();\r\n      }\r\n\r\n      this.unsubscribeMeeting = onSnapshot(\r\n        doc(this.meetingsCollection, meetingId),\r\n        (snapshot: FirebaseFirestoreTypes.DocumentSnapshot<Meeting>) => {\r\n          if (!snapshot) {\r\n            const error = this.createError('Failed to get meeting data');\r\n            console.warn(\r\n              'MeetingService: Received null snapshot in meeting listener',\r\n            );\r\n            onError(error);\r\n            return;\r\n          }\r\n\r\n          try {\r\n            if (snapshot.exists()) {\r\n              const meeting = {\r\n                id: snapshot.id,\r\n                ...snapshot.data(),\r\n              } as Meeting;\r\n\r\n              // Check if meeting has ended\r\n              const now = new Date();\r\n              const endTime = new Date(\r\n                meeting.duration * 60000 + meeting.createdAt.toMillis(),\r\n              );\r\n              if (this.endTimeCheckInterval) {\r\n                clearInterval(this.endTimeCheckInterval);\r\n                this.endTimeCheckInterval = null;\r\n              }\r\n              this.startEndTimeMonitoring(meetingId, () => {\r\n                meeting.status = 'completed';\r\n                onUpdate(meeting);\r\n              });\r\n\r\n              if (endTime <= now && meeting.status !== 'completed') {\r\n                this.endMeeting(meetingId)\r\n                  .then(() => {\r\n                    meeting.status = 'completed';\r\n                    onUpdate(meeting);\r\n                  })\r\n                  .catch(error => {\r\n                    console.error('Error ending expired meeting:', error);\r\n                  });\r\n              } else {\r\n                onUpdate(meeting);\r\n              }\r\n            } else {\r\n              onError(this.createError('Meeting not found'));\r\n            }\r\n          } catch (error) {\r\n            console.error(\r\n              'MeetingService: Error processing meeting snapshot:',\r\n              error,\r\n            );\r\n            onError(this.createError('Error processing meeting data', error));\r\n          }\r\n        },\r\n        error => {\r\n          console.error('MeetingService: Error in meeting listener:', error);\r\n          onError(this.createError('Meeting subscription error', error));\r\n        },\r\n      );\r\n    } catch (error) {\r\n      console.error('MeetingService :: subscribeMeeting() ::', error);\r\n      onError(\r\n        this.createError('Failed to subscribe to meeting updates', error),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get meeting by ID\r\n   */\r\n  async getMeeting(meetingId: string): Promise<Meeting> {\r\n    return this.retryOperation(async () => {\r\n      const meetingDoc = await getDoc(doc(this.meetingsCollection, meetingId));\r\n      if (!meetingDoc.exists()) {\r\n        throw this.createError('Meeting not found');\r\n      }\r\n\r\n      return {\r\n        id: meetingDoc.id,\r\n        ...meetingDoc.data(),\r\n      } as Meeting;\r\n    }, 'Failed to get meeting');\r\n  }\r\n\r\n  /**\r\n   * Get meeting by room code\r\n   */\r\n  async getMeetingByRoomCode(roomCode: string): Promise<Meeting> {\r\n    return this.retryOperation(async () => {\r\n      const querySnapshot = await getDocs(\r\n        query(\r\n          this.meetingsCollection,\r\n          where('roomCode', '==', roomCode),\r\n          where('status', 'in', ['scheduled', 'active']),\r\n          limit(1),\r\n        ),\r\n      );\r\n\r\n      if (querySnapshot.empty) {\r\n        throw this.createError('Meeting not found');\r\n      }\r\n\r\n      const meetingDoc = querySnapshot.docs[0];\r\n      return {\r\n        id: meetingDoc.id,\r\n        ...meetingDoc.data(),\r\n      } as Meeting;\r\n    }, 'Failed to get meeting by room code');\r\n  }\r\n\r\n  /**\r\n   * Get active meetings\r\n   */\r\n  async getActiveMeetings(): Promise<Meeting[]> {\r\n    return this.retryOperation(async () => {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw this.createError('User not authenticated');\r\n      }\r\n\r\n      const querySnapshot = await getDocs(\r\n        query(\r\n          this.meetingsCollection,\r\n          where('participants', 'array-contains', userId),\r\n          where('status', '==', 'active'),\r\n          orderBy('startTime', 'desc'),\r\n        ),\r\n      );\r\n\r\n      return querySnapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data(),\r\n      })) as Meeting[];\r\n    }, 'Failed to get active meetings');\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   */\r\n  cleanup(): void {\r\n    this.stopEndTimeMonitoring();\r\n    if (this.unsubscribeMeeting) {\r\n      this.unsubscribeMeeting();\r\n      this.unsubscribeMeeting = null;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\services\\WebRTCService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\styles\\Chat.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\styles\\Room.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\styles\\RoomComponent.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\styles\\RoomScreen.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\types\\object.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\types\\props.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\utils\\avatar.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\utils\\helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\utils\\layout.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\utils\\sharing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Room\\utils\\validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SavedPost\\components\\SavedPostsEmptyState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SavedPost\\components\\SavedPostsHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SavedPost\\hooks\\useSavedPosts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SavedPost\\screens\\SavedPosts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SavedPost\\services\\SavedPostService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getDoc' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":9},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":34,"column":8,"nodeType":"Identifier","messageId":"noShadow","endLine":34,"endColumn":52}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {getAuth} from '@react-native-firebase/auth';\r\nimport {\r\n  getFirestore,\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  updateDoc,\r\n  onSnapshot,\r\n  arrayUnion,\r\n  arrayRemove,\r\n  FirebaseFirestoreTypes,\r\n} from '@react-native-firebase/firestore';\r\nimport {SavePostResponse} from 'shared/types/firebase';\r\n\r\nexport class SavedPostService {\r\n  // Simple list to store saved post IDs\r\n  private savedPosts: string[] = [];\r\n\r\n  // List of functions to call when saved posts change\r\n  private listeners: (() => void)[] = [];\r\n\r\n  constructor() {\r\n    // Start listening to saved posts when service is created\r\n    this.setupSavedPostsListener();\r\n  }\r\n\r\n  private setupSavedPostsListener() {\r\n    const user = getAuth().currentUser;\r\n    if (!user) return;\r\n\r\n    // Listen to changes in user's saved posts\r\n    onSnapshot(\r\n      doc(collection(getFirestore(), 'users'), user.uid),\r\n      (doc: FirebaseFirestoreTypes.DocumentSnapshot) => {\r\n        try {\r\n          if (!doc) {\r\n            console.warn(\r\n              'SavedPostService: Received null snapshot in saved posts listener',\r\n            );\r\n            return;\r\n          }\r\n\r\n          if (doc.exists()) {\r\n            // Update our list of saved posts\r\n            this.savedPosts = doc.data()?.savedPosts || [];\r\n            // Tell everyone who's listening that saved posts changed\r\n            this.notifyListeners();\r\n          }\r\n        } catch (error) {\r\n          console.error(\r\n            'SavedPostService: Error processing saved posts snapshot:',\r\n            error,\r\n          );\r\n        }\r\n      },\r\n      error => {\r\n        console.error(\r\n          'SavedPostService: Error in saved posts listener:',\r\n          error,\r\n        );\r\n      },\r\n    );\r\n  }\r\n\r\n  // Add a new listener\r\n  subscribeToSavedPosts(onSavedPostsChange: () => void): () => void {\r\n    this.listeners.push(onSavedPostsChange);\r\n    // Return function to remove listener\r\n    return () => {\r\n      this.listeners = this.listeners.filter(\r\n        listener => listener !== onSavedPostsChange,\r\n      );\r\n    };\r\n  }\r\n\r\n  // Tell all listeners that saved posts changed\r\n  private notifyListeners() {\r\n    this.listeners.forEach(listener => listener());\r\n  }\r\n\r\n  // Check if a post is saved\r\n  isPostSaved(postId: string): boolean {\r\n    return this.savedPosts.includes(postId);\r\n  }\r\n\r\n  // Save or unsave a post\r\n  async savePost(postId: string): Promise<SavePostResponse> {\r\n    try {\r\n      const user = getAuth().currentUser;\r\n      if (!user) {\r\n        return {success: false, error: 'Not logged in'};\r\n      }\r\n\r\n      const userRef = doc(collection(getFirestore(), 'users'), user.uid);\r\n      const isSaved = this.isPostSaved(postId);\r\n\r\n      // If post is already saved, remove it. If not saved, add it.\r\n      await updateDoc(userRef, {\r\n        savedPosts: isSaved ? arrayRemove(postId) : arrayUnion(postId),\r\n      });\r\n\r\n      return {success: true, saved: !isSaved};\r\n    } catch (error) {\r\n      console.error('Error saving post:', error);\r\n      return {success: false, error: 'Failed to save post'};\r\n    }\r\n  }\r\n\r\n  // Clean up when service is no longer needed\r\n  cleanup() {\r\n    this.listeners = [];\r\n    this.savedPosts = [];\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SavedPost\\styles\\SavedPosts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SavedPost\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SavedPost\\types\\props.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SearchPost\\components\\SearchEmptyState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SearchPost\\components\\SearchLoading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SearchPost\\hooks\\useSearchPosts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SearchPost\\screens\\Search.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SearchPost\\styles\\Search.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SearchPost\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\SearchPost\\types\\props.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\components\\DuoTaskDetailsModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Task' is defined but never used.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":14},{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has missing dependencies: 'loadCollaboratorDetails', 'modalVisible', and 'task'. Either include them or remove the dependency array.","line":85,"column":6,"nodeType":"ArrayExpression","endLine":85,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [loadCollaboratorDetails, modalVisible, task]","fix":{"range":[2249,2251],"text":"[loadCollaboratorDetails, modalVisible, task]"}}]},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: \"isDark ? '#1a1a1a' : 'white'\" }","line":159,"column":13,"nodeType":"ObjectExpression","endLine":159,"endColumn":62},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":163,"column":42,"nodeType":"ObjectExpression","endLine":163,"endColumn":79},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { marginHorizontal: 16, marginBottom: 10 }","line":172,"column":24,"nodeType":"ObjectExpression","endLine":172,"endColumn":66},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  flexDirection: 'row',\n  justifyContent: 'space-between',\n  marginBottom: 5\n}","line":174,"column":22,"nodeType":"ObjectExpression","endLine":178,"endColumn":16},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\", fontSize: 12 }","line":179,"column":28,"nodeType":"ObjectExpression","endLine":179,"endColumn":80},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  flexDirection: 'row',\n  alignItems: 'center',\n  paddingHorizontal: 8,\n  paddingVertical: 2,\n  borderRadius: 10,\n  backgroundColor: 'task?.completed\\r\\n' +\n    \"                    ? '#34C759'\\r\\n\" +\n    \"                    : task?.collaborationStatus === 'active'\\r\\n\" +\n    \"                      ? '#007AFF'\\r\\n\" +\n    \"                      : '#FF9500'\"\n}","line":184,"column":24,"nodeType":"ObjectExpression","endLine":195,"endColumn":18},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: 'white', fontSize: 10 }","line":196,"column":30,"nodeType":"ObjectExpression","endLine":196,"endColumn":62},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  height: 6,\n  backgroundColor: \"isDark ? '#404040' : '#e0e0e0'\",\n  borderRadius: 3,\n  overflow: 'hidden'\n}","line":203,"column":22,"nodeType":"ObjectExpression","endLine":208,"endColumn":16},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  height: '100%',\n  backgroundColor: \"task?.completed ? '#34C759' : '#1a9cd8'\",\n  borderRadius: 3\n}","line":210,"column":24,"nodeType":"ObjectExpression","endLine":215,"endColumn":18},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  flexDirection: 'row',\n  borderBottomWidth: 1,\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\",\n  marginBottom: 10\n}","line":222,"column":20,"nodeType":"ObjectExpression","endLine":227,"endColumn":14},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  padding: 10,\n  borderBottomWidth: 2,\n  borderBottomColor: \"activeTab === 'details' ? '#1a9cd8' : 'transparent'\"\n}","line":229,"column":22,"nodeType":"ObjectExpression","endLine":234,"endColumn":16},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":236,"column":28,"nodeType":"ObjectExpression","endLine":236,"endColumn":65},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  padding: 10,\n  borderBottomWidth: 2,\n  borderBottomColor: \"activeTab === 'subtasks' ? '#1a9cd8' : 'transparent'\"\n}","line":239,"column":22,"nodeType":"ObjectExpression","endLine":244,"endColumn":16},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":246,"column":28,"nodeType":"ObjectExpression","endLine":246,"endColumn":65},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\" }","line":258,"column":23,"nodeType":"ObjectExpression","endLine":258,"endColumn":61},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":265,"column":23,"nodeType":"ObjectExpression","endLine":265,"endColumn":60},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\" }","line":275,"column":23,"nodeType":"ObjectExpression","endLine":275,"endColumn":61},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":282,"column":23,"nodeType":"ObjectExpression","endLine":282,"endColumn":60},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\" }","line":292,"column":23,"nodeType":"ObjectExpression","endLine":292,"endColumn":61},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { flexDirection: 'row', alignItems: 'center' }","line":296,"column":32,"nodeType":"ObjectExpression","endLine":296,"endColumn":78},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { width: 12, height: 12, borderRadius: 6, marginRight: 5 }","line":298,"column":30,"nodeType":"ObjectExpression","endLine":306,"endColumn":24},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":311,"column":25,"nodeType":"ObjectExpression","endLine":311,"endColumn":62},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\" }","line":323,"column":23,"nodeType":"ObjectExpression","endLine":323,"endColumn":61},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":330,"column":23,"nodeType":"ObjectExpression","endLine":330,"endColumn":60},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\", marginBottom: 5 }","line":340,"column":23,"nodeType":"ObjectExpression","endLine":340,"endColumn":78},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  flexDirection: 'row',\n  alignItems: 'center',\n  backgroundColor: \"isDark ? '#2a2a2a' : '#f5f5f5'\",\n  padding: 10,\n  borderRadius: 5,\n  marginBottom: 5\n}","line":347,"column":30,"nodeType":"ObjectExpression","endLine":354,"endColumn":24},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  width: 32,\n  height: 32,\n  borderRadius: 16,\n  backgroundColor: '#1a9cd8',\n  justifyContent: 'center',\n  alignItems: 'center',\n  marginRight: 10\n}","line":356,"column":32,"nodeType":"ObjectExpression","endLine":364,"endColumn":26},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: 'white' }","line":365,"column":38,"nodeType":"ObjectExpression","endLine":365,"endColumn":56},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { flex: 1 }","line":375,"column":36,"nodeType":"ObjectExpression","endLine":375,"endColumn":47},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":376,"column":38,"nodeType":"ObjectExpression","endLine":376,"endColumn":75},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\", fontSize: 12 }","line":383,"column":34,"nodeType":"ObjectExpression","endLine":386,"endColumn":28},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  flexDirection: 'row',\n  justifyContent: 'space-between',\n  marginTop: 20\n}","line":397,"column":28,"nodeType":"ObjectExpression","endLine":401,"endColumn":22},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: '#FF3B30',\n  paddingVertical: 10,\n  paddingHorizontal: 16,\n  borderRadius: 5,\n  alignItems: 'center',\n  flex: 1,\n  marginRight: 5\n}","line":403,"column":30,"nodeType":"ObjectExpression","endLine":411,"endColumn":24},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: 'white' }","line":416,"column":36,"nodeType":"ObjectExpression","endLine":416,"endColumn":54},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: '#1a9cd8',\n  paddingVertical: 10,\n  paddingHorizontal: 16,\n  borderRadius: 5,\n  alignItems: 'center',\n  flex: 1,\n  marginLeft: 5\n}","line":420,"column":30,"nodeType":"ObjectExpression","endLine":428,"endColumn":24},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: 'white' }","line":433,"column":36,"nodeType":"ObjectExpression","endLine":433,"endColumn":54},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\" }","line":447,"column":23,"nodeType":"ObjectExpression","endLine":447,"endColumn":61},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { flexDirection: 'row', marginBottom: 15 }","line":451,"column":32,"nodeType":"ObjectExpression","endLine":451,"endColumn":74},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: \"isDark ? '#2a2a2a' : '#f5f5f5'\",\n  color: \"isDark ? 'white' : 'black'\",\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\",\n  flex: 1,\n  marginRight: 10\n}","line":455,"column":25,"nodeType":"ObjectExpression","endLine":461,"endColumn":26},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: '#1a9cd8',\n  padding: 10,\n  borderRadius: 5,\n  justifyContent: 'center',\n  alignItems: 'center'\n}","line":469,"column":30,"nodeType":"ObjectExpression","endLine":475,"endColumn":24},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: 'white' }","line":477,"column":36,"nodeType":"ObjectExpression","endLine":477,"endColumn":54},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\", marginBottom: 10 }","line":485,"column":21,"nodeType":"ObjectExpression","endLine":485,"endColumn":77},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDark ? '#8e8e8e' : '#666'\",\n  textAlign: 'center',\n  padding: 20\n}","line":492,"column":28,"nodeType":"ObjectExpression","endLine":496,"endColumn":22},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  flexDirection: 'row',\n  alignItems: 'center',\n  padding: 12,\n  borderBottomWidth: 1,\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\"\n}","line":503,"column":30,"nodeType":"ObjectExpression","endLine":509,"endColumn":24},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  width: 24,\n  height: 24,\n  borderRadius: 12,\n  borderWidth: 2,\n  borderColor: \"isDark ? '#8e8e8e' : '#666'\",\n  justifyContent: 'center',\n  alignItems: 'center',\n  backgroundColor: 'subtask.completed\\r\\n' +\n    \"                            ? '#1a9cd8'\\r\\n\" +\n    \"                            : 'transparent'\",\n  marginRight: 10\n}","line":511,"column":32,"nodeType":"ObjectExpression","endLine":523,"endColumn":26},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { flex: 1 }","line":532,"column":36,"nodeType":"ObjectExpression","endLine":532,"endColumn":47},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDark ? 'white' : 'black'\",\n  textDecorationLine: 'subtask.completed\\r\\n' +\n    \"                              ? 'line-through'\\r\\n\" +\n    \"                              : 'none'\",\n  opacity: 'subtask.completed ? 0.7 : 1'\n}","line":534,"column":34,"nodeType":"ObjectExpression","endLine":540,"endColumn":28},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDark ? '#8e8e8e' : '#666'\",\n  fontSize: 12,\n  textDecorationLine: 'subtask.completed\\r\\n' +\n    \"                                ? 'line-through'\\r\\n\" +\n    \"                                : 'none'\",\n  opacity: 'subtask.completed ? 0.7 : 1'\n}","line":545,"column":36,"nodeType":"ObjectExpression","endLine":552,"endColumn":30},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\", fontSize: 10, marginTop: 2 }","line":559,"column":36,"nodeType":"ObjectExpression","endLine":563,"endColumn":30},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: '#34C759', fontSize: 10, marginTop: 2 }","line":573,"column":36,"nodeType":"ObjectExpression","endLine":577,"endColumn":30}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":50,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback } from 'react';\r\nimport {\r\n  Modal,\r\n  View,\r\n  Text,\r\n  TouchableOpacity,\r\n  ScrollView,\r\n  TextInput,\r\n  Alert,\r\n} from 'react-native';\r\nimport Icon from 'react-native-vector-icons/Ionicons';\r\nimport { Task, SubTask } from 'shared/types/taskTypes';\r\nimport { styles } from 'tasks/styles/Tasks.styles';\r\nimport { TaskService } from 'shared/services/TaskService';\r\nimport { getAuth } from '@react-native-firebase/auth';\r\nimport {\r\n  getFirestore,\r\n  doc,\r\n  getDoc,\r\n  Timestamp,\r\n} from '@react-native-firebase/firestore';\r\n\r\nimport { DuoTaskDetailsModalProps } from '../types';\r\n\r\n// Define additional styles for the modal details\r\nconst modalDetailStyles = {\r\n  detailItem: {\r\n    marginBottom: 15,\r\n    paddingHorizontal: 16,\r\n  },\r\n  detailLabel: {\r\n    fontSize: 14,\r\n    fontWeight: 'bold' as const,\r\n    marginBottom: 5,\r\n  },\r\n  detailValue: {\r\n    fontSize: 16,\r\n    marginBottom: 5,\r\n  },\r\n};\r\n\r\nconst DuoTaskDetailsModal: React.FC<DuoTaskDetailsModalProps> = ({\r\n  modalVisible,\r\n  isDark,\r\n  task,\r\n  onClose,\r\n  onDeleteTask,\r\n  onEditTask,\r\n  onTaskUpdated,\r\n}) => {\r\n  const [activeTab, setActiveTab] = useState('details'); // 'details', 'subtasks'\r\n  const [newSubtaskTitle, setNewSubtaskTitle] = useState('');\r\n  const [collaborators, setCollaborators] = useState<any[]>([]);\r\n  const taskService = new TaskService();\r\n  const loadCollaboratorDetails = useCallback(async () => {\r\n    if (!task?.collaborators) {\r\n      return undefined;\r\n    }\r\n\r\n    try {\r\n      const collaboratorDetails = [];\r\n\r\n      for (const userId of task.collaborators) {\r\n        const userDoc = await getDoc(doc(getFirestore(), 'users', userId));\r\n        if (userDoc.exists()) {\r\n          collaboratorDetails.push({\r\n            id: userId,\r\n            ...userDoc.data(),\r\n            isCurrentUser: userId === getAuth().currentUser?.uid,\r\n          });\r\n        }\r\n      }\r\n\r\n      setCollaborators(collaboratorDetails);\r\n    } catch (error) {\r\n      console.error('Error loading collaborator details:', error);\r\n    }\r\n  }, [task.collaborators]);\r\n\r\n  // Load collaborator details when modal opens\r\n  useEffect(() => {\r\n    if (modalVisible && task) {\r\n      loadCollaboratorDetails();\r\n    }\r\n  }, []);\r\n\r\n  const handleAddSubtask = async () => {\r\n    if (!task || !newSubtaskTitle.trim()) return;\r\n\r\n    try {\r\n      const newSubtask: Omit<SubTask, 'id' | 'createdAt' | 'updatedAt'> = {\r\n        title: newSubtaskTitle,\r\n        completed: false,\r\n        assignedTo: getAuth().currentUser?.uid,\r\n      };\r\n\r\n      await taskService.addDuoTaskSubtask(task.id, newSubtask);\r\n\r\n      const updatedTask = await taskService.getTaskById(task.id);\r\n\r\n      if (updatedTask && onTaskUpdated) {\r\n        onTaskUpdated(updatedTask);\r\n      }\r\n\r\n      setNewSubtaskTitle('');\r\n    } catch (error) {\r\n      console.error('Error adding subtask:', error);\r\n      Alert.alert('Error', 'Failed to add subtask. Please try again.');\r\n    }\r\n  };\r\n\r\n  const toggleSubtaskCompletion = async (\r\n    subtaskId: string,\r\n    completed: boolean,\r\n  ) => {\r\n    if (!task) return;\r\n\r\n    try {\r\n      await taskService.updateDuoTaskSubtask(task.id, subtaskId, {\r\n        completed: !completed,\r\n        completedBy: !completed ? getAuth().currentUser?.uid : undefined,\r\n        completedAt: !completed ? Timestamp.now() : undefined,\r\n      });\r\n\r\n      const updatedTask = await taskService.getTaskById(task.id);\r\n\r\n      if (updatedTask && onTaskUpdated) {\r\n        onTaskUpdated(updatedTask);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error updating subtask:', error);\r\n      Alert.alert('Error', 'Failed to update subtask. Please try again.');\r\n    }\r\n  };\r\n\r\n  const getPriorityColor = (priority: string) => {\r\n    switch (priority) {\r\n      case 'high':\r\n        return '#FF3B30';\r\n      case 'medium':\r\n        return '#FF9500';\r\n      case 'low':\r\n        return '#34C759';\r\n      default:\r\n        return '#8E8E93';\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Modal\r\n      animationType=\"slide\"\r\n      transparent={true}\r\n      visible={modalVisible}\r\n      onRequestClose={onClose}>\r\n      <View style={styles.modalOverlay}>\r\n        <View\r\n          style={[\r\n            styles.modalContent,\r\n            { backgroundColor: isDark ? '#1a1a1a' : 'white' },\r\n          ]}>\r\n          <View style={styles.modalHeader}>\r\n            <Text\r\n              style={[styles.modalTitle, { color: isDark ? 'white' : 'black' }]}>\r\n              {task?.title}\r\n            </Text>\r\n            <TouchableOpacity onPress={onClose}>\r\n              <Icon name=\"close\" size={24} color={isDark ? 'white' : 'black'} />\r\n            </TouchableOpacity>\r\n          </View>\r\n\r\n          {/* Progress bar */}\r\n          <View style={{ marginHorizontal: 16, marginBottom: 10 }}>\r\n            <View\r\n              style={{\r\n                flexDirection: 'row',\r\n                justifyContent: 'space-between',\r\n                marginBottom: 5,\r\n              }}>\r\n              <Text style={{ color: isDark ? '#8e8e8e' : '#666', fontSize: 12 }}>\r\n                Progress: {task?.progress || 0}%\r\n              </Text>\r\n\r\n              <View\r\n                style={{\r\n                  flexDirection: 'row',\r\n                  alignItems: 'center',\r\n                  paddingHorizontal: 8,\r\n                  paddingVertical: 2,\r\n                  borderRadius: 10,\r\n                  backgroundColor: task?.completed\r\n                    ? '#34C759'\r\n                    : task?.collaborationStatus === 'active'\r\n                      ? '#007AFF'\r\n                      : '#FF9500',\r\n                }}>\r\n                <Text style={{ color: 'white', fontSize: 10 }}>\r\n                  {task?.completed ? 'Completed' : task?.collaborationStatus}\r\n                </Text>\r\n              </View>\r\n            </View>\r\n\r\n            <View\r\n              style={{\r\n                height: 6,\r\n                backgroundColor: isDark ? '#404040' : '#e0e0e0',\r\n                borderRadius: 3,\r\n                overflow: 'hidden',\r\n              }}>\r\n              <View\r\n                style={{\r\n                  height: '100%',\r\n                  width: `${task?.progress || 0}%`,\r\n                  backgroundColor: task?.completed ? '#34C759' : '#1a9cd8',\r\n                  borderRadius: 3,\r\n                }}\r\n              />\r\n            </View>\r\n          </View>\r\n\r\n          {/* Tabs */}\r\n          <View\r\n            style={{\r\n              flexDirection: 'row',\r\n              borderBottomWidth: 1,\r\n              borderColor: isDark ? '#404040' : '#e0e0e0',\r\n              marginBottom: 10,\r\n            }}>\r\n            <TouchableOpacity\r\n              style={{\r\n                padding: 10,\r\n                borderBottomWidth: 2,\r\n                borderBottomColor:\r\n                  activeTab === 'details' ? '#1a9cd8' : 'transparent',\r\n              }}\r\n              onPress={() => setActiveTab('details')}>\r\n              <Text style={{ color: isDark ? 'white' : 'black' }}>Details</Text>\r\n            </TouchableOpacity>\r\n            <TouchableOpacity\r\n              style={{\r\n                padding: 10,\r\n                borderBottomWidth: 2,\r\n                borderBottomColor:\r\n                  activeTab === 'subtasks' ? '#1a9cd8' : 'transparent',\r\n              }}\r\n              onPress={() => setActiveTab('subtasks')}>\r\n              <Text style={{ color: isDark ? 'white' : 'black' }}>Subtasks</Text>\r\n            </TouchableOpacity>\r\n          </View>\r\n\r\n          <ScrollView style={styles.modalBody}>\r\n            {/* Details Tab */}\r\n            {activeTab === 'details' && (\r\n              <View className=\"pb-10\">\r\n                <View style={modalDetailStyles.detailItem}>\r\n                  <Text\r\n                    style={[\r\n                      modalDetailStyles.detailLabel,\r\n                      { color: isDark ? '#8e8e8e' : '#666' },\r\n                    ]}>\r\n                    Description\r\n                  </Text>\r\n                  <Text\r\n                    style={[\r\n                      modalDetailStyles.detailValue,\r\n                      { color: isDark ? 'white' : 'black' },\r\n                    ]}>\r\n                    {task?.description || 'No description'}\r\n                  </Text>\r\n                </View>\r\n\r\n                <View style={modalDetailStyles.detailItem}>\r\n                  <Text\r\n                    style={[\r\n                      modalDetailStyles.detailLabel,\r\n                      { color: isDark ? '#8e8e8e' : '#666' },\r\n                    ]}>\r\n                    Due Date\r\n                  </Text>\r\n                  <Text\r\n                    style={[\r\n                      modalDetailStyles.detailValue,\r\n                      { color: isDark ? 'white' : 'black' },\r\n                    ]}>\r\n                    {task?.dueDate} {task?.dueTime ? `at ${task.dueTime}` : ''}\r\n                  </Text>\r\n                </View>\r\n\r\n                <View style={modalDetailStyles.detailItem}>\r\n                  <Text\r\n                    style={[\r\n                      modalDetailStyles.detailLabel,\r\n                      { color: isDark ? '#8e8e8e' : '#666' },\r\n                    ]}>\r\n                    Priority\r\n                  </Text>\r\n                  <View style={{ flexDirection: 'row', alignItems: 'center' }}>\r\n                    <View\r\n                      style={{\r\n                        width: 12,\r\n                        height: 12,\r\n                        borderRadius: 6,\r\n                        backgroundColor: getPriorityColor(\r\n                          task?.priority || 'medium',\r\n                        ),\r\n                        marginRight: 5,\r\n                      }}\r\n                    />\r\n                    <Text\r\n                      style={[\r\n                        modalDetailStyles.detailValue,\r\n                        { color: isDark ? 'white' : 'black' },\r\n                      ]}>\r\n                      {task?.priority.charAt(0).toUpperCase() +\r\n                        task?.priority.slice(1)}\r\n                    </Text>\r\n                  </View>\r\n                </View>\r\n\r\n                <View style={modalDetailStyles.detailItem}>\r\n                  <Text\r\n                    style={[\r\n                      modalDetailStyles.detailLabel,\r\n                      { color: isDark ? '#8e8e8e' : '#666' },\r\n                    ]}>\r\n                    Category\r\n                  </Text>\r\n                  <Text\r\n                    style={[\r\n                      modalDetailStyles.detailValue,\r\n                      { color: isDark ? 'white' : 'black' },\r\n                    ]}>\r\n                    {task?.category || 'None'}\r\n                  </Text>\r\n                </View>\r\n\r\n                <View style={modalDetailStyles.detailItem}>\r\n                  <Text\r\n                    style={[\r\n                      modalDetailStyles.detailLabel,\r\n                      { color: isDark ? '#8e8e8e' : '#666', marginBottom: 5 },\r\n                    ]}>\r\n                    Team Members\r\n                  </Text>\r\n                  {collaborators.map(collaborator => (\r\n                    <View\r\n                      key={collaborator.id}\r\n                      style={{\r\n                        flexDirection: 'row',\r\n                        alignItems: 'center',\r\n                        backgroundColor: isDark ? '#2a2a2a' : '#f5f5f5',\r\n                        padding: 10,\r\n                        borderRadius: 5,\r\n                        marginBottom: 5,\r\n                      }}>\r\n                      <View\r\n                        style={{\r\n                          width: 32,\r\n                          height: 32,\r\n                          borderRadius: 16,\r\n                          backgroundColor: '#1a9cd8',\r\n                          justifyContent: 'center',\r\n                          alignItems: 'center',\r\n                          marginRight: 10,\r\n                        }}>\r\n                        <Text style={{ color: 'white' }}>\r\n                          {(\r\n                            collaborator.displayName ||\r\n                            collaborator.email ||\r\n                            '?'\r\n                          )\r\n                            .charAt(0)\r\n                            .toUpperCase()}\r\n                        </Text>\r\n                      </View>\r\n                      <View style={{ flex: 1 }}>\r\n                        <Text style={{ color: isDark ? 'white' : 'black' }}>\r\n                          {collaborator.displayName ||\r\n                            collaborator.email ||\r\n                            'Unknown user'}\r\n                          {collaborator.isCurrentUser ? ' (You)' : ''}\r\n                        </Text>\r\n                        <Text\r\n                          style={{\r\n                            color: isDark ? '#8e8e8e' : '#666',\r\n                            fontSize: 12,\r\n                          }}>\r\n                          {collaborator.email}\r\n                        </Text>\r\n                      </View>\r\n                    </View>\r\n                  ))}\r\n                </View>\r\n\r\n                {/* Only show Edit/Delete buttons if the current user is the task creator */}\r\n                {task && task.userId === getAuth().currentUser?.uid && (\r\n                  <View\r\n                    style={{\r\n                      flexDirection: 'row',\r\n                      justifyContent: 'space-between',\r\n                      marginTop: 20,\r\n                    }}>\r\n                    <TouchableOpacity\r\n                      style={{\r\n                        backgroundColor: '#FF3B30',\r\n                        paddingVertical: 10,\r\n                        paddingHorizontal: 16,\r\n                        borderRadius: 5,\r\n                        alignItems: 'center',\r\n                        flex: 1,\r\n                        marginRight: 5,\r\n                      }}\r\n                      onPress={() => {\r\n                        onClose();\r\n                        onDeleteTask(task.id);\r\n                      }}>\r\n                      <Text style={{ color: 'white' }}>Delete</Text>\r\n                    </TouchableOpacity>\r\n\r\n                    <TouchableOpacity\r\n                      style={{\r\n                        backgroundColor: '#1a9cd8',\r\n                        paddingVertical: 10,\r\n                        paddingHorizontal: 16,\r\n                        borderRadius: 5,\r\n                        alignItems: 'center',\r\n                        flex: 1,\r\n                        marginLeft: 5,\r\n                      }}\r\n                      onPress={() => {\r\n                        onClose();\r\n                        onEditTask(task);\r\n                      }}>\r\n                      <Text style={{ color: 'white' }}>Edit</Text>\r\n                    </TouchableOpacity>\r\n                  </View>\r\n                )}\r\n              </View>\r\n            )}\r\n\r\n            {/* Subtasks Tab */}\r\n            {activeTab === 'subtasks' && (\r\n              <View>\r\n                <View style={styles.inputGroup}>\r\n                  <Text\r\n                    style={[\r\n                      modalDetailStyles.detailLabel,\r\n                      { color: isDark ? '#8e8e8e' : '#666' },\r\n                    ]}>\r\n                    Add New Subtask\r\n                  </Text>\r\n                  <View style={{ flexDirection: 'row', marginBottom: 15 }}>\r\n                    <TextInput\r\n                      style={[\r\n                        styles.input,\r\n                        {\r\n                          backgroundColor: isDark ? '#2a2a2a' : '#f5f5f5',\r\n                          color: isDark ? 'white' : 'black',\r\n                          borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                          flex: 1,\r\n                          marginRight: 10,\r\n                        },\r\n                      ]}\r\n                      placeholder=\"New subtask\"\r\n                      placeholderTextColor={isDark ? '#8e8e8e' : '#999'}\r\n                      value={newSubtaskTitle}\r\n                      onChangeText={setNewSubtaskTitle}\r\n                    />\r\n                    <TouchableOpacity\r\n                      style={{\r\n                        backgroundColor: '#1a9cd8',\r\n                        padding: 10,\r\n                        borderRadius: 5,\r\n                        justifyContent: 'center',\r\n                        alignItems: 'center',\r\n                      }}\r\n                      onPress={handleAddSubtask}>\r\n                      <Text style={{ color: 'white' }}>Add</Text>\r\n                    </TouchableOpacity>\r\n                  </View>\r\n                </View>\r\n\r\n                <Text\r\n                  style={[\r\n                    modalDetailStyles.detailLabel,\r\n                    { color: isDark ? '#8e8e8e' : '#666', marginBottom: 10 },\r\n                  ]}>\r\n                  Subtasks ({task?.subtasks?.length || 0})\r\n                </Text>\r\n\r\n                {!task?.subtasks || task.subtasks.length === 0 ? (\r\n                  <Text\r\n                    style={{\r\n                      color: isDark ? '#8e8e8e' : '#666',\r\n                      textAlign: 'center',\r\n                      padding: 20,\r\n                    }}>\r\n                    No subtasks yet. Add some to track progress!\r\n                  </Text>\r\n                ) : (\r\n                  task.subtasks.map(subtask => (\r\n                    <View\r\n                      key={subtask.id}\r\n                      style={{\r\n                        flexDirection: 'row',\r\n                        alignItems: 'center',\r\n                        padding: 12,\r\n                        borderBottomWidth: 1,\r\n                        borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                      }}>\r\n                      <TouchableOpacity\r\n                        style={{\r\n                          width: 24,\r\n                          height: 24,\r\n                          borderRadius: 12,\r\n                          borderWidth: 2,\r\n                          borderColor: isDark ? '#8e8e8e' : '#666',\r\n                          justifyContent: 'center',\r\n                          alignItems: 'center',\r\n                          backgroundColor: subtask.completed\r\n                            ? '#1a9cd8'\r\n                            : 'transparent',\r\n                          marginRight: 10,\r\n                        }}\r\n                        onPress={() =>\r\n                          toggleSubtaskCompletion(subtask.id, subtask.completed)\r\n                        }>\r\n                        {subtask.completed && (\r\n                          <Icon name=\"checkmark\" size={16} color=\"white\" />\r\n                        )}\r\n                      </TouchableOpacity>\r\n\r\n                      <View style={{ flex: 1 }}>\r\n                        <Text\r\n                          style={{\r\n                            color: isDark ? 'white' : 'black',\r\n                            textDecorationLine: subtask.completed\r\n                              ? 'line-through'\r\n                              : 'none',\r\n                            opacity: subtask.completed ? 0.7 : 1,\r\n                          }}>\r\n                          {subtask.title}\r\n                        </Text>\r\n                        {subtask.description && (\r\n                          <Text\r\n                            style={{\r\n                              color: isDark ? '#8e8e8e' : '#666',\r\n                              fontSize: 12,\r\n                              textDecorationLine: subtask.completed\r\n                                ? 'line-through'\r\n                                : 'none',\r\n                              opacity: subtask.completed ? 0.7 : 1,\r\n                            }}>\r\n                            {subtask.description}\r\n                          </Text>\r\n                        )}\r\n\r\n                        {subtask.assignedTo && (\r\n                          <Text\r\n                            style={{\r\n                              color: isDark ? '#8e8e8e' : '#666',\r\n                              fontSize: 10,\r\n                              marginTop: 2,\r\n                            }}>\r\n                            Assigned to:{' '}\r\n                            {subtask.assignedTo === getAuth().currentUser?.uid\r\n                              ? 'You'\r\n                              : 'Team Member'}\r\n                          </Text>\r\n                        )}\r\n\r\n                        {subtask.completedBy && (\r\n                          <Text\r\n                            style={{\r\n                              color: '#34C759',\r\n                              fontSize: 10,\r\n                              marginTop: 2,\r\n                            }}>\r\n                            Completed by:{' '}\r\n                            {subtask.completedBy === getAuth().currentUser?.uid\r\n                              ? 'You'\r\n                              : 'Team Member'}\r\n                          </Text>\r\n                        )}\r\n                      </View>\r\n                    </View>\r\n                  ))\r\n                )}\r\n              </View>\r\n            )}\r\n          </ScrollView>\r\n        </View>\r\n      </View>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nexport default DuoTaskDetailsModal;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\components\\DuoTaskItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\components\\DuoTaskModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Task' is defined but never used.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":14},{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has missing dependencies: 'onChangeTask' and 'task'. Either include them or remove the dependency array. If 'onChangeTask' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":133,"column":8,"nodeType":"ArrayExpression","endLine":133,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [onChangeTask, subtasks, task]","fix":{"range":[4457,4467],"text":"[onChangeTask, subtasks, task]"}}]},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDark ? '#8e8e8e' : '#666'\",\n  textAlign: 'center',\n  padding: 20\n}","line":719,"column":52,"nodeType":"ObjectExpression","endLine":723,"endColumn":46},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  flexDirection: 'row',\n  padding: 10,\n  borderBottomWidth: 1,\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\",\n  alignItems: 'center'\n}","line":734,"column":60,"nodeType":"ObjectExpression","endLine":740,"endColumn":54}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback } from 'react';\r\nimport {\r\n    Modal,\r\n    View,\r\n    Text,\r\n    TouchableOpacity,\r\n    TextInput,\r\n    ScrollView,\r\n    Switch,\r\n    Alert,\r\n    ActivityIndicator,\r\n} from 'react-native';\r\nimport { LegendList } from '@legendapp/list';\r\nimport Icon from 'react-native-vector-icons/Ionicons';\r\nimport { Task, SubTask } from 'shared/types/taskTypes';\r\nimport {\r\n    styles,\r\n    duoTaskModalStyles,\r\n} from 'tasks/styles/Tasks.styles';\r\nimport {\r\n    getFirestore,\r\n    collection,\r\n    doc,\r\n    getDocs,\r\n    Timestamp,\r\n    query,\r\n    where,\r\n    limit,\r\n    getDoc,\r\n} from '@react-native-firebase/firestore';\r\nimport { getAuth } from '@react-native-firebase/auth';\r\n// Replace uuid import with custom generator\r\n// import { v4 as uuidv4 } from 'uuid';\r\n\r\n// Custom UUID generator that doesn't rely on crypto.getRandomValues()\r\nconst generateUUID = (): string => {\r\n    // Use a timestamp-based prefix to ensure uniqueness\r\n    const timestamp = Date.now().toString(36);\r\n\r\n    // Generate random segments\r\n    const randomSegment1 = Math.random().toString(36).substring(2, 15);\r\n    const randomSegment2 = Math.random().toString(36).substring(2, 15);\r\n\r\n    // Combine timestamp and random segments to form a UUID-like string\r\n    return `${timestamp}-${randomSegment1}-${randomSegment2}`;\r\n};\r\n\r\nimport { DuoTaskModalProps } from '../types';\r\n\r\nconst DuoTaskModal: React.FC<DuoTaskModalProps> = ({\r\n    modalVisible,\r\n    isEditMode,\r\n    isDark,\r\n    task,\r\n    onClose,\r\n    onSave,\r\n    onChangeTask,\r\n}) => {\r\n    const [collaboratorEmail, setCollaboratorEmail] = useState('');\r\n    const [isSearching, setIsSearching] = useState(false);\r\n    const [, setCollaboratorData] = useState<any>(null);\r\n    const [collaborators, setCollaborators] = useState<any[]>([]);\r\n    const [error, setError] = useState<string | null>(null);\r\n    const [activeTab, setActiveTab] = useState('details'); // 'details', 'subtasks', 'collaboration'\r\n\r\n    // Subtask management\r\n    const [newSubtaskTitle, setNewSubtaskTitle] = useState('');\r\n    const [newSubtaskDescription, setNewSubtaskDescription] = useState('');\r\n    const [subtasks, setSubtasks] = useState<SubTask[]>(task.subtasks || []);\r\n\r\n    // Fetch collaborator details for display\r\n    const fetchCollaboratorDetails = useCallback(async () => {\r\n        if (!task.collaborators || task.collaborators.length === 0) return;\r\n\r\n        const currentUserId = getAuth().currentUser?.uid || '';\r\n        const otherCollaboratorIds = task.collaborators.filter(\r\n            id => id !== currentUserId,\r\n        );\r\n\r\n        let collaboratorsList: any[] = [];\r\n        for (const id of otherCollaboratorIds) {\r\n            try {\r\n                const userDoc = await getDoc(doc(getFirestore(), 'users', id));\r\n\r\n                if (userDoc.exists()) {\r\n                    const userData = userDoc.data();\r\n                    collaboratorsList.push({\r\n                        id: userDoc.id,\r\n                        displayName:\r\n                            userData?.displayName || userData?.email || 'Unknown User',\r\n                        email: userData?.email || '',\r\n                        photoURL: userData?.photoURL || null,\r\n                    });\r\n                }\r\n            } catch (err) {\r\n                console.error('Error fetching collaborator details:', err);\r\n            }\r\n        }\r\n\r\n        setCollaborators(collaboratorsList);\r\n    }, [task.collaborators]);\r\n    // Initialize collaborators list from task\r\n    useEffect(() => {\r\n        if (task.collaborators && task.collaborators.length > 1) {\r\n            fetchCollaboratorDetails();\r\n        }\r\n    }, [task.collaborators, fetchCollaboratorDetails]);\r\n\r\n    // Sync subtasks with task\r\n    useEffect(() => {\r\n        if (task.subtasks) {\r\n            setSubtasks(task.subtasks);\r\n        }\r\n    }, [task.subtasks]);\r\n\r\n    // Update task subtasks when subtasks state changes\r\n    useEffect(() => {\r\n        onChangeTask({\r\n            ...task,\r\n            subtasks,\r\n        });\r\n\r\n        // Calculate progress\r\n        if (subtasks.length > 0) {\r\n            const completedCount = subtasks.filter(s => s.completed).length;\r\n            const percentage = Math.round((completedCount / subtasks.length) * 100);\r\n            onChangeTask({\r\n                ...task,\r\n                subtasks,\r\n                progress: percentage,\r\n            });\r\n        }\r\n    }, [subtasks]);\r\n\r\n    const searchCollaborator = async () => {\r\n        if (!collaboratorEmail) {\r\n            setError('Please enter a collaborator email');\r\n            return;\r\n        }\r\n\r\n        setIsSearching(true);\r\n        setError(null);\r\n\r\n        try {\r\n            // Search for user by email\r\n            const userSnapshot = await getDocs(\r\n                query(\r\n                    collection(getFirestore(), 'users'),\r\n                    where('email', '==', collaboratorEmail),\r\n                    limit(1),\r\n                ),\r\n            );\r\n\r\n            if (userSnapshot.empty) {\r\n                setError('User not found');\r\n                setCollaboratorData(null);\r\n            } else {\r\n                const userData = userSnapshot.docs[0].data();\r\n                const userId = userSnapshot.docs[0].id;\r\n\r\n                // Check if user is trying to add themselves\r\n                if (userId === getAuth().currentUser?.uid) {\r\n                    setError('You cannot add yourself as a collaborator');\r\n                    setCollaboratorData(null);\r\n                    return;\r\n                }\r\n\r\n                // Check if user is already a collaborator\r\n                if (task.collaborators && task.collaborators.includes(userId)) {\r\n                    setError('This user is already a collaborator');\r\n                    setCollaboratorData(null);\r\n                    return;\r\n                }\r\n\r\n                setCollaboratorData({\r\n                    id: userId,\r\n                    displayName: userData.displayName || userData.email,\r\n                    email: userData.email,\r\n                    photoURL: userData.photoURL,\r\n                });\r\n\r\n                // Add the new collaborator to the list\r\n                const currentUserId = getAuth().currentUser?.uid || '';\r\n                const existingCollaborators = task.collaborators || [currentUserId];\r\n                const updatedCollaborators = [...existingCollaborators];\r\n\r\n                if (!updatedCollaborators.includes(userId)) {\r\n                    updatedCollaborators.push(userId);\r\n                }\r\n\r\n                // Update the task with the new collaborator\r\n                onChangeTask({\r\n                    ...task,\r\n                    isDuoTask: true,\r\n                    collaborators: updatedCollaborators,\r\n                    collaborationStatus: 'pending',\r\n                });\r\n\r\n                // Add to UI collaborators list\r\n                setCollaborators([\r\n                    ...collaborators,\r\n                    {\r\n                        id: userId,\r\n                        displayName: userData.displayName || userData.email,\r\n                        email: userData.email,\r\n                        photoURL: userData.photoURL,\r\n                    },\r\n                ]);\r\n\r\n                // Reset the input\r\n                setCollaboratorEmail('');\r\n                setCollaboratorData(null);\r\n            }\r\n        } catch (err) {\r\n            console.error('Error searching for collaborator:', err);\r\n            setError('An error occurred while searching for the collaborator');\r\n        } finally {\r\n            setIsSearching(false);\r\n        }\r\n    };\r\n\r\n    const addSubtask = () => {\r\n        if (!newSubtaskTitle.trim()) {\r\n            Alert.alert('Error', 'Subtask title is required');\r\n            return;\r\n        }\r\n\r\n        const newSubtask: SubTask = {\r\n            id: generateUUID(),\r\n            title: newSubtaskTitle,\r\n            description: newSubtaskDescription,\r\n            completed: false,\r\n            createdAt: Timestamp.now(),\r\n            updatedAt: Timestamp.now(),\r\n        };\r\n\r\n        setSubtasks([...subtasks, newSubtask]);\r\n        setNewSubtaskTitle('');\r\n        setNewSubtaskDescription('');\r\n    };\r\n\r\n    const toggleSubtaskCompletion = (id: string) => {\r\n        setSubtasks(\r\n            subtasks.map(subtask => {\r\n                if (subtask.id === id) {\r\n                    return {\r\n                        ...subtask,\r\n                        completed: !subtask.completed,\r\n                        completedBy: !subtask.completed\r\n                            ? getAuth().currentUser?.uid\r\n                            : undefined,\r\n                        completedAt: !subtask.completed ? Timestamp.now() : undefined,\r\n                        updatedAt: Timestamp.now(),\r\n                    };\r\n                }\r\n                return subtask;\r\n            }),\r\n        );\r\n    };\r\n\r\n    const removeSubtask = (id: string) => {\r\n        setSubtasks(subtasks.filter(subtask => subtask.id !== id));\r\n    };\r\n\r\n    const removeCollaborator = (collaboratorId: string) => {\r\n        // Remove from collaborators list in the UI\r\n        setCollaborators(collaborators.filter(c => c.id !== collaboratorId));\r\n\r\n        // Remove from task collaborators array\r\n        if (task.collaborators) {\r\n            const currentUserId = getAuth().currentUser?.uid || '';\r\n            const updatedCollaborators = task.collaborators.filter(\r\n                id => id !== collaboratorId,\r\n            );\r\n\r\n            // Make sure current user is still in the collaborators list\r\n            if (!updatedCollaborators.includes(currentUserId)) {\r\n                updatedCollaborators.push(currentUserId);\r\n            }\r\n\r\n            onChangeTask({\r\n                ...task,\r\n                collaborators: updatedCollaborators,\r\n                // Keep as a team task if there are still multiple collaborators\r\n                isDuoTask: updatedCollaborators.length > 1,\r\n            });\r\n        }\r\n    };\r\n\r\n    // Reset collaboration if all collaborators are removed\r\n    const resetCollaboration = () => {\r\n        setCollaborators([]);\r\n        onChangeTask({\r\n            ...task,\r\n            isDuoTask: false,\r\n            collaborators: [getAuth().currentUser?.uid || ''],\r\n            collaborationStatus: undefined,\r\n        });\r\n        setCollaboratorEmail('');\r\n        setCollaboratorData(null);\r\n    };\r\n\r\n    return (\r\n        <Modal\r\n            animationType=\"slide\"\r\n            transparent={true}\r\n            visible={modalVisible}\r\n            testID='duoTaskModal'\r\n            onRequestClose={onClose}>\r\n            <View style={styles.modalOverlay}>\r\n                <View\r\n                    style={[\r\n                        styles.modalContent,\r\n                        duoTaskModalStyles.modalContent,\r\n                        isDark\r\n                            ? duoTaskModalStyles.modalContentDark\r\n                            : duoTaskModalStyles.modalContentLight,\r\n                    ]}>\r\n                    <View style={styles.modalHeader}>\r\n                        <Text\r\n                            style={[\r\n                                styles.modalTitle,\r\n                                duoTaskModalStyles.modalTitle,\r\n                                isDark\r\n                                    ? duoTaskModalStyles.modalTitleDark\r\n                                    : duoTaskModalStyles.modalTitleLight,\r\n                            ]}>\r\n                            {isEditMode ? 'Edit Team Task' : 'Create Team Task'}\r\n                        </Text>\r\n                        <TouchableOpacity\r\n                            style={duoTaskModalStyles.closeButton}\r\n                            onPress={onClose}>\r\n                            <Icon\r\n                                name=\"close\"\r\n                                size={24}\r\n                                color={\r\n                                    isDark\r\n                                        ? duoTaskModalStyles.tabTextDark.color\r\n                                        : duoTaskModalStyles.tabTextLight.color\r\n                                }\r\n                            />\r\n                        </TouchableOpacity>\r\n                    </View>\r\n\r\n                    {/* Tabs */}\r\n                    <View\r\n                        style={[\r\n                            duoTaskModalStyles.tabsContainer,\r\n                            isDark\r\n                                ? duoTaskModalStyles.tabsContainerDark\r\n                                : duoTaskModalStyles.tabsContainerLight,\r\n                        ]}>\r\n                        <TouchableOpacity\r\n                            style={[\r\n                                duoTaskModalStyles.tab,\r\n                                activeTab === 'details'\r\n                                    ? duoTaskModalStyles.tabActive\r\n                                    : duoTaskModalStyles.tabInactive,\r\n                            ]}\r\n                            onPress={() => setActiveTab('details')}>\r\n                            <Text\r\n                                style={[\r\n                                    duoTaskModalStyles.tabText,\r\n                                    isDark\r\n                                        ? duoTaskModalStyles.tabTextDark\r\n                                        : duoTaskModalStyles.tabTextLight,\r\n                                ]}>\r\n                                Task Details\r\n                            </Text>\r\n                        </TouchableOpacity>\r\n                        <TouchableOpacity\r\n                            style={[\r\n                                duoTaskModalStyles.tab,\r\n                                activeTab === 'subtasks'\r\n                                    ? duoTaskModalStyles.tabActive\r\n                                    : duoTaskModalStyles.tabInactive,\r\n                            ]}\r\n                            onPress={() => setActiveTab('subtasks')}>\r\n                            <Text\r\n                                style={[\r\n                                    duoTaskModalStyles.tabText,\r\n                                    isDark\r\n                                        ? duoTaskModalStyles.tabTextDark\r\n                                        : duoTaskModalStyles.tabTextLight,\r\n                                ]}>\r\n                                Subtasks\r\n                            </Text>\r\n                        </TouchableOpacity>\r\n                        <TouchableOpacity\r\n                            style={[\r\n                                duoTaskModalStyles.tab,\r\n                                activeTab === 'collaboration'\r\n                                    ? duoTaskModalStyles.tabActive\r\n                                    : duoTaskModalStyles.tabInactive,\r\n                            ]}\r\n                            onPress={() => setActiveTab('collaboration')}>\r\n                            <Text\r\n                                style={[\r\n                                    duoTaskModalStyles.tabText,\r\n                                    duoTaskModalStyles.teamMembersTabText,\r\n                                    isDark\r\n                                        ? duoTaskModalStyles.tabTextDark\r\n                                        : duoTaskModalStyles.tabTextLight,\r\n                                ]}>\r\n                                Team Members\r\n                            </Text>\r\n                        </TouchableOpacity>\r\n                    </View>\r\n\r\n                    <ScrollView style={styles.modalBody}>\r\n                        {/* Task Details Tab */}\r\n                        {activeTab === 'details' && (\r\n                            <>\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text\r\n                                        style={[\r\n                                            styles.inputLabel,\r\n                                            duoTaskModalStyles.inputLabel,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputLabelDark\r\n                                                : duoTaskModalStyles.inputLabelLight,\r\n                                        ]}>\r\n                                        Title *\r\n                                    </Text>\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            duoTaskModalStyles.input,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputDark\r\n                                                : duoTaskModalStyles.inputLight,\r\n                                        ]}\r\n                                        placeholder=\"Task title\"\r\n                                        placeholderTextColor={\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.placeholderDark.color\r\n                                                : duoTaskModalStyles.placeholderLight.color\r\n                                        }\r\n                                        value={task.title}\r\n                                        onChangeText={text => onChangeTask({ ...task, title: text })}\r\n                                    />\r\n                                </View>\r\n\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text\r\n                                        style={[\r\n                                            styles.inputLabel,\r\n                                            duoTaskModalStyles.inputLabel,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputLabelDark\r\n                                                : duoTaskModalStyles.inputLabelLight,\r\n                                        ]}>\r\n                                        Description\r\n                                    </Text>\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            duoTaskModalStyles.input,\r\n                                            duoTaskModalStyles.descriptionInput,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputDark\r\n                                                : duoTaskModalStyles.inputLight,\r\n                                        ]}\r\n                                        placeholder=\"Task description\"\r\n                                        placeholderTextColor={\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.placeholderDark.color\r\n                                                : duoTaskModalStyles.placeholderLight.color\r\n                                        }\r\n                                        value={task.description}\r\n                                        onChangeText={text =>\r\n                                            onChangeTask({ ...task, description: text })\r\n                                        }\r\n                                        multiline\r\n                                        numberOfLines={4}\r\n                                    />\r\n                                </View>\r\n\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text\r\n                                        style={[\r\n                                            styles.inputLabel,\r\n                                            duoTaskModalStyles.inputLabel,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputLabelDark\r\n                                                : duoTaskModalStyles.inputLabelLight,\r\n                                        ]}>\r\n                                        Due Date\r\n                                    </Text>\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            duoTaskModalStyles.input,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputDark\r\n                                                : duoTaskModalStyles.inputLight,\r\n                                        ]}\r\n                                        placeholder=\"Select due date\"\r\n                                        placeholderTextColor={\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.placeholderDark.color\r\n                                                : duoTaskModalStyles.placeholderLight.color\r\n                                        }\r\n                                        value={task.dueDate}\r\n                                        onChangeText={text =>\r\n                                            onChangeTask({ ...task, dueDate: text })\r\n                                        }\r\n                                    />\r\n                                </View>\r\n\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text\r\n                                        style={[\r\n                                            styles.inputLabel,\r\n                                            duoTaskModalStyles.inputLabel,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputLabelDark\r\n                                                : duoTaskModalStyles.inputLabelLight,\r\n                                        ]}>\r\n                                        Due Time\r\n                                    </Text>\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            duoTaskModalStyles.input,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputDark\r\n                                                : duoTaskModalStyles.inputLight,\r\n                                        ]}\r\n                                        placeholder=\"HH:MM (24-hour format)\"\r\n                                        placeholderTextColor={\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.placeholderDark.color\r\n                                                : duoTaskModalStyles.placeholderLight.color\r\n                                        }\r\n                                        value={task.dueTime}\r\n                                        onChangeText={text =>\r\n                                            onChangeTask({ ...task, dueTime: text })\r\n                                        }\r\n                                    />\r\n                                </View>\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text\r\n                                        style={[\r\n                                            styles.inputLabel,\r\n                                            duoTaskModalStyles.inputLabel,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputLabelDark\r\n                                                : duoTaskModalStyles.inputLabelLight,\r\n                                        ]}>\r\n                                        Priority\r\n                                    </Text>\r\n                                    <View style={styles.prioritySelector}>\r\n                                        {['low', 'medium', 'high'].map(priority => (\r\n                                            <TouchableOpacity\r\n                                                key={priority}\r\n                                                style={[\r\n                                                    styles.priorityOption,\r\n                                                    duoTaskModalStyles.priorityButton,\r\n                                                    isDark\r\n                                                        ? duoTaskModalStyles.priorityButtonDark\r\n                                                        : duoTaskModalStyles.priorityButtonLight,\r\n                                                    task.priority === priority &&\r\n                                                    duoTaskModalStyles.priorityButtonActive,\r\n                                                ]}\r\n                                                onPress={() =>\r\n                                                    onChangeTask({\r\n                                                        ...task,\r\n                                                        priority: priority as 'low' | 'medium' | 'high',\r\n                                                    })\r\n                                                }>\r\n                                                <Text\r\n                                                    style={[\r\n                                                        duoTaskModalStyles.priorityButtonText,\r\n                                                        task.priority === priority\r\n                                                            ? duoTaskModalStyles.priorityButtonTextActive\r\n                                                            : isDark\r\n                                                                ? duoTaskModalStyles.priorityButtonTextDark\r\n                                                                : duoTaskModalStyles.priorityButtonTextLight,\r\n                                                    ]}>\r\n                                                    {priority.charAt(0).toUpperCase() + priority.slice(1)}\r\n                                                </Text>\r\n                                            </TouchableOpacity>\r\n                                        ))}\r\n                                    </View>\r\n                                </View>\r\n\r\n                                <View style={styles.inputGroup}>\r\n                                    <View style={styles.notifyContainer}>\r\n                                        <Text\r\n                                            style={[\r\n                                                styles.inputLabel,\r\n                                                duoTaskModalStyles.inputLabel,\r\n                                                isDark\r\n                                                    ? duoTaskModalStyles.inputLabelDark\r\n                                                    : duoTaskModalStyles.inputLabelLight,\r\n                                            ]}>\r\n                                            Send Notification\r\n                                        </Text>\r\n                                        <Switch\r\n                                            trackColor={{\r\n                                                false: isDark\r\n                                                    ? duoTaskModalStyles.switchTrackDark.backgroundColor\r\n                                                    : duoTaskModalStyles.switchTrackLight.backgroundColor,\r\n                                                true: duoTaskModalStyles.switchTrackActive\r\n                                                    .backgroundColor,\r\n                                            }}\r\n                                            thumbColor={\r\n                                                task.notify\r\n                                                    ? duoTaskModalStyles.switchThumbActive.backgroundColor\r\n                                                    : isDark\r\n                                                        ? duoTaskModalStyles.switchThumbDark.backgroundColor\r\n                                                        : duoTaskModalStyles.switchThumbLight\r\n                                                            .backgroundColor\r\n                                            }\r\n                                            ios_backgroundColor={\r\n                                                isDark\r\n                                                    ? duoTaskModalStyles.switchTrackDark.backgroundColor\r\n                                                    : duoTaskModalStyles.switchTrackLight.backgroundColor\r\n                                            }\r\n                                            onValueChange={value =>\r\n                                                onChangeTask({ ...task, notify: value })\r\n                                            }\r\n                                            value={task.notify}\r\n                                            testID='notifySwitch'\r\n                                        />\r\n                                    </View>\r\n                                </View>\r\n                            </>\r\n                        )}\r\n\r\n                        {/* Subtasks Tab */}\r\n                        {activeTab === 'subtasks' && (\r\n                            <>\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text\r\n                                        style={[\r\n                                            styles.inputLabel,\r\n                                            duoTaskModalStyles.inputLabel,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputLabelDark\r\n                                                : duoTaskModalStyles.inputLabelLight,\r\n                                        ]}>\r\n                                        Add Subtasks\r\n                                    </Text>\r\n                                    <Text\r\n                                        style={[\r\n                                            duoTaskModalStyles.descriptionText,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.descriptionTextDark\r\n                                                : duoTaskModalStyles.descriptionTextLight,\r\n                                        ]}>\r\n                                        Break down your task into smaller, manageable subtasks\r\n                                    </Text>\r\n\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            duoTaskModalStyles.input,\r\n                                            duoTaskModalStyles.subtaskInput,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputDark\r\n                                                : duoTaskModalStyles.inputLight,\r\n                                        ]}\r\n                                        placeholder=\"Subtask title\"\r\n                                        placeholderTextColor={\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.placeholderDark.color\r\n                                                : duoTaskModalStyles.placeholderLight.color\r\n                                        }\r\n                                        value={newSubtaskTitle}\r\n                                        onChangeText={setNewSubtaskTitle}\r\n                                    />\r\n\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            duoTaskModalStyles.input,\r\n                                            duoTaskModalStyles.subtaskDescriptionInput,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputDark\r\n                                                : duoTaskModalStyles.inputLight,\r\n                                        ]}\r\n                                        placeholder=\"Subtask Description (optional)\"\r\n                                        placeholderTextColor={\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.placeholderDark.color\r\n                                                : duoTaskModalStyles.placeholderLight.color\r\n                                        }\r\n                                        value={newSubtaskDescription}\r\n                                        onChangeText={setNewSubtaskDescription}\r\n                                    />\r\n\r\n                                    <TouchableOpacity\r\n                                        testID=\"addSubtask\"\r\n                                        style={duoTaskModalStyles.addButton}\r\n                                        onPress={addSubtask}>\r\n                                        <Text style={duoTaskModalStyles.addButtonText}>\r\n                                            Add Subtask\r\n                                        </Text>\r\n                                    </TouchableOpacity>\r\n                                </View>\r\n\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text\r\n                                        style={[\r\n                                            styles.inputLabel,\r\n                                            duoTaskModalStyles.inputLabel,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputLabelDark\r\n                                                : duoTaskModalStyles.inputLabelLight,\r\n                                            duoTaskModalStyles.subtasksCount,\r\n                                        ]}>\r\n                                        Subtasks ({subtasks.length})\r\n                                    </Text>\r\n\r\n                                    {subtasks.length === 0 ? (\r\n                                        <Text\r\n                                            style={{\r\n                                                color: isDark ? '#8e8e8e' : '#666',\r\n                                                textAlign: 'center',\r\n                                                padding: 20,\r\n                                            }}>\r\n                                            No subtasks yet. Add some to track progress!\r\n                                        </Text>\r\n                                    ) : (\r\n                                        <LegendList\r\n                                            data={subtasks}\r\n                                            keyExtractor={item => item.id}\r\n                                            estimatedItemSize={50}\r\n                                            recycleItems={true}\r\n                                            renderItem={({ item }) => (\r\n                                                <View\r\n                                                    style={{\r\n                                                        flexDirection: 'row',\r\n                                                        padding: 10,\r\n                                                        borderBottomWidth: 1,\r\n                                                        borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                                                        alignItems: 'center',\r\n                                                    }}>\r\n                                                    <TouchableOpacity\r\n                                                        testID='taskCompletionToggleButton'\r\n                                                        style={[\r\n                                                            duoTaskModalStyles.subtaskCheckbox,\r\n                                                            {\r\n                                                                borderColor: isDark\r\n                                                                    ? duoTaskModalStyles.subtaskCheckboxDark\r\n                                                                        .borderColor\r\n                                                                    : duoTaskModalStyles.subtaskCheckboxLight\r\n                                                                        .borderColor,\r\n                                                                backgroundColor: item.completed\r\n                                                                    ? duoTaskModalStyles.subtaskCheckboxActive\r\n                                                                        .backgroundColor\r\n                                                                    : duoTaskModalStyles.subtaskCheckboxInactive\r\n                                                                        .backgroundColor,\r\n                                                            },\r\n                                                        ]}\r\n                                                        onPress={() => toggleSubtaskCompletion(item.id)}>\r\n                                                        {item.completed && (\r\n                                                            <Icon testID=\"checkmark\" name=\"checkmark\" size={16} color=\"white\" />\r\n                                                        )}\r\n                                                    </TouchableOpacity>\r\n\r\n                                                    <View\r\n                                                        style={duoTaskModalStyles.subtaskTitleContainer}>\r\n                                                        <Text\r\n                                                            style={[\r\n                                                                duoTaskModalStyles.subtaskTitle,\r\n                                                                isDark\r\n                                                                    ? duoTaskModalStyles.subtaskTitleDark\r\n                                                                    : duoTaskModalStyles.subtaskTitleLight,\r\n                                                                item.completed &&\r\n                                                                duoTaskModalStyles.subtaskTitleCompleted,\r\n                                                            ]}>\r\n                                                            {item.title}\r\n                                                        </Text>\r\n                                                        {item.description && (\r\n                                                            <Text\r\n                                                                style={[\r\n                                                                    duoTaskModalStyles.subtaskDescription,\r\n                                                                    isDark\r\n                                                                        ? duoTaskModalStyles.subtaskDescriptionDark\r\n                                                                        : duoTaskModalStyles.subtaskDescriptionLight,\r\n                                                                    item.completed &&\r\n                                                                    duoTaskModalStyles.subtaskDescriptionCompleted,\r\n                                                                ]}>\r\n                                                                {item.description}\r\n                                                            </Text>\r\n                                                        )}\r\n                                                    </View>\r\n\r\n                                                    <TouchableOpacity\r\n                                                        onPress={() => removeSubtask(item.id)}\r\n                                                        style={duoTaskModalStyles.removeSubtaskButton}>\r\n                                                        <Icon\r\n                                                            name=\"trash-outline\"\r\n                                                            size={20}\r\n                                                            color={\r\n                                                                isDark\r\n                                                                    ? duoTaskModalStyles.removeSubtaskIconDark\r\n                                                                        .color\r\n                                                                    : duoTaskModalStyles.removeSubtaskIconLight\r\n                                                                        .color\r\n                                                            }\r\n                                                        />\r\n                                                    </TouchableOpacity>\r\n                                                </View>\r\n                                            )}\r\n                                            style={duoTaskModalStyles.subtaskList}\r\n                                        />\r\n                                    )}\r\n                                </View>\r\n                            </>\r\n                        )}\r\n\r\n                        {/* Collaboration Tab */}\r\n                        {activeTab === 'collaboration' && (\r\n                            <>\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text\r\n                                        style={[\r\n                                            styles.inputLabel,\r\n                                            duoTaskModalStyles.inputLabel,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputLabelDark\r\n                                                : duoTaskModalStyles.inputLabelLight,\r\n                                        ]}>\r\n                                        Add Team Members\r\n                                    </Text>\r\n                                    <Text\r\n                                        style={[\r\n                                            duoTaskModalStyles.descriptionText,\r\n                                            duoTaskModalStyles.collaborationHintText,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.collaborationHintTextDark\r\n                                                : duoTaskModalStyles.collaborationHintTextLight,\r\n                                        ]}>\r\n                                        Enter email of the person you want to add to the team\r\n                                    </Text>\r\n                                    <View style={duoTaskModalStyles.collaboratorInputContainer}>\r\n                                        <TextInput\r\n                                            style={[\r\n                                                styles.input,\r\n                                                duoTaskModalStyles.input,\r\n                                                duoTaskModalStyles.collaboratorInput,\r\n                                                isDark\r\n                                                    ? duoTaskModalStyles.inputDark\r\n                                                    : duoTaskModalStyles.inputLight,\r\n                                            ]}\r\n                                            placeholder=\"Team member email\"\r\n                                            placeholderTextColor={\r\n                                                isDark\r\n                                                    ? duoTaskModalStyles.placeholderDark.color\r\n                                                    : duoTaskModalStyles.placeholderLight.color\r\n                                            }\r\n                                            value={collaboratorEmail}\r\n                                            onChangeText={setCollaboratorEmail}\r\n                                            keyboardType=\"email-address\"\r\n                                        />\r\n\r\n                                        <TouchableOpacity\r\n                                            style={duoTaskModalStyles.addCollaboratorButton}\r\n                                            onPress={searchCollaborator}\r\n                                            disabled={isSearching}>\r\n                                            {isSearching ? (\r\n                                                <ActivityIndicator size=\"small\" color=\"white\" />\r\n                                            ) : (\r\n                                                <Text\r\n                                                    style={duoTaskModalStyles.addCollaboratorButtonText}>\r\n                                                    Add\r\n                                                </Text>\r\n                                            )}\r\n                                        </TouchableOpacity>\r\n                                    </View>\r\n\r\n                                    {error && (\r\n                                        <Text style={duoTaskModalStyles.errorText}>{error}</Text>\r\n                                    )}\r\n\r\n                                    <Text\r\n                                        style={[\r\n                                            styles.inputLabel,\r\n                                            duoTaskModalStyles.inputLabel,\r\n                                            duoTaskModalStyles.teamMembersCount,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.inputLabelDark\r\n                                                : duoTaskModalStyles.inputLabelLight,\r\n                                        ]}>\r\n                                        Team Members ({collaborators.length})\r\n                                    </Text>\r\n\r\n                                    {collaborators.length === 0 ? (\r\n                                        <Text\r\n                                            style={[\r\n                                                duoTaskModalStyles.emptyTeamMembersText,\r\n                                                isDark\r\n                                                    ? duoTaskModalStyles.collaborationHintTextDark\r\n                                                    : duoTaskModalStyles.collaborationHintTextLight,\r\n                                            ]}>\r\n                                            No team members added yet. Add team members to work\r\n                                            together!\r\n                                        </Text>\r\n                                    ) : (\r\n                                        <LegendList\r\n                                            data={collaborators}\r\n                                            keyExtractor={item => item.id}\r\n                                            estimatedItemSize={60}\r\n                                            recycleItems={true}\r\n                                            renderItem={({ item }) => (\r\n                                                <View\r\n                                                    style={[\r\n                                                        duoTaskModalStyles.collaboratorItem,\r\n                                                        isDark\r\n                                                            ? duoTaskModalStyles.collaboratorItemDark\r\n                                                            : duoTaskModalStyles.collaboratorItemLight,\r\n                                                    ]}>\r\n                                                    <View style={duoTaskModalStyles.collaboratorDetails}>\r\n                                                        <Text\r\n                                                            style={[\r\n                                                                isDark\r\n                                                                    ? duoTaskModalStyles.collaboratorNameDark\r\n                                                                    : duoTaskModalStyles.collaboratorNameLight,\r\n                                                            ]}>\r\n                                                            {item.displayName}\r\n                                                        </Text>\r\n                                                        <Text\r\n                                                            style={[\r\n                                                                isDark\r\n                                                                    ? duoTaskModalStyles.collaboratorEmailDark\r\n                                                                    : duoTaskModalStyles.collaboratorEmailLight,\r\n                                                            ]}>\r\n                                                            {item.email}\r\n                                                        </Text>\r\n                                                    </View>\r\n\r\n                                                    <TouchableOpacity\r\n                                                        onPress={() => removeCollaborator(item.id)}\r\n                                                        style={duoTaskModalStyles.removeCollaboratorButton}>\r\n                                                        <Icon\r\n                                                            name=\"close-circle\"\r\n                                                            size={24}\r\n                                                            color={\r\n                                                                isDark\r\n                                                                    ? duoTaskModalStyles\r\n                                                                        .removeCollaboratorIconDark.color\r\n                                                                    : duoTaskModalStyles\r\n                                                                        .removeCollaboratorIconLight.color\r\n                                                            }\r\n                                                        />\r\n                                                    </TouchableOpacity>\r\n                                                </View>\r\n                                            )}\r\n                                        />\r\n                                    )}\r\n\r\n                                    {collaborators.length > 0 && (\r\n                                        <TouchableOpacity\r\n                                            style={duoTaskModalStyles.removeAllCollaboratorsButton}\r\n                                            onPress={resetCollaboration}>\r\n                                            <Text\r\n                                                style={\r\n                                                    duoTaskModalStyles.removeAllCollaboratorsButtonText\r\n                                                }>\r\n                                                Remove All Team Members\r\n                                            </Text>\r\n                                        </TouchableOpacity>\r\n                                    )}\r\n\r\n                                    <Text\r\n                                        style={[\r\n                                            duoTaskModalStyles.collaborationHintText,\r\n                                            isDark\r\n                                                ? duoTaskModalStyles.collaborationHintTextDark\r\n                                                : duoTaskModalStyles.collaborationHintTextLight,\r\n                                        ]}>\r\n                                        Once you save the task, all team members will receive\r\n                                        invitations to collaborate.\r\n                                    </Text>\r\n                                </View>\r\n                            </>\r\n                        )}\r\n                    </ScrollView>\r\n\r\n                    <View style={styles.modalFooter}>\r\n                        <TouchableOpacity\r\n                            style={[styles.button, styles.cancelButton]}\r\n                            onPress={onClose}>\r\n                            <Text style={styles.buttonText}>Cancel</Text>\r\n                        </TouchableOpacity>\r\n                        <TouchableOpacity\r\n                            style={[styles.button, styles.saveButton]}\r\n                            onPress={onSave}>\r\n                            <Text style={styles.buttonText}>Save</Text>\r\n                        </TouchableOpacity>\r\n                    </View>\r\n                </View>\r\n            </View>\r\n        </Modal>\r\n    );\r\n};\r\n\r\nexport default DuoTaskModal;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\components\\FilterBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\components\\InvitationItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\components\\TaskItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\components\\TaskModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Task' is defined but never used.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":14},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: \"isDark ? '#1a1a1a' : 'white'\" }","line":36,"column":13,"nodeType":"ObjectExpression","endLine":36,"endColumn":62},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":40,"column":42,"nodeType":"ObjectExpression","endLine":40,"endColumn":79},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":53,"column":19,"nodeType":"ObjectExpression","endLine":53,"endColumn":56},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: \"isDark ? '#2a2a2a' : '#f5f5f5'\",\n  color: \"isDark ? 'white' : 'black'\",\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\"\n}","line":60,"column":19,"nodeType":"ObjectExpression","endLine":64,"endColumn":20},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":77,"column":19,"nodeType":"ObjectExpression","endLine":77,"endColumn":56},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: \"isDark ? '#2a2a2a' : '#f5f5f5'\",\n  color: \"isDark ? 'white' : 'black'\",\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\"\n}","line":85,"column":19,"nodeType":"ObjectExpression","endLine":89,"endColumn":20},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":106,"column":19,"nodeType":"ObjectExpression","endLine":106,"endColumn":56},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: \"isDark ? '#2a2a2a' : '#f5f5f5'\",\n  color: \"isDark ? 'white' : 'black'\",\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\"\n}","line":113,"column":19,"nodeType":"ObjectExpression","endLine":117,"endColumn":20},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":130,"column":19,"nodeType":"ObjectExpression","endLine":130,"endColumn":56},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: \"isDark ? '#2a2a2a' : '#f5f5f5'\",\n  color: \"isDark ? 'white' : 'black'\",\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\"\n}","line":137,"column":19,"nodeType":"ObjectExpression","endLine":141,"endColumn":20},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":154,"column":19,"nodeType":"ObjectExpression","endLine":154,"endColumn":56},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: \"isDark ? '#2a2a2a' : '#f5f5f5'\",\n  color: \"isDark ? 'white' : 'black'\",\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\"\n}","line":161,"column":19,"nodeType":"ObjectExpression","endLine":165,"endColumn":20},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":180,"column":19,"nodeType":"ObjectExpression","endLine":180,"endColumn":56},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { borderColor: \"isDark ? '#404040' : '#e0e0e0'\" }","line":190,"column":23,"nodeType":"ObjectExpression","endLine":198,"endColumn":24},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: 'newTask.priority === priority\\r\\n' +\n    \"                              ? 'white'\\r\\n\" +\n    '                              : isDark\\r\\n' +\n    \"                                ? 'white'\\r\\n\" +\n    \"                                : 'black'\"\n}","line":209,"column":25,"nodeType":"ObjectExpression","endLine":216,"endColumn":26},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":229,"column":21,"nodeType":"ObjectExpression","endLine":229,"endColumn":58},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\" }","line":254,"column":21,"nodeType":"ObjectExpression","endLine":254,"endColumn":59},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":266,"column":21,"nodeType":"ObjectExpression","endLine":266,"endColumn":58},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: '!newTask.completed\\r\\n' +\n    \"                          ? '#1a9cd8'\\r\\n\" +\n    '                          : isDark\\r\\n' +\n    \"                            ? '#2a2a2a'\\r\\n\" +\n    \"                            : '#f5f5f5'\",\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\"\n}","line":274,"column":23,"nodeType":"ObjectExpression","endLine":281,"endColumn":24},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: '!newTask.completed\\r\\n' +\n    \"                            ? 'white'\\r\\n\" +\n    '                            : isDark\\r\\n' +\n    \"                              ? 'white'\\r\\n\" +\n    \"                              : 'black'\"\n}","line":289,"column":25,"nodeType":"ObjectExpression","endLine":295,"endColumn":26},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: 'newTask.completed\\r\\n' +\n    \"                          ? '#34C759'\\r\\n\" +\n    '                          : isDark\\r\\n' +\n    \"                            ? '#2a2a2a'\\r\\n\" +\n    \"                            : '#f5f5f5'\",\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\"\n}","line":303,"column":23,"nodeType":"ObjectExpression","endLine":310,"endColumn":24},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: 'newTask.completed\\r\\n' +\n    \"                            ? 'white'\\r\\n\" +\n    '                            : isDark\\r\\n' +\n    \"                              ? 'white'\\r\\n\" +\n    \"                              : 'black'\"\n}","line":316,"column":25,"nodeType":"ObjectExpression","endLine":322,"endColumn":26}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":22,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport {\r\n  Modal,\r\n  View,\r\n  Text,\r\n  TouchableOpacity,\r\n  TextInput,\r\n  ScrollView,\r\n  Switch,\r\n} from 'react-native';\r\nimport Icon from 'react-native-vector-icons/Ionicons';\r\nimport { Task } from 'shared/types/taskTypes';\r\nimport { styles } from 'tasks/styles/Tasks.styles';\r\nimport { TaskModalProps } from '../types';\r\n\r\nconst TaskModal = ({\r\n  modalVisible,\r\n  isEditMode,\r\n  isDark,\r\n  newTask,\r\n  onClose,\r\n  onUpdateTask,\r\n  onChangeTask,\r\n  getPriorityColor,\r\n}: TaskModalProps) => {\r\n  return (\r\n    <Modal\r\n      animationType=\"slide\"\r\n      transparent={true}\r\n      visible={modalVisible}\r\n      onRequestClose={onClose}>\r\n      <View style={styles.modalOverlay}>\r\n        <View\r\n          style={[\r\n            styles.modalContent,\r\n            { backgroundColor: isDark ? '#1a1a1a' : 'white' },\r\n          ]}>\r\n          <View style={styles.modalHeader}>\r\n            <Text\r\n              style={[styles.modalTitle, { color: isDark ? 'white' : 'black' }]}>\r\n              {isEditMode ? 'Edit Task' : 'Add New Task'}\r\n            </Text>\r\n            <TouchableOpacity onPress={onClose}>\r\n              <Icon name=\"close\" size={24} color={isDark ? 'white' : 'black'} />\r\n            </TouchableOpacity>\r\n          </View>\r\n\r\n          <ScrollView style={styles.modalBody}>\r\n            <View style={styles.inputGroup}>\r\n              <Text\r\n                style={[\r\n                  styles.inputLabel,\r\n                  { color: isDark ? 'white' : 'black' },\r\n                ]}>\r\n                Title *\r\n              </Text>\r\n              <TextInput\r\n                style={[\r\n                  styles.input,\r\n                  {\r\n                    backgroundColor: isDark ? '#2a2a2a' : '#f5f5f5',\r\n                    color: isDark ? 'white' : 'black',\r\n                    borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                  },\r\n                ]}\r\n                placeholder=\"Task title\"\r\n                placeholderTextColor={isDark ? '#8e8e8e' : '#999'}\r\n                value={newTask.title}\r\n                onChangeText={text => onChangeTask({ ...newTask, title: text })}\r\n              />\r\n            </View>\r\n\r\n            <View style={styles.inputGroup}>\r\n              <Text\r\n                style={[\r\n                  styles.inputLabel,\r\n                  { color: isDark ? 'white' : 'black' },\r\n                ]}>\r\n                Description\r\n              </Text>\r\n              <TextInput\r\n                style={[\r\n                  styles.input,\r\n                  styles.textArea,\r\n                  {\r\n                    backgroundColor: isDark ? '#2a2a2a' : '#f5f5f5',\r\n                    color: isDark ? 'white' : 'black',\r\n                    borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                  },\r\n                ]}\r\n                placeholder=\"Task description\"\r\n                placeholderTextColor={isDark ? '#8e8e8e' : '#999'}\r\n                value={newTask.description}\r\n                onChangeText={text =>\r\n                  onChangeTask({ ...newTask, description: text })\r\n                }\r\n                multiline\r\n                numberOfLines={4}\r\n              />\r\n            </View>\r\n\r\n            <View style={styles.inputGroup}>\r\n              <Text\r\n                style={[\r\n                  styles.inputLabel,\r\n                  { color: isDark ? 'white' : 'black' },\r\n                ]}>\r\n                Due Date\r\n              </Text>\r\n              <TextInput\r\n                style={[\r\n                  styles.input,\r\n                  {\r\n                    backgroundColor: isDark ? '#2a2a2a' : '#f5f5f5',\r\n                    color: isDark ? 'white' : 'black',\r\n                    borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                  },\r\n                ]}\r\n                placeholder=\"YYYY-MM-DD\"\r\n                placeholderTextColor={isDark ? '#8e8e8e' : '#999'}\r\n                value={newTask.dueDate}\r\n                onChangeText={text => onChangeTask({ ...newTask, dueDate: text })}\r\n              />\r\n            </View>\r\n\r\n            <View style={styles.inputGroup}>\r\n              <Text\r\n                style={[\r\n                  styles.inputLabel,\r\n                  { color: isDark ? 'white' : 'black' },\r\n                ]}>\r\n                Due Time\r\n              </Text>\r\n              <TextInput\r\n                style={[\r\n                  styles.input,\r\n                  {\r\n                    backgroundColor: isDark ? '#2a2a2a' : '#f5f5f5',\r\n                    color: isDark ? 'white' : 'black',\r\n                    borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                  },\r\n                ]}\r\n                placeholder=\"HH:MM (24-hour format)\"\r\n                placeholderTextColor={isDark ? '#8e8e8e' : '#999'}\r\n                value={newTask.dueTime}\r\n                onChangeText={text => onChangeTask({ ...newTask, dueTime: text })}\r\n              />\r\n            </View>\r\n\r\n            <View style={styles.inputGroup}>\r\n              <Text\r\n                style={[\r\n                  styles.inputLabel,\r\n                  { color: isDark ? 'white' : 'black' },\r\n                ]}>\r\n                Category\r\n              </Text>\r\n              <TextInput\r\n                style={[\r\n                  styles.input,\r\n                  {\r\n                    backgroundColor: isDark ? '#2a2a2a' : '#f5f5f5',\r\n                    color: isDark ? 'white' : 'black',\r\n                    borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                  },\r\n                ]}\r\n                placeholder=\"e.g. Work, Personal, Health\"\r\n                placeholderTextColor={isDark ? '#8e8e8e' : '#999'}\r\n                value={newTask.category}\r\n                onChangeText={text =>\r\n                  onChangeTask({ ...newTask, category: text })\r\n                }\r\n              />\r\n            </View>\r\n\r\n            <View style={styles.inputGroup}>\r\n              <Text\r\n                style={[\r\n                  styles.inputLabel,\r\n                  { color: isDark ? 'white' : 'black' },\r\n                ]}>\r\n                Priority\r\n              </Text>\r\n              <View style={styles.prioritySelector}>\r\n                {['low', 'medium', 'high'].map(priority => (\r\n                  <TouchableOpacity\r\n                    key={priority}\r\n                    style={[\r\n                      styles.priorityOption,\r\n                      {\r\n                        backgroundColor:\r\n                          newTask.priority === priority\r\n                            ? getPriorityColor(priority)\r\n                            : isDark\r\n                              ? '#2a2a2a'\r\n                              : '#f5f5f5',\r\n                        borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                      },\r\n                    ]}\r\n                    onPress={() =>\r\n                      onChangeTask({\r\n                        ...newTask,\r\n                        priority: priority as 'low' | 'medium' | 'high',\r\n                      })\r\n                    }>\r\n                    <Text\r\n                      style={[\r\n                        styles.priorityText,\r\n                        {\r\n                          color:\r\n                            newTask.priority === priority\r\n                              ? 'white'\r\n                              : isDark\r\n                                ? 'white'\r\n                                : 'black',\r\n                        },\r\n                      ]}>\r\n                      {priority.charAt(0).toUpperCase() + priority.slice(1)}\r\n                    </Text>\r\n                  </TouchableOpacity>\r\n                ))}\r\n              </View>\r\n            </View>\r\n            <View style={styles.inputGroup}>\r\n              <View style={styles.notifyContainer}>\r\n                <Text\r\n                  style={[\r\n                    styles.inputLabel,\r\n                    { color: isDark ? 'white' : 'black' },\r\n                  ]}>\r\n                  Send Notification\r\n                </Text>\r\n                <Switch\r\n                  testID=\"notification-switch\"\r\n                  trackColor={{\r\n                    false: isDark ? '#555' : '#ccc',\r\n                    true: '#34C759',\r\n                  }}\r\n                  thumbColor={\r\n                    newTask.notify ? '#fff' : isDark ? '#888' : '#f4f3f4'\r\n                  }\r\n                  ios_backgroundColor={isDark ? '#555' : '#ccc'}\r\n                  onValueChange={value =>\r\n                    onChangeTask({ ...newTask, notify: value })\r\n                  }\r\n                  value={newTask.notify}\r\n\r\n                />\r\n              </View>\r\n              {newTask.notify && (\r\n                <Text\r\n                  style={[\r\n                    styles.notifyHint,\r\n                    { color: isDark ? '#8e8e8e' : '#666' },\r\n                  ]}>\r\n                  You will receive a notification at the scheduled time\r\n                </Text>\r\n              )}\r\n            </View>\r\n\r\n            {isEditMode && (\r\n              <View style={styles.inputGroup}>\r\n                <Text\r\n                  style={[\r\n                    styles.inputLabel,\r\n                    { color: isDark ? 'white' : 'black' },\r\n                  ]}>\r\n                  Status\r\n                </Text>\r\n                <View style={styles.statusSelector}>\r\n                  <TouchableOpacity\r\n                    style={[\r\n                      styles.statusOption,\r\n                      {\r\n                        backgroundColor: !newTask.completed\r\n                          ? '#1a9cd8'\r\n                          : isDark\r\n                            ? '#2a2a2a'\r\n                            : '#f5f5f5',\r\n                        borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                      },\r\n                    ]}\r\n                    onPress={() =>\r\n                      onChangeTask({ ...newTask, completed: false })\r\n                    }>\r\n                    <Text\r\n                      style={[\r\n                        styles.statusText,\r\n                        {\r\n                          color: !newTask.completed\r\n                            ? 'white'\r\n                            : isDark\r\n                              ? 'white'\r\n                              : 'black',\r\n                        },\r\n                      ]}>\r\n                      Pending\r\n                    </Text>\r\n                  </TouchableOpacity>\r\n                  <TouchableOpacity\r\n                    style={[\r\n                      styles.statusOption,\r\n                      {\r\n                        backgroundColor: newTask.completed\r\n                          ? '#34C759'\r\n                          : isDark\r\n                            ? '#2a2a2a'\r\n                            : '#f5f5f5',\r\n                        borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                      },\r\n                    ]}\r\n                    onPress={() => onChangeTask({ ...newTask, completed: true })}>\r\n                    <Text\r\n                      style={[\r\n                        styles.statusText,\r\n                        {\r\n                          color: newTask.completed\r\n                            ? 'white'\r\n                            : isDark\r\n                              ? 'white'\r\n                              : 'black',\r\n                        },\r\n                      ]}>\r\n                      Completed\r\n                    </Text>\r\n                  </TouchableOpacity>\r\n                </View>\r\n              </View>\r\n            )}\r\n          </ScrollView>\r\n\r\n          <View style={styles.modalFooter}>\r\n            <TouchableOpacity\r\n              style={[styles.modalButton, styles.cancelButton]}\r\n              onPress={onClose}>\r\n              <Text style={styles.cancelButtonText}>Cancel</Text>\r\n            </TouchableOpacity>\r\n\r\n            <TouchableOpacity\r\n              style={[styles.modalButton, styles.addButton]}\r\n              onPress={onUpdateTask}>\r\n              <Text style={styles.addButtonText}>\r\n                {isEditMode ? 'Update Task' : 'Add Task'}\r\n              </Text>\r\n            </TouchableOpacity>\r\n          </View>\r\n        </View>\r\n      </View>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nexport default React.memo(TaskModal);\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\components\\TeamTaskModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'collaboratorData' is assigned a value but never used. Allowed unused elements of array destructuring patterns must match /^_/u.","line":56,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":28},{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has a missing dependency: 'fetchCollaboratorDetails'. Either include it or remove the dependency array.","line":71,"column":8,"nodeType":"ArrayExpression","endLine":71,"endColumn":28,"suggestions":[{"desc":"Update the dependencies array to be: [fetchCollaboratorDetails, task.collaborators]","fix":{"range":[2614,2634],"text":"[fetchCollaboratorDetails, task.collaborators]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has missing dependencies: 'onChangeTask' and 'task'. Either include them or remove the dependency array. If 'onChangeTask' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":125,"column":8,"nodeType":"ArrayExpression","endLine":125,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [onChangeTask, subtasks, task]","fix":{"range":[4514,4524],"text":"[onChangeTask, subtasks, task]"}}]},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: \"isDark ? '#1a1a1a' : 'white'\" }","line":286,"column":21,"nodeType":"ObjectExpression","endLine":286,"endColumn":70},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":289,"column":58,"nodeType":"ObjectExpression","endLine":289,"endColumn":95},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":336,"column":70,"nodeType":"ObjectExpression","endLine":336,"endColumn":107},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":350,"column":70,"nodeType":"ObjectExpression","endLine":350,"endColumn":107},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":367,"column":70,"nodeType":"ObjectExpression","endLine":367,"endColumn":107},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":381,"column":70,"nodeType":"ObjectExpression","endLine":381,"endColumn":107},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":395,"column":70,"nodeType":"ObjectExpression","endLine":395,"endColumn":107},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":409,"column":70,"nodeType":"ObjectExpression","endLine":409,"endColumn":107},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { borderColor: \"isDark ? '#404040' : '#e0e0e0'\" }","line":416,"column":53,"nodeType":"ObjectExpression","endLine":421,"endColumn":54},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: 'task.priority === priority\\r\\n' +\n    \"                                                            ? 'white'\\r\\n\" +\n    \"                                                            : isDark ? 'white' : 'black'\"\n}","line":427,"column":53,"nodeType":"ObjectExpression","endLine":431,"endColumn":54},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":442,"column":74,"nodeType":"ObjectExpression","endLine":442,"endColumn":111},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":459,"column":70,"nodeType":"ObjectExpression","endLine":459,"endColumn":107},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { marginBottom: 5 }","line":470,"column":45,"nodeType":"ObjectExpression","endLine":470,"endColumn":64},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: \"isDark ? '#2a2a2a' : '#f5f5f5'\",\n  color: \"isDark ? 'white' : 'black'\",\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\",\n  marginBottom: 10\n}","line":481,"column":45,"nodeType":"ObjectExpression","endLine":486,"endColumn":46},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: '#1a9cd8',\n  padding: 10,\n  borderRadius: 5,\n  alignItems: 'center',\n  marginBottom: 20\n}","line":495,"column":48,"nodeType":"ObjectExpression","endLine":501,"endColumn":42},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: 'white' }","line":504,"column":54,"nodeType":"ObjectExpression","endLine":504,"endColumn":72},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\", marginBottom: 10 }","line":509,"column":70,"nodeType":"ObjectExpression","endLine":509,"endColumn":125},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDark ? '#8e8e8e' : '#666'\",\n  textAlign: 'center',\n  padding: 20\n}","line":514,"column":54,"nodeType":"ObjectExpression","endLine":514,"endColumn":126},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  flexDirection: 'row',\n  padding: 10,\n  borderBottomWidth: 1,\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\",\n  alignItems: 'center'\n}","line":524,"column":62,"nodeType":"ObjectExpression","endLine":530,"endColumn":50},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  width: 24,\n  height: 24,\n  borderRadius: 12,\n  borderWidth: 2,\n  borderColor: \"isDark ? '#8e8e8e' : '#666'\",\n  justifyContent: 'center',\n  alignItems: 'center',\n  backgroundColor: \"item.completed ? '#1a9cd8' : 'transparent'\",\n  marginRight: 10\n}","line":532,"column":64,"nodeType":"ObjectExpression","endLine":542,"endColumn":58},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { flex: 1 }","line":550,"column":66,"nodeType":"ObjectExpression","endLine":550,"endColumn":77},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDark ? 'white' : 'black'\",\n  textDecorationLine: \"item.completed ? 'line-through' : 'none'\",\n  opacity: 'item.completed ? 0.7 : 1'\n}","line":551,"column":70,"nodeType":"ObjectExpression","endLine":555,"endColumn":58},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDark ? '#8e8e8e' : '#666'\",\n  fontSize: 12,\n  textDecorationLine: \"item.completed ? 'line-through' : 'none'\",\n  opacity: 'item.completed ? 0.7 : 1'\n}","line":559,"column":74,"nodeType":"ObjectExpression","endLine":564,"endColumn":62},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":585,"column":70,"nodeType":"ObjectExpression","endLine":585,"endColumn":107},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDark ? '#8e8e8e' : '#666'\",\n  marginBottom: 10,\n  fontSize: 12\n}","line":588,"column":51,"nodeType":"ObjectExpression","endLine":588,"endColumn":121},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { flexDirection: 'row', marginBottom: 10 }","line":592,"column":50,"nodeType":"ObjectExpression","endLine":592,"endColumn":92},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: \"isDark ? '#2a2a2a' : '#f5f5f5'\",\n  color: \"isDark ? 'white' : 'black'\",\n  borderColor: \"isDark ? '#404040' : '#e0e0e0'\",\n  flex: 1,\n  marginRight: 5\n}","line":596,"column":49,"nodeType":"ObjectExpression","endLine":602,"endColumn":50},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  backgroundColor: '#1a9cd8',\n  padding: 10,\n  borderRadius: 5,\n  justifyContent: 'center'\n}","line":612,"column":52,"nodeType":"ObjectExpression","endLine":617,"endColumn":46},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: 'white' }","line":624,"column":62,"nodeType":"ObjectExpression","endLine":624,"endColumn":80},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: '#FF3B30', marginBottom: 10 }","line":630,"column":54,"nodeType":"ObjectExpression","endLine":630,"endColumn":92},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDark ? 'white' : 'black'\",\n  marginTop: 20,\n  marginBottom: 10\n}","line":635,"column":70,"nodeType":"ObjectExpression","endLine":635,"endColumn":140},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  color: \"isDark ? '#8e8e8e' : '#666'\",\n  textAlign: 'center',\n  padding: 10\n}","line":640,"column":54,"nodeType":"ObjectExpression","endLine":640,"endColumn":126},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  flexDirection: 'row',\n  padding: 10,\n  backgroundColor: \"isDark ? '#2a2a2a' : '#f5f5f5'\",\n  borderRadius: 5,\n  alignItems: 'center',\n  marginBottom: 10\n}","line":650,"column":62,"nodeType":"ObjectExpression","endLine":657,"endColumn":50},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { flex: 1 }","line":658,"column":66,"nodeType":"ObjectExpression","endLine":658,"endColumn":77},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? 'white' : 'black'\" }","line":659,"column":70,"nodeType":"ObjectExpression","endLine":659,"endColumn":107},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\", fontSize: 12 }","line":662,"column":70,"nodeType":"ObjectExpression","endLine":662,"endColumn":122},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: {\n  marginTop: 10,\n  padding: 10,\n  borderRadius: 5,\n  backgroundColor: '#FF3B30',\n  alignItems: 'center'\n}","line":677,"column":52,"nodeType":"ObjectExpression","endLine":683,"endColumn":46},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: 'white' }","line":686,"column":58,"nodeType":"ObjectExpression","endLine":686,"endColumn":76},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isDark ? '#8e8e8e' : '#666'\", marginTop: 20, fontSize: 12 }","line":690,"column":51,"nodeType":"ObjectExpression","endLine":690,"endColumn":118}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":39,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\r\nimport {\r\n    Modal,\r\n    View,\r\n    Text,\r\n    TouchableOpacity,\r\n    TextInput,\r\n    ScrollView,\r\n    Switch,\r\n    Alert,\r\n    ActivityIndicator\r\n} from 'react-native';\r\nimport { LegendList } from '@legendapp/list';\r\nimport Icon from 'react-native-vector-icons/Ionicons';\r\nimport { Task, SubTask } from 'shared/types/taskTypes';\r\nimport { styles } from '../styles/Tasks.styles';\r\nimport { getFirestore, collection, doc, getDocs, Timestamp, query, where, limit } from '@react-native-firebase/firestore';\r\nimport { getAuth } from '@react-native-firebase/auth';\r\n\r\n// Custom UUID generator that doesn't rely on crypto.getRandomValues()\r\nconst generateUUID = (): string => {\r\n    // Use a timestamp-based prefix to ensure uniqueness\r\n    const timestamp = Date.now().toString(36);\r\n\r\n    // Generate random segments\r\n    const randomSegment1 = Math.random().toString(36).substring(2, 15);\r\n    const randomSegment2 = Math.random().toString(36).substring(2, 15);\r\n\r\n    // Combine timestamp and random segments to form a UUID-like string\r\n    return `${timestamp}-${randomSegment1}-${randomSegment2}`;\r\n};\r\n\r\ninterface TeamTaskModalProps {\r\n    modalVisible: boolean;\r\n    isEditMode: boolean;\r\n    isDark: boolean;\r\n    task: Omit<Task, 'id' | 'userId' | 'createdAt' | 'updatedAt'>;\r\n    onClose: () => void;\r\n    onSave: () => void;\r\n    onChangeTask: (task: Omit<Task, 'id' | 'userId' | 'createdAt' | 'updatedAt'>) => void;\r\n    getPriorityColor: (priority: string) => string;\r\n}\r\n\r\nconst TeamTaskModal: React.FC<TeamTaskModalProps> = ({\r\n    modalVisible,\r\n    isEditMode,\r\n    isDark,\r\n    task,\r\n    onClose,\r\n    onSave,\r\n    onChangeTask,\r\n    getPriorityColor\r\n}) => {\r\n    const [collaboratorEmail, setCollaboratorEmail] = useState('');\r\n    const [isSearching, setIsSearching] = useState(false);\r\n    const [collaboratorData, setCollaboratorData] = useState<any>(null);\r\n    const [collaborators, setCollaborators] = useState<any[]>([]);\r\n    const [error, setError] = useState<string | null>(null);\r\n    const [activeTab, setActiveTab] = useState('details'); // 'details', 'subtasks', 'collaboration'\r\n\r\n    // Subtask management\r\n    const [newSubtaskTitle, setNewSubtaskTitle] = useState('');\r\n    const [newSubtaskDescription, setNewSubtaskDescription] = useState('');\r\n    const [subtasks, setSubtasks] = useState<SubTask[]>(task.subtasks || []);\r\n\r\n    // Initialize collaborators list from task\r\n    useEffect(() => {\r\n        if (task.collaborators && task.collaborators.length > 0) {\r\n            fetchCollaboratorDetails();\r\n        }\r\n    }, [task.collaborators]);\r\n\r\n    // Fetch collaborator details for display\r\n    const fetchCollaboratorDetails = async () => {\r\n        if (!task.collaborators || task.collaborators.length === 0) return;\r\n\r\n        const currentUserId = getAuth().currentUser?.uid || '';\r\n        const otherCollaboratorIds = task.collaborators.filter(id => id !== currentUserId);\r\n\r\n        let collaboratorsList: any[] = [];\r\n        for (const id of otherCollaboratorIds) {\r\n            try {\r\n                const userDoc = await getDoc(doc(getFirestore(), 'users', id));\r\n                if (userDoc.exists) {\r\n                    const userData = userDoc.data();\r\n                    collaboratorsList.push({\r\n                        id: userDoc.id,\r\n                        displayName: userData?.displayName || userData?.email || 'Unknown User',\r\n                        email: userData?.email || '',\r\n                        photoURL: userData?.photoURL || null\r\n                    });\r\n                }\r\n            } catch (err) {\r\n                console.error('Error fetching collaborator details:', err);\r\n            }\r\n        }\r\n\r\n        setCollaborators(collaboratorsList);\r\n    };\r\n\r\n    // Sync subtasks with task\r\n    useEffect(() => {\r\n        if (task.subtasks) {\r\n            setSubtasks(task.subtasks);\r\n        }\r\n    }, [task.subtasks]);\r\n\r\n    // Update task subtasks when subtasks state changes\r\n    useEffect(() => {\r\n        onChangeTask({\r\n            ...task,\r\n            subtasks\r\n        });\r\n\r\n        // Calculate progress\r\n        if (subtasks.length > 0) {\r\n            const completedCount = subtasks.filter(s => s.completed).length;\r\n            const percentage = Math.round((completedCount / subtasks.length) * 100);\r\n            onChangeTask({\r\n                ...task,\r\n                subtasks,\r\n                progress: percentage\r\n            });\r\n        }\r\n    }, [subtasks]);\r\n\r\n    const searchCollaborator = async () => {\r\n        if (!collaboratorEmail) {\r\n            setError('Please enter a collaborator email');\r\n            return;\r\n        }\r\n\r\n        setIsSearching(true);\r\n        setError(null);\r\n\r\n        try {\r\n            // Search for user by email\r\n            const userSnapshot = await getDocs(query(collection(getFirestore(), 'users'), where('email', '==', collaboratorEmail), limit(1)));\r\n\r\n            if (userSnapshot.empty) {\r\n                setError('User not found');\r\n                setCollaboratorData(null);\r\n            } else {\r\n                const userData = userSnapshot.docs[0].data();\r\n                const userId = userSnapshot.docs[0].id;\r\n\r\n                // Check if user is trying to add themselves\r\n                if (userId === getAuth().currentUser?.uid) {\r\n                    setError('You cannot add yourself as a collaborator');\r\n                    setCollaboratorData(null);\r\n                    return;\r\n                }\r\n\r\n                // Check if user is already a collaborator\r\n                if (task.collaborators && task.collaborators.includes(userId)) {\r\n                    setError('This user is already a collaborator');\r\n                    setCollaboratorData(null);\r\n                    return;\r\n                }\r\n\r\n                setCollaboratorData({\r\n                    id: userId,\r\n                    displayName: userData.displayName || userData.email,\r\n                    email: userData.email,\r\n                    photoURL: userData.photoURL\r\n                });\r\n\r\n                // Add the new collaborator to the list\r\n                const currentUserId = getAuth().currentUser?.uid || '';\r\n                const existingCollaborators = task.collaborators || [currentUserId];\r\n                const updatedCollaborators = [...existingCollaborators];\r\n\r\n                if (!updatedCollaborators.includes(userId)) {\r\n                    updatedCollaborators.push(userId);\r\n                }\r\n\r\n                // Update the task with the new collaborator\r\n                onChangeTask({\r\n                    ...task,\r\n                    isDuoTask: true, // Keep this flag for compatibility\r\n                    isTeamTask: true, // New flag for team tasks\r\n                    collaborators: updatedCollaborators,\r\n                    collaborationStatus: 'pending'\r\n                });\r\n\r\n                // Add to UI collaborators list\r\n                setCollaborators([...collaborators, {\r\n                    id: userId,\r\n                    displayName: userData.displayName || userData.email,\r\n                    email: userData.email,\r\n                    photoURL: userData.photoURL\r\n                }]);\r\n\r\n                // Reset the input\r\n                setCollaboratorEmail('');\r\n                setCollaboratorData(null);\r\n            }\r\n        } catch (err) {\r\n            console.error('Error searching for collaborator:', err);\r\n            setError('An error occurred while searching for the collaborator');\r\n        } finally {\r\n            setIsSearching(false);\r\n        }\r\n    };\r\n\r\n    const addSubtask = () => {\r\n        if (!newSubtaskTitle.trim()) {\r\n            Alert.alert('Error', 'Subtask title is required');\r\n            return;\r\n        }\r\n\r\n        const newSubtask: SubTask = {\r\n            id: generateUUID(),\r\n            title: newSubtaskTitle,\r\n            description: newSubtaskDescription,\r\n            completed: false,\r\n            createdAt: Timestamp.now(),\r\n            updatedAt: Timestamp.now()\r\n        };\r\n\r\n        setSubtasks([...subtasks, newSubtask]);\r\n        setNewSubtaskTitle('');\r\n        setNewSubtaskDescription('');\r\n    };\r\n\r\n    const toggleSubtaskCompletion = (id: string) => {\r\n        setSubtasks(subtasks.map(subtask => {\r\n            if (subtask.id === id) {\r\n                return {\r\n                    ...subtask,\r\n                    completed: !subtask.completed,\r\n                    completedBy: !subtask.completed ? getAuth().currentUser?.uid : undefined,\r\n                    completedAt: !subtask.completed ? Timestamp.now() : undefined,\r\n                    updatedAt: Timestamp.now()\r\n                };\r\n            }\r\n            return subtask;\r\n        }));\r\n    };\r\n\r\n    const removeSubtask = (id: string) => {\r\n        setSubtasks(subtasks.filter(subtask => subtask.id !== id));\r\n    };\r\n\r\n    const removeCollaborator = (collaboratorId: string) => {\r\n        // Remove from collaborators list in the UI\r\n        setCollaborators(collaborators.filter(c => c.id !== collaboratorId));\r\n\r\n        // Remove from task collaborators array\r\n        if (task.collaborators) {\r\n            const updatedCollaborators = task.collaborators.filter(id => id !== collaboratorId);\r\n            onChangeTask({\r\n                ...task,\r\n                collaborators: updatedCollaborators,\r\n                // If only the current user remains, it's not a team task anymore\r\n                isTeamTask: updatedCollaborators.length > 1,\r\n                isDuoTask: updatedCollaborators.length > 1\r\n            });\r\n        }\r\n    };\r\n\r\n    // Reset collaboration if all collaborators are removed\r\n    const resetCollaboration = () => {\r\n        setCollaborators([]);\r\n        onChangeTask({\r\n            ...task,\r\n            isDuoTask: false,\r\n            isTeamTask: false,\r\n            collaborators: [getAuth().currentUser?.uid || ''],\r\n            collaborationStatus: undefined\r\n        });\r\n        setCollaboratorEmail('');\r\n        setCollaboratorData(null);\r\n    };\r\n\r\n    return (\r\n        <Modal\r\n            animationType=\"slide\"\r\n            transparent={true}\r\n            visible={modalVisible}\r\n            onRequestClose={onClose}\r\n        >\r\n            <View style={styles.modalOverlay}>\r\n                <View style={[\r\n                    styles.modalContent,\r\n                    { backgroundColor: isDark ? '#1a1a1a' : 'white' }\r\n                ]}>\r\n                    <View style={styles.modalHeader}>\r\n                        <Text style={[styles.modalTitle, { color: isDark ? 'white' : 'black' }]}>\r\n                            {isEditMode ? 'Edit Team Task' : 'Create Team Task'}\r\n                        </Text>\r\n                        <TouchableOpacity onPress={onClose}>\r\n                            <Icon name=\"close\" size={24} color={isDark ? 'white' : 'black'} />\r\n                        </TouchableOpacity>\r\n                    </View>\r\n\r\n                    {/* Tabs */}\r\n                    <View style={[\r\n                        styles.tabsContainer,\r\n                        isDark ? styles.darkTabsContainer : styles.lightTabsContainer\r\n                    ]}>\r\n                        <TouchableOpacity\r\n                            style={[\r\n                                styles.tabButton,\r\n                                activeTab === 'details' ? styles.tabButtonActive : styles.tabButtonInactive\r\n                            ]}\r\n                            onPress={() => setActiveTab('details')}\r\n                        >\r\n                            <Text style={isDark ? styles.darkTabText : styles.tabText}>Task Details</Text>\r\n                        </TouchableOpacity>\r\n                        <TouchableOpacity\r\n                            style={[\r\n                                styles.tabButton,\r\n                                activeTab === 'subtasks' ? styles.tabButtonActive : styles.tabButtonInactive\r\n                            ]}\r\n                            onPress={() => setActiveTab('subtasks')}\r\n                        >\r\n                            <Text style={isDark ? styles.darkTabText : styles.tabText}>Subtasks</Text>\r\n                        </TouchableOpacity>\r\n                        <TouchableOpacity\r\n                            style={[\r\n                                styles.tabButton,\r\n                                activeTab === 'collaboration' ? styles.tabButtonActive : styles.tabButtonInactive\r\n                            ]}\r\n                            onPress={() => setActiveTab('collaboration')}\r\n                        >\r\n                            <Text style={isDark ? styles.darkTabText : styles.tabText}>Team Members</Text>\r\n                        </TouchableOpacity>\r\n                    </View>\r\n\r\n                    <ScrollView style={styles.modalBody}>\r\n                        {/* Task Details Tab */}\r\n                        {activeTab === 'details' && (\r\n                            <>\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text style={[styles.inputLabel, { color: isDark ? 'white' : 'black' }]}>Title *</Text>\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            isDark ? styles.inputDark : styles.inputLight\r\n                                        ]}\r\n                                        placeholder=\"Task title\"\r\n                                        placeholderTextColor={isDark ? styles.placeholderDark.color : styles.placeholderLight.color}\r\n                                        value={task.title}\r\n                                        onChangeText={(text) => onChangeTask({ ...task, title: text })}\r\n                                    />\r\n                                </View>\r\n\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text style={[styles.inputLabel, { color: isDark ? 'white' : 'black' }]}>Description</Text>\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            styles.textArea,\r\n                                            isDark ? styles.inputDark : styles.inputLight\r\n                                        ]}\r\n                                        placeholder=\"Task description\"\r\n                                        placeholderTextColor={isDark ? styles.placeholderDark.color : styles.placeholderLight.color}\r\n                                        value={task.description}\r\n                                        onChangeText={(text) => onChangeTask({ ...task, description: text })}\r\n                                        multiline\r\n                                        numberOfLines={4}\r\n                                    />\r\n                                </View>\r\n\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text style={[styles.inputLabel, { color: isDark ? 'white' : 'black' }]}>Due Date</Text>\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            isDark ? styles.inputDark : styles.inputLight\r\n                                        ]}\r\n                                        placeholder=\"YYYY-MM-DD\"\r\n                                        placeholderTextColor={isDark ? styles.placeholderDark.color : styles.placeholderLight.color}\r\n                                        value={task.dueDate}\r\n                                        onChangeText={(text) => onChangeTask({ ...task, dueDate: text })}\r\n                                    />\r\n                                </View>\r\n\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text style={[styles.inputLabel, { color: isDark ? 'white' : 'black' }]}>Due Time</Text>\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            isDark ? styles.inputDark : styles.inputLight\r\n                                        ]}\r\n                                        placeholder=\"HH:MM (24-hour format)\"\r\n                                        placeholderTextColor={isDark ? styles.placeholderDark.color : styles.placeholderLight.color}\r\n                                        value={task.dueTime}\r\n                                        onChangeText={(text) => onChangeTask({ ...task, dueTime: text })}\r\n                                    />\r\n                                </View>\r\n\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text style={[styles.inputLabel, { color: isDark ? 'white' : 'black' }]}>Category</Text>\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            isDark ? styles.inputDark : styles.inputLight\r\n                                        ]}\r\n                                        placeholder=\"e.g. Work, Personal, Health\"\r\n                                        placeholderTextColor={isDark ? styles.placeholderDark.color : styles.placeholderLight.color}\r\n                                        value={task.category}\r\n                                        onChangeText={(text) => onChangeTask({ ...task, category: text })}\r\n                                    />\r\n                                </View>\r\n\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text style={[styles.inputLabel, { color: isDark ? 'white' : 'black' }]}>Priority</Text>\r\n                                    <View style={styles.prioritySelector}>\r\n                                        {['low', 'medium', 'high'].map((priority) => (\r\n                                            <TouchableOpacity\r\n                                                key={priority}\r\n                                                style={[\r\n                                                    styles.priorityOption,\r\n                                                    {\r\n                                                        backgroundColor: task.priority === priority\r\n                                                            ? getPriorityColor(priority)\r\n                                                            : isDark ? '#2a2a2a' : '#f5f5f5',\r\n                                                        borderColor: isDark ? '#404040' : '#e0e0e0'\r\n                                                    }\r\n                                                ]}\r\n                                                onPress={() => onChangeTask({ ...task, priority: priority as 'low' | 'medium' | 'high' })}\r\n                                            >\r\n                                                <Text style={[\r\n                                                    styles.priorityText,\r\n                                                    {\r\n                                                        color: task.priority === priority\r\n                                                            ? 'white'\r\n                                                            : isDark ? 'white' : 'black'\r\n                                                    }\r\n                                                ]}>\r\n                                                    {priority.charAt(0).toUpperCase() + priority.slice(1)}\r\n                                                </Text>\r\n                                            </TouchableOpacity>\r\n                                        ))}\r\n                                    </View>\r\n                                </View>\r\n\r\n                                <View style={styles.inputGroup}>\r\n                                    <View style={styles.notifyContainer}>\r\n                                        <Text style={[styles.inputLabel, { color: isDark ? 'white' : 'black' }]}>Send Notification</Text>\r\n                                        <Switch\r\n                                            trackColor={{ false: isDark ? '#555' : '#ccc', true: '#34C759' }}\r\n                                            thumbColor={task.notify ? '#fff' : isDark ? '#888' : '#f4f3f4'}\r\n                                            ios_backgroundColor={isDark ? '#555' : '#ccc'}\r\n                                            onValueChange={(value) => onChangeTask({ ...task, notify: value })}\r\n                                            value={task.notify}\r\n                                        />\r\n                                    </View>\r\n                                </View>\r\n                            </>\r\n                        )}\r\n\r\n                        {/* Subtasks Tab */}\r\n                        {activeTab === 'subtasks' && (\r\n                            <>\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text style={[styles.inputLabel, { color: isDark ? 'white' : 'black' }]}>\r\n                                        Add Subtasks\r\n                                    </Text>\r\n                                    <Text style={isDark ? styles.darkSubtaskDescription : styles.subtaskDescription}>\r\n                                        Break down your task into smaller, manageable subtasks\r\n                                    </Text>\r\n\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            isDark ? styles.inputDark : styles.inputLight,\r\n                                            { marginBottom: 5 }\r\n                                        ]}\r\n                                        placeholder=\"Subtask title\"\r\n                                        placeholderTextColor={isDark ? styles.placeholderDark.color : styles.placeholderLight.color}\r\n                                        value={newSubtaskTitle}\r\n                                        onChangeText={setNewSubtaskTitle}\r\n                                    />\r\n\r\n                                    <TextInput\r\n                                        style={[\r\n                                            styles.input,\r\n                                            {\r\n                                                backgroundColor: isDark ? '#2a2a2a' : '#f5f5f5',\r\n                                                color: isDark ? 'white' : 'black',\r\n                                                borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                                                marginBottom: 10\r\n                                            }\r\n                                        ]}\r\n                                        placeholder=\"Description (optional)\"\r\n                                        placeholderTextColor={isDark ? '#8e8e8e' : '#999'}\r\n                                        value={newSubtaskDescription}\r\n                                        onChangeText={setNewSubtaskDescription}\r\n                                    />\r\n\r\n                                    <TouchableOpacity\r\n                                        style={{\r\n                                            backgroundColor: '#1a9cd8',\r\n                                            padding: 10,\r\n                                            borderRadius: 5,\r\n                                            alignItems: 'center',\r\n                                            marginBottom: 20\r\n                                        }}\r\n                                        onPress={addSubtask}\r\n                                    >\r\n                                        <Text style={{ color: 'white' }}>Add Subtask</Text>\r\n                                    </TouchableOpacity>\r\n                                </View>\r\n\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text style={[styles.inputLabel, { color: isDark ? 'white' : 'black', marginBottom: 10 }]}>\r\n                                        Subtasks ({subtasks.length})\r\n                                    </Text>\r\n\r\n                                    {subtasks.length === 0 ? (\r\n                                        <Text style={{ color: isDark ? '#8e8e8e' : '#666', textAlign: 'center', padding: 20 }}>\r\n                                            No subtasks yet. Add some to track progress!\r\n                                        </Text>\r\n                                    ) : (\r\n                                        <LegendList\r\n                                            data={subtasks}\r\n                                            keyExtractor={(item) => item.id}\r\n                                            estimatedItemSize={50}\r\n                                            recycleItems={true}\r\n                                            renderItem={({ item }) => (\r\n                                                <View style={{\r\n                                                    flexDirection: 'row',\r\n                                                    padding: 10,\r\n                                                    borderBottomWidth: 1,\r\n                                                    borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                                                    alignItems: 'center'\r\n                                                }}>\r\n                                                    <TouchableOpacity\r\n                                                        style={{\r\n                                                            width: 24,\r\n                                                            height: 24,\r\n                                                            borderRadius: 12,\r\n                                                            borderWidth: 2,\r\n                                                            borderColor: isDark ? '#8e8e8e' : '#666',\r\n                                                            justifyContent: 'center',\r\n                                                            alignItems: 'center',\r\n                                                            backgroundColor: item.completed ? '#1a9cd8' : 'transparent',\r\n                                                            marginRight: 10\r\n                                                        }}\r\n                                                        onPress={() => toggleSubtaskCompletion(item.id)}\r\n                                                    >\r\n                                                        {item.completed && (\r\n                                                            <Icon name=\"checkmark\" size={16} color=\"white\" />\r\n                                                        )}\r\n                                                    </TouchableOpacity>\r\n\r\n                                                    <View style={{ flex: 1 }}>\r\n                                                        <Text style={{\r\n                                                            color: isDark ? 'white' : 'black',\r\n                                                            textDecorationLine: item.completed ? 'line-through' : 'none',\r\n                                                            opacity: item.completed ? 0.7 : 1\r\n                                                        }}>\r\n                                                            {item.title}\r\n                                                        </Text>\r\n                                                        {item.description && (\r\n                                                            <Text style={{\r\n                                                                color: isDark ? '#8e8e8e' : '#666',\r\n                                                                fontSize: 12,\r\n                                                                textDecorationLine: item.completed ? 'line-through' : 'none',\r\n                                                                opacity: item.completed ? 0.7 : 1\r\n                                                            }}>\r\n                                                                {item.description}\r\n                                                            </Text>\r\n                                                        )}\r\n                                                    </View>\r\n\r\n                                                    <TouchableOpacity onPress={() => removeSubtask(item.id)}>\r\n                                                        <Icon name=\"trash-outline\" size={20} color={isDark ? '#8e8e8e' : '#666'} />\r\n                                                    </TouchableOpacity>\r\n                                                </View>\r\n                                            )}\r\n                                        />\r\n                                    )}\r\n                                </View>\r\n                            </>\r\n                        )}\r\n\r\n                        {/* Collaboration Tab */}\r\n                        {activeTab === 'collaboration' && (\r\n                            <>\r\n                                <View style={styles.inputGroup}>\r\n                                    <Text style={[styles.inputLabel, { color: isDark ? 'white' : 'black' }]}>\r\n                                        Add Team Members\r\n                                    </Text>\r\n                                    <Text style={[{ color: isDark ? '#8e8e8e' : '#666', marginBottom: 10, fontSize: 12 }]}>\r\n                                        Enter email of the person you want to add to the team\r\n                                    </Text>\r\n\r\n                                    <View style={{ flexDirection: 'row', marginBottom: 10 }}>\r\n                                        <TextInput\r\n                                            style={[\r\n                                                styles.input,\r\n                                                {\r\n                                                    backgroundColor: isDark ? '#2a2a2a' : '#f5f5f5',\r\n                                                    color: isDark ? 'white' : 'black',\r\n                                                    borderColor: isDark ? '#404040' : '#e0e0e0',\r\n                                                    flex: 1,\r\n                                                    marginRight: 5\r\n                                                }\r\n                                            ]}\r\n                                            placeholder=\"Collaborator email\"\r\n                                            placeholderTextColor={isDark ? '#8e8e8e' : '#999'}\r\n                                            value={collaboratorEmail}\r\n                                            onChangeText={setCollaboratorEmail}\r\n                                            keyboardType=\"email-address\"\r\n                                        />\r\n\r\n                                        <TouchableOpacity\r\n                                            style={{\r\n                                                backgroundColor: '#1a9cd8',\r\n                                                padding: 10,\r\n                                                borderRadius: 5,\r\n                                                justifyContent: 'center'\r\n                                            }}\r\n                                            onPress={searchCollaborator}\r\n                                            disabled={isSearching}\r\n                                        >\r\n                                            {isSearching ? (\r\n                                                <ActivityIndicator size=\"small\" color=\"white\" />\r\n                                            ) : (\r\n                                                <Text style={{ color: 'white' }}>Add</Text>\r\n                                            )}\r\n                                        </TouchableOpacity>\r\n                                    </View>\r\n\r\n                                    {error && (\r\n                                        <Text style={{ color: '#FF3B30', marginBottom: 10 }}>\r\n                                            {error}\r\n                                        </Text>\r\n                                    )}\r\n\r\n                                    <Text style={[styles.inputLabel, { color: isDark ? 'white' : 'black', marginTop: 20, marginBottom: 10 }]}>\r\n                                        Team Members ({collaborators.length})\r\n                                    </Text>\r\n\r\n                                    {collaborators.length === 0 ? (\r\n                                        <Text style={{ color: isDark ? '#8e8e8e' : '#666', textAlign: 'center', padding: 10 }}>\r\n                                            No team members added yet. Add collaborators to work together!\r\n                                        </Text>\r\n                                    ) : (\r\n                                        <LegendList\r\n                                            data={collaborators}\r\n                                            keyExtractor={(item) => item.id}\r\n                                            estimatedItemSize={60}\r\n                                            recycleItems={true}\r\n                                            renderItem={({ item }) => (\r\n                                                <View style={{\r\n                                                    flexDirection: 'row',\r\n                                                    padding: 10,\r\n                                                    backgroundColor: isDark ? '#2a2a2a' : '#f5f5f5',\r\n                                                    borderRadius: 5,\r\n                                                    alignItems: 'center',\r\n                                                    marginBottom: 10\r\n                                                }}>\r\n                                                    <View style={{ flex: 1 }}>\r\n                                                        <Text style={{ color: isDark ? 'white' : 'black' }}>\r\n                                                            {item.displayName}\r\n                                                        </Text>\r\n                                                        <Text style={{ color: isDark ? '#8e8e8e' : '#666', fontSize: 12 }}>\r\n                                                            {item.email}\r\n                                                        </Text>\r\n                                                    </View>\r\n\r\n                                                    <TouchableOpacity onPress={() => removeCollaborator(item.id)}>\r\n                                                        <Icon name=\"close-circle\" size={24} color={isDark ? '#8e8e8e' : '#666'} />\r\n                                                    </TouchableOpacity>\r\n                                                </View>\r\n                                            )}\r\n                                        />\r\n                                    )}\r\n\r\n                                    {collaborators.length > 0 && (\r\n                                        <TouchableOpacity\r\n                                            style={{\r\n                                                marginTop: 10,\r\n                                                padding: 10,\r\n                                                borderRadius: 5,\r\n                                                backgroundColor: '#FF3B30',\r\n                                                alignItems: 'center'\r\n                                            }}\r\n                                            onPress={resetCollaboration}\r\n                                        >\r\n                                            <Text style={{ color: 'white' }}>Remove All Collaborators</Text>\r\n                                        </TouchableOpacity>\r\n                                    )}\r\n\r\n                                    <Text style={[{ color: isDark ? '#8e8e8e' : '#666', marginTop: 20, fontSize: 12 }]}>\r\n                                        Once you save the task, your team members will receive invitations.\r\n                                    </Text>\r\n                                </View>\r\n                            </>\r\n                        )}\r\n                    </ScrollView>\r\n\r\n                    <View style={styles.modalFooter}>\r\n                        <TouchableOpacity\r\n                            style={[styles.button, styles.cancelButton]}\r\n                            onPress={onClose}\r\n                        >\r\n                            <Text style={styles.buttonText}>Cancel</Text>\r\n                        </TouchableOpacity>\r\n                        <TouchableOpacity\r\n                            style={[styles.button, styles.saveButton]}\r\n                            onPress={onSave}\r\n                        >\r\n                            <Text style={styles.buttonText}>Save</Text>\r\n                        </TouchableOpacity>\r\n                    </View>\r\n                </View>\r\n            </View>\r\n        </Modal>\r\n    );\r\n};\r\n\r\nexport default TeamTaskModal;","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\hooks\\useDuoTasks.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has missing dependencies: 'detachListeners', 'fetchInvitations', 'fetchTasks', and 'setupTaskListeners'. Either include them or remove the dependency array.","line":164,"column":6,"nodeType":"ArrayExpression","endLine":164,"endColumn":17,"suggestions":[{"desc":"Update the dependencies array to be: [detachListeners, fetchInvitations, fetchTasks, isFocused, setupTaskListeners]","fix":{"range":[5222,5233],"text":"[detachListeners, fetchInvitations, fetchTasks, isFocused, setupTaskListeners]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useCallback has a missing dependency: 'closeModal'. Either include it or remove the dependency array.","line":192,"column":6,"nodeType":"ArrayExpression","endLine":192,"endColumn":40,"suggestions":[{"desc":"Update the dependencies array to be: [newTask, taskService, closeModal, fetchTasks]","fix":{"range":[6222,6256],"text":"[newTask, taskService, closeModal, fetchTasks]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useCallback has a missing dependency: 'closeModal'. Either include it or remove the dependency array.","line":206,"column":6,"nodeType":"ArrayExpression","endLine":206,"endColumn":54,"suggestions":[{"desc":"Update the dependencies array to be: [selectedTask, taskService, newTask, closeModal, fetchTasks]","fix":{"range":[6761,6809],"text":"[selectedTask, taskService, newTask, closeModal, fetchTasks]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\hooks\\useTasks.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useCallback has a missing dependency: 'closeModal'. Either include it or remove the dependency array.","line":167,"column":6,"nodeType":"ArrayExpression","endLine":174,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [newTask, isEditMode, currentTaskId, closeModal, fetchTasks, selectedFilter, taskService]","fix":{"range":[5328,5441],"text":"[newTask, isEditMode, currentTaskId, closeModal, fetchTasks, selectedFilter, taskService]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\screens\\DuoTasks.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\screens\\Tasks.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\styles\\Tasks.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\features\\Tasks\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\config\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\constants\\cloudinary.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\constants\\common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\constants\\gemini.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\constants\\navigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\constants\\style.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\constants\\svg.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\helpers\\ThemeListener.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'React' is defined but never used.","line":1,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":13},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'theme' is already declared in the upper scope on line 13 column 9.","line":40,"column":15,"nodeType":"Identifier","messageId":"noShadow","endLine":40,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\r\nimport { Appearance, ColorSchemeName, Platform } from 'react-native';\r\nimport { changeThemeColor } from 'shared/reducers/User';\r\nimport { useTypedDispatch } from 'hooks/redux/useTypedDispatch';\r\nimport { useTypedSelector } from 'hooks/redux/useTypedSelector';\r\nimport * as NavigationBar from 'expo-navigation-bar';\r\n\r\nconst ThemeListener = () => {\r\n  const dispatch = useTypedDispatch();\r\n  const customColorPreference = useTypedSelector(\r\n    state => state.user.customColorPrefrence,\r\n  );\r\n  const theme = useTypedSelector(state => state.user.theme);\r\n\r\n  // Effect to update system navigation bar style based on theme\r\n  useEffect(() => {\r\n    const updateNavigationBar = async () => {\r\n      if (Platform.OS === 'android') {\r\n        const isDark = theme === 'dark';\r\n        try {\r\n          // Set the background color of the navigation bar\r\n          await NavigationBar.setBackgroundColorAsync(\r\n            isDark ? '#1a1a1a' : '#ffffff',\r\n          );\r\n          // Set the icon style (light icons on dark bg, dark icons on light bg)\r\n          await NavigationBar.setButtonStyleAsync(isDark ? 'light' : 'dark');\r\n        } catch (error) {\r\n          console.log('Failed to set navigation bar style:', error);\r\n        }\r\n      }\r\n    };\r\n\r\n    updateNavigationBar();\r\n  }, [theme]);\r\n\r\n  useEffect(() => {\r\n    if (!customColorPreference) {\r\n      dispatch(changeThemeColor(Appearance.getColorScheme()!));\r\n      const listener = (preferences: { colorScheme: ColorSchemeName }) => {\r\n        const theme = preferences.colorScheme || 'light';\r\n        dispatch(changeThemeColor(theme));\r\n      };\r\n      const subscription = Appearance.addChangeListener(listener);\r\n      return () => subscription.remove();\r\n    }\r\n  }, [dispatch, customColorPreference]);\r\n\r\n  return null;\r\n};\r\n\r\nexport default ThemeListener;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\helpers\\common\\roomCodeGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\helpers\\common\\stringHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\helpers\\firebase\\FirebaseErrorHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\helpers\\navigation\\NavigationIconHelper.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\hooks\\common\\useAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\hooks\\common\\useKeyBoardVisible.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\hooks\\common\\useTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\hooks\\redux\\useTypedDispatch.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\hooks\\redux\\useTypedSelector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\components\\AnnouncementIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\components\\FloatingBottomTabBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\components\\FloatingLexAIButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\components\\HashtagTab.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\components\\HomeIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\components\\NavigationDrawer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\components\\NavigationDrawerButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\routes\\AuthStack.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":2,"message":"React Hook useEffect has a missing dependency: 'dispatch'. Either include it or remove the dependency array.","line":30,"column":6,"nodeType":"ArrayExpression","endLine":30,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [dispatch]","fix":{"range":[1147,1149],"text":"[dispatch]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\routes\\Route.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\routes\\UserStack.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NavigationProp' is defined but never used.","line":26,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'RootStackParamList' is defined but never used.","line":42,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SafeAreaView' is defined but never used.","line":43,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":21}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Home from 'home/screens/Home';\r\nimport {createDrawerNavigator} from '@react-navigation/drawer';\r\nimport {createBottomTabNavigator} from '@react-navigation/bottom-tabs';\r\nimport NavigationDrawer from 'shared/navigation/components/NavigationDrawer';\r\nimport NavigationDrawerButton from 'shared/navigation/components/NavigationDrawerButton';\r\nimport Search from 'search-post/screens/Search';\r\nimport CreatePost from 'create-post/screens/CreatePost';\r\nimport Room from 'room/screens/Room';\r\nimport RoomScreen from 'room/screens/RoomScreen';\r\nimport Tasks from 'tasks/screens/Tasks';\r\nimport DuoTasks from 'tasks/screens/DuoTasks';\r\nimport EventsAndHackathons from 'events-and-hackathons/screens/EventsAndHackathons';\r\nimport EventDetails from 'events-and-hackathons/screens/EventDetails';\r\nimport ConversationsScreen from 'conversations/screens/Conversations';\r\nimport ChatScreen from 'conversations/screens/Chat';\r\nimport ContactListScreen from 'conversations/screens/ContactList';\r\nimport SavedPosts from 'saved-post/screens/SavedPosts';\r\nimport {BottomTabNavigationProp} from '@react-navigation/bottom-tabs';\r\nimport {useTypedSelector} from 'hooks/redux/useTypedSelector';\r\nimport NavigationIconHelper from 'shared/helpers/navigation/NavigationIconHelper';\r\nimport {Dimensions, Alert, ImageSourcePropType, StatusBar} from 'react-native';\r\nimport {useEffect, useRef, useCallback} from 'react';\r\nimport {\r\n  useNavigation,\r\n  CommonActions,\r\n  NavigationProp,\r\n} from '@react-navigation/native';\r\nimport {useTypedDispatch} from 'hooks/redux/useTypedDispatch';\r\nimport {clearDeepLink, markDeepLinkProcessed} from 'shared/reducers/DeepLink';\r\nimport {MeetingService} from 'room/services/MeetingService';\r\nimport QRCode from 'qr-code/screens/QRCode';\r\nimport {MessageService} from 'conversations/services/MessageService';\r\nimport LexAI from 'lex-ai/screens/LexAI';\r\nimport {\r\n  getFirestore,\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n} from '@react-native-firebase/firestore';\r\nimport FloatingBottomTabBar from 'shared/navigation/components/FloatingBottomTabBar';\r\nimport {getMessaging} from '@react-native-firebase/messaging';\r\nimport {RootStackParamList} from './Route';\r\nimport {SafeAreaView, useSafeAreaInsets} from 'react-native-safe-area-context';\r\n\r\nconst {width: SCREEN_WIDTH} = Dimensions.get('window');\r\n\r\n/**\r\n * Type definitions for navigation parameters\r\n * Defines the shape of navigation props for each screen\r\n */\r\nexport type UserStackParamList = {\r\n  Search: {searchText?: string};\r\n  Home: undefined;\r\n  CreatePost: undefined;\r\n  Room:\r\n    | {\r\n        meetingData?: {\r\n          id: string;\r\n          title: string;\r\n          description: string;\r\n          duration: number;\r\n          isPrivate: boolean;\r\n          maxParticipants: number;\r\n          taskId?: string;\r\n          host: string;\r\n          status: string;\r\n          participants: string[];\r\n          roomCode: string;\r\n          settings: {\r\n            muteOnEntry: boolean;\r\n            allowChat: boolean;\r\n            allowScreenShare: boolean;\r\n            recordingEnabled: boolean;\r\n          };\r\n          createdAt: Date;\r\n          updatedAt: Date;\r\n        };\r\n        joinMode?: boolean;\r\n        roomCode?: string;\r\n      }\r\n    | undefined;\r\n  RoomScreen: {\r\n    meeting: any;\r\n    isHost: boolean;\r\n  };\r\n  Tasks: undefined;\r\n  DuoTasks: undefined;\r\n  EventsAndHackathons: undefined;\r\n  EventDetails: {\r\n    id: string;\r\n    source: string;\r\n  };\r\n  LexAI: undefined;\r\n  Conversations: undefined;\r\n  Chat: {\r\n    conversationId: string;\r\n    recipientId: string;\r\n    recipientName: string;\r\n    recipientPhoto?: string | ImageSourcePropType;\r\n    isQrInitiated: boolean;\r\n  };\r\n  ContactList: undefined;\r\n  SavedPosts: undefined;\r\n  QRCode: undefined;\r\n};\r\n\r\nexport type UserNavigationProps = BottomTabNavigationProp<UserStackParamList>;\r\n\r\n/**\r\n * Parse room code from a deep link URL\r\n */\r\nconst extractRoomCodeFromUrl = (url: string): string | null => {\r\n  try {\r\n    // Handle both formats: learnex://meeting?roomCode=ABC123 or https://learnex-web.vercel.app/join/ABC123\r\n    const urlObj = new URL(url);\r\n\r\n    if (urlObj.protocol === 'learnex:') {\r\n      // Mobile deep link format\r\n      const params = new URLSearchParams(urlObj.search);\r\n      return params.get('roomCode');\r\n    } else if (urlObj.hostname.includes('learnex-web.vercel.app')) {\r\n      // Check for old query parameter format\r\n      const params = new URLSearchParams(urlObj.search);\r\n      const queryCode = params.get('code');\r\n\r\n      if (queryCode) {\r\n        return queryCode;\r\n      }\r\n\r\n      // Check for new path format: /join/ABC123\r\n      const pathParts = urlObj.pathname.split('/');\r\n      if (pathParts.length >= 3 && pathParts[1] === 'join') {\r\n        return pathParts[2];\r\n      }\r\n    }\r\n\r\n    return null;\r\n  } catch (error) {\r\n    console.error('Error parsing deep link URL:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Parse user ID from a chat deep link URL\r\n * Format: learnex://chat/{userId}\r\n */\r\nconst extractUserIdFromChatUrl = (url: string): string | null => {\r\n  try {\r\n    // Check if this is a chat deep link\r\n    if (url.startsWith('learnex://chat/')) {\r\n      // Extract the userId from the path\r\n      const userId = url.replace('learnex://chat/', '');\r\n      if (userId && userId.length > 0) {\r\n        return userId;\r\n      }\r\n    }\r\n    return null;\r\n  } catch (error) {\r\n    console.error('Error parsing chat deep link URL:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Bottom tab navigator configuration\r\n * Includes Home, Search, Create Post\r\n */\r\n\r\n// Custom tab bar component to prevent recreation on each render\r\nconst CustomTabBar = (props: any) => <FloatingBottomTabBar {...props} />;\r\n\r\nconst TabNavigator = ({isDark}: {isDark: boolean}) => {\r\n  const Tab = createBottomTabNavigator<UserStackParamList>();\r\n  const insets = useSafeAreaInsets();\r\n\r\n  return (\r\n    <Tab.Navigator\r\n      initialRouteName=\"Home\"\r\n      tabBar={CustomTabBar}\r\n      screenOptions={({route}) => ({\r\n        headerShown: false,\r\n        tabBarShowLabel: false,\r\n        style: {\r\n          marginBottom: insets.bottom,\r\n        },\r\n        tabBarStyle: {\r\n          borderWidth: 0,\r\n          borderColor: isDark ? '#2a2a2a' : '#EDECEC',\r\n          height: Math.min(SCREEN_WIDTH * 0.1375, 55),\r\n          paddingBottom: Math.min(SCREEN_WIDTH * 0.0125, 5),\r\n          marginBottom: insets.bottom,\r\n        },\r\n        // Custom tab bar icons with theme-aware colors\r\n        tabBarIcon: ({focused, color, size}) => {\r\n          return NavigationIconHelper(route, focused, size + 5, color); // Slightly reduce icon size\r\n        },\r\n        animation: 'fade',\r\n      })}>\r\n      <Tab.Screen name=\"Home\" component={Home} />\r\n      <Tab.Screen name=\"Search\" component={Search} />\r\n      <Tab.Screen name=\"CreatePost\" component={CreatePost} />\r\n    </Tab.Navigator>\r\n  );\r\n};\r\n\r\n/**\r\n * Main navigation stack for authenticated users\r\n * Combines drawer navigation with bottom tab navigation\r\n */\r\nconst UserStack = () => {\r\n  const Drawer = createDrawerNavigator();\r\n  const isDark = useTypedSelector(state => state.user.theme) === 'dark';\r\n  const deepLinkUrl = useTypedSelector(state => state.deepLink.url);\r\n  const deepLinkProcessed = useTypedSelector(state => state.deepLink.processed);\r\n  const navigation = useNavigation();\r\n  const dispatch = useTypedDispatch();\r\n  const meetingService = useRef(new MeetingService()).current;\r\n  const messageService = useRef(new MessageService()).current;\r\n  const firebase = useTypedSelector(state => state.firebase.firebase);\r\n  const messaging = getMessaging();\r\n\r\n  useEffect(() => {\r\n    StatusBar.setBarStyle(isDark ? 'light-content' : 'dark-content', true);\r\n  }, [isDark]);\r\n\r\n  const renderDrawerContent = useCallback(\r\n    (props: any) => <NavigationDrawer {...props} />,\r\n    [],\r\n  );\r\n\r\n  const renderHeader = useCallback(\r\n    ({navigation: drawerNavigation}: {navigation: any}) => (\r\n      <NavigationDrawerButton navigation={drawerNavigation} />\r\n    ),\r\n    [],\r\n  );\r\n\r\n  const renderTabNavigator = useCallback(\r\n    () => <TabNavigator isDark={isDark} />,\r\n    [isDark],\r\n  );\r\n\r\n  // Set up notification channels and handlers for direct messages and tasks\r\n  useEffect(() => {\r\n    const setupNotifications = async () => {\r\n      try {\r\n        // Import notification service\r\n        const notificationService =\r\n          require('shared/services/NotificationService').default;\r\n\r\n        // Set up notification channels (for Android)\r\n        await notificationService.setupNotificationChannels();\r\n\r\n        // Set up foreground notification handlers for navigation\r\n        notificationService.setupNotificationHandlers(navigation);\r\n\r\n        // Set up background notification handler\r\n        notificationService.setupBackgroundHandler();\r\n\r\n        // Start listening for new messages to trigger notifications\r\n        notificationService.setupMessageListener();\r\n\r\n        // Start listening for tasks to schedule notifications\r\n        notificationService.setupTaskNotificationListener();\r\n\r\n        // Initialize Firebase Cloud Messaging\r\n        const fcmInitialized = await notificationService.initializeFCM();\r\n        if (fcmInitialized) {\r\n          console.log('Firebase Cloud Messaging initialized successfully');\r\n        } else {\r\n          console.warn(\r\n            'Firebase Cloud Messaging initialization failed or permission denied',\r\n          );\r\n        }\r\n\r\n        console.log('Notification services initialized');\r\n      } catch (error) {\r\n        console.error('Failed to set up notification services:', error);\r\n      }\r\n    };\r\n\r\n    // Set up notifications when the component mounts\r\n    setupNotifications();\r\n\r\n    return () => {\r\n      // Clean up message listener when component unmounts\r\n      try {\r\n        const notificationService =\r\n          require('shared/services/NotificationService').default;\r\n        notificationService.removeMessageListener();\r\n        notificationService.removeTaskListener();\r\n        notificationService.cleanupFCM();\r\n      } catch (error) {\r\n        console.error('Failed to clean up notification listeners:', error);\r\n      }\r\n    };\r\n  }, [navigation, messaging]);\r\n\r\n  // Handle deep link navigation\r\n  useEffect(() => {\r\n    const handleDeepLink = async () => {\r\n      if (deepLinkUrl && !deepLinkProcessed) {\r\n        console.log('Processing deep link in UserStack:', deepLinkUrl);\r\n\r\n        // Mark as processed to prevent multiple attempts\r\n        dispatch(markDeepLinkProcessed());\r\n\r\n        // First, check if this is a chat deep link\r\n        const userId = extractUserIdFromChatUrl(deepLinkUrl);\r\n        if (userId) {\r\n          try {\r\n            const currentUser = firebase.currentUser();\r\n            if (!currentUser) {\r\n              throw new Error('You must be signed in to start a conversation');\r\n            }\r\n\r\n            // Get user details to show in the chat using UserService\r\n            // Getting complete user document to fetch photoURL as well\r\n            const userDoc = await getDoc(\r\n              doc(collection(getFirestore(), 'users'), userId),\r\n            );\r\n\r\n            if (!userDoc.exists()) {\r\n              throw new Error('User not found');\r\n            }\r\n\r\n            const userData =\r\n              (userDoc.data() as {\r\n                fullName?: string;\r\n                username?: string;\r\n                photoURL?: string;\r\n                profilePicture?: string;\r\n                image?: string;\r\n              }) || {};\r\n            const recipientName =\r\n              userData.fullName || userData.username || 'User';\r\n            const recipientPhoto =\r\n              userData.photoURL ||\r\n              userData.profilePicture ||\r\n              userData.image ||\r\n              null;\r\n\r\n            console.log('Starting chat with user:', {\r\n              recipientName,\r\n              recipientPhoto,\r\n            });\r\n\r\n            // Create or get a conversation between the two users\r\n            const conversation = await messageService.getOrCreateConversation(\r\n              currentUser.uid,\r\n              userId,\r\n            );\r\n\r\n            // Set a flag in AsyncStorage to mark this as a QR-initiated conversation\r\n            try {\r\n              const AsyncStorage =\r\n                require('@react-native-async-storage/async-storage').default;\r\n              await AsyncStorage.setItem(\r\n                `qr_conversation_${conversation.id}`,\r\n                'true',\r\n              );\r\n              console.log(\r\n                'Marked conversation as QR-initiated:',\r\n                conversation.id,\r\n              );\r\n            } catch (storageError) {\r\n              console.error('Failed to mark QR conversation:', storageError);\r\n              // Continue even if storage fails\r\n            }\r\n\r\n            // Navigate to the chat screen\r\n            navigation.dispatch(\r\n              CommonActions.navigate({\r\n                name: 'Chat',\r\n                params: {\r\n                  conversationId: conversation.id,\r\n                  recipientId: userId,\r\n                  recipientName,\r\n                  recipientPhoto,\r\n                  isQrInitiated: true, // Pass QR flag to chat screen\r\n                },\r\n              }),\r\n            );\r\n\r\n            // Clear the deep link after successful navigation\r\n            setTimeout(() => {\r\n              dispatch(clearDeepLink());\r\n            }, 2000);\r\n\r\n            return; // Exit after handling chat link\r\n          } catch (error) {\r\n            console.error('Error processing chat deep link:', error);\r\n            Alert.alert(\r\n              'Error',\r\n              error instanceof Error\r\n                ? error.message\r\n                : 'Unable to start conversation',\r\n            );\r\n            dispatch(clearDeepLink());\r\n            return; // Exit after handling error\r\n          }\r\n        }\r\n\r\n        // If not a chat link, check if it's a meeting link\r\n        const roomCode = extractRoomCodeFromUrl(deepLinkUrl);\r\n        if (roomCode) {\r\n          try {\r\n            // Get meeting by room code\r\n            const meeting = await meetingService.getMeetingByRoomCode(roomCode);\r\n            console.log(navigation.getState()?.routeNames);\r\n            console.log(navigation.getState()?.index);\r\n\r\n            // Navigate to RoomScreen\r\n            navigation.dispatch(\r\n              CommonActions.navigate({\r\n                name: 'UserStack',\r\n                params: {\r\n                  screen: 'RoomScreen',\r\n                  params: {\r\n                    meeting,\r\n                    isHost: false,\r\n                  },\r\n                },\r\n              }),\r\n            );\r\n\r\n            // Clear the deep link after successful navigation\r\n            setTimeout(() => {\r\n              dispatch(clearDeepLink());\r\n            }, 2000);\r\n          } catch (error) {\r\n            console.error('Error processing meeting deep link:', error);\r\n            Alert.alert(\r\n              'Error',\r\n              error instanceof Error ? error.message : 'Unable to join meeting',\r\n            );\r\n            dispatch(clearDeepLink());\r\n          }\r\n        }\r\n\r\n        if (deepLinkUrl === 'learnex://callback') {\r\n          navigation.navigate('UserStack');\r\n        }\r\n      }\r\n    };\r\n\r\n    handleDeepLink();\r\n  }, [\r\n    deepLinkUrl,\r\n    deepLinkProcessed,\r\n    dispatch,\r\n    navigation,\r\n    messageService,\r\n    meetingService,\r\n    firebase,\r\n  ]);\r\n\r\n  return (\r\n    <Drawer.Navigator\r\n      initialRouteName=\"Tabs\"\r\n      drawerContent={renderDrawerContent}\r\n      screenOptions={{\r\n        headerShown: false, // Hide header for all screens by default\r\n        drawerStyle: {\r\n          backgroundColor: isDark ? '#1a1a1a' : 'white',\r\n          width: Math.min(SCREEN_WIDTH * 0.85, 400),\r\n        },\r\n      }}>\r\n      <Drawer.Screen\r\n        name=\"Tabs\"\r\n        component={renderTabNavigator}\r\n        options={{\r\n          headerShown: true, // Show header only for the main tabs\r\n          header: renderHeader,\r\n          lazy: true,\r\n        }}\r\n      />\r\n      <Drawer.Screen\r\n        name=\"Room\"\r\n        component={Room}\r\n        options={{\r\n          headerShown: false, // Hide header for Room screen\r\n          swipeEnabled: false, // Disable drawer swipe for this screen\r\n          drawerItemStyle: {display: 'none'}, // Hide from drawer if needed\r\n        }}\r\n      />\r\n      <Drawer.Screen\r\n        name=\"RoomScreen\"\r\n        component={RoomScreen}\r\n        options={{\r\n          headerShown: false, // Hide header for RoomScreen\r\n          swipeEnabled: false, // Disable drawer swipe for this screen\r\n          drawerItemStyle: {display: 'none'}, // Hide from drawer\r\n        }}\r\n      />\r\n      <Drawer.Screen\r\n        name=\"Tasks\"\r\n        component={Tasks}\r\n        options={{\r\n          headerShown: false, // Hide header for Tasks screen\r\n          swipeEnabled: false, // Disable drawer swipe for this screen\r\n          drawerItemStyle: {display: 'none'}, // Hide from drawer if needed\r\n        }}\r\n      />\r\n      <Drawer.Screen\r\n        name=\"EventsAndHackathons\"\r\n        component={EventsAndHackathons}\r\n        options={{\r\n          headerShown: false, // Hide header for Events and Hackathons screen\r\n          swipeEnabled: false, // Disable drawer swipe for this screen\r\n          drawerItemStyle: {display: 'none'}, // Hide from drawer if needed\r\n        }}\r\n      />\r\n      <Drawer.Screen\r\n        name=\"EventDetails\"\r\n        component={EventDetails}\r\n        options={{\r\n          headerShown: false, // Hide header for Event Details screen\r\n          swipeEnabled: false, // Disable drawer swipe for this screen\r\n          drawerItemStyle: {display: 'none'}, // Hide from drawer if needed\r\n        }}\r\n      />\r\n      <Drawer.Screen\r\n        name=\"Conversations\"\r\n        component={ConversationsScreen}\r\n        options={{\r\n          headerShown: false, // Hide header for Conversations screen\r\n          swipeEnabled: false, // Disable drawer swipe for this screen\r\n        }}\r\n      />\r\n      <Drawer.Screen\r\n        name=\"Chat\"\r\n        component={ChatScreen}\r\n        options={{\r\n          headerShown: true, // Changed from false to true to show the header\r\n          swipeEnabled: false, // Disable drawer swipe for this screen\r\n          drawerItemStyle: {display: 'none'}, // Hide from drawer\r\n        }}\r\n      />\r\n      <Drawer.Screen\r\n        name=\"ContactList\"\r\n        component={ContactListScreen}\r\n        options={{\r\n          headerShown: false, // Hide header for Contact List screen\r\n          swipeEnabled: false, // Disable drawer swipe for this screen\r\n          drawerItemStyle: {display: 'none'}, // Hide from drawer\r\n        }}\r\n      />\r\n      <Drawer.Screen\r\n        name=\"QRCode\"\r\n        component={QRCode}\r\n        options={{\r\n          headerShown: false, // Hide header for Saved Posts screen\r\n          swipeEnabled: false, // Disable drawer swipe for this screen\r\n          drawerItemStyle: {display: 'none'}, // Hide from drawer\r\n        }}\r\n      />\r\n      <Drawer.Screen\r\n        name=\"SavedPosts\"\r\n        component={SavedPosts}\r\n        options={{\r\n          headerShown: false, // Hide header for Saved Posts screen\r\n          swipeEnabled: false, // Disable drawer swipe for this screen\r\n          drawerItemStyle: {display: 'none'}, // Hide from drawer\r\n        }}\r\n      />\r\n      <Drawer.Screen\r\n        name=\"LexAI\"\r\n        component={LexAI}\r\n        options={{\r\n          headerShown: false, // Hide header for LexAI screen\r\n          drawerItemStyle: {display: 'none',backgroundColor: 'black'}, // Hide from drawer\r\n        }}\r\n      />\r\n      <Drawer.Screen\r\n        name=\"DuoTasks\"\r\n        component={DuoTasks}\r\n        options={{\r\n          headerShown: false, // Hide header for LexAI screen\r\n          drawerItemStyle: {display: 'none'}, // Hide from drawer\r\n        }}\r\n      />\r\n    </Drawer.Navigator>\r\n  );\r\n};\r\n\r\nexport default UserStack;\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\styles\\HashtagTab.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\styles\\HomeIcon.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\styles\\NavigationDrawer.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\navigation\\styles\\NavigationDrawerButton.styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\reducers\\DeepLink.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\reducers\\Firebase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\reducers\\Hackathon.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\reducers\\User.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\reducers\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\reducers\\rootReducer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\res\\strings\\eng.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\AuthService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\DeepLinkHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\FirebaseService.ts","messages":[{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 20 column 3.","line":214,"column":13,"nodeType":"Identifier","messageId":"noShadow","endLine":214,"endColumn":16},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 20 column 3.","line":372,"column":33,"nodeType":"Identifier","messageId":"noShadow","endLine":372,"endColumn":36},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 20 column 3.","line":642,"column":37,"nodeType":"Identifier","messageId":"noShadow","endLine":642,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  statusCodes,\r\n  GoogleSignin,\r\n} from '@react-native-google-signin/google-signin';\r\nimport Config from 'react-native-config';\r\nimport {authorize, AuthConfiguration} from 'react-native-app-auth';\r\nimport {signUpData} from 'shared/types/authTypes';\r\nimport {PostType} from 'shared/types/post';\r\nimport {\r\n  arrayRemove,\r\n  arrayUnion,\r\n  getDocs,\r\n  increment,\r\n  limit,\r\n  limitToLast,\r\n  orderBy,\r\n  serverTimestamp,\r\n  getFirestore,\r\n  collection,\r\n  doc,\r\n  addDoc,\r\n  getDoc,\r\n  updateDoc,\r\n  setDoc,\r\n  query,\r\n  where,\r\n  runTransaction,\r\n  writeBatch,\r\n} from '@react-native-firebase/firestore';\r\nimport {\r\n  createUserWithEmailAndPassword,\r\n  FirebaseAuthTypes,\r\n  getAuth,\r\n  GithubAuthProvider,\r\n  GoogleAuthProvider,\r\n  sendPasswordResetEmail,\r\n  signInWithCredential,\r\n  signInWithEmailAndPassword,\r\n  signOut,\r\n} from '@react-native-firebase/auth';\r\n\r\ninterface GetPostsResponse {\r\n  success: boolean;\r\n  posts?: PostType[];\r\n  error?: string;\r\n}\r\n\r\n// Auth Module\r\nclass AuthModule {\r\n  constructor() {\r\n    GoogleSignin.configure({\r\n      webClientId:\r\n        '378245937295-p9lvf9tenrtchg6d2t5g6tamlhm5a168.apps.googleusercontent.com',\r\n    });\r\n  }\r\n\r\n  currentUser(): FirebaseAuthTypes.User | null {\r\n    return getAuth().currentUser;\r\n  }\r\n\r\n  async signUpWithEmailAndPassword({\r\n    email,\r\n    username,\r\n    fullName,\r\n    password,\r\n  }: signUpData) {\r\n    try {\r\n      const data = {email, username, fullName, isLoggedIn: true};\r\n      await createUserWithEmailAndPassword(getAuth(), email, password);\r\n      await addDoc(collection(getFirestore(), 'users'), data);\r\n      return {success: true};\r\n    } catch (error: any) {\r\n      console.log('AuthModule :: signUpWithEmailAndPassword() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n\r\n  async loginWithEmailAndPassword(email: string, password: string) {\r\n    try {\r\n      await signInWithEmailAndPassword(getAuth(), email, password);\r\n      return {success: true};\r\n    } catch (error: any) {\r\n      console.log('AuthModule :: loginWithEmailAndPassword() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n\r\n  async sendPasswordResetEmail(email: string) {\r\n    try {\r\n      await sendPasswordResetEmail(getAuth(), email);\r\n      return {success: true};\r\n    } catch (error) {\r\n      console.log('AuthModule :: sendPasswordResetEmail() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n\r\n  async signOut() {\r\n    try {\r\n      await signOut(getAuth());\r\n      return {success: true};\r\n    } catch (error: any) {\r\n      console.log('AuthModule :: signOut() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n\r\n  async googleSignIn() {\r\n    try {\r\n      await GoogleSignin.hasPlayServices({showPlayServicesUpdateDialog: true});\r\n      await GoogleSignin.signIn();\r\n      const {accessToken} = await GoogleSignin.getTokens();\r\n\r\n      if (!accessToken) {\r\n        throw new Error('No access token found');\r\n      }\r\n\r\n      // Create a Google credential with the token\r\n      const googleCredential = GoogleAuthProvider.credential(null, accessToken);\r\n      await signInWithCredential(getAuth(), googleCredential);\r\n\r\n      // Create user document if it doesn't exist\r\n      const user = getAuth().currentUser;\r\n      if (user) {\r\n        const userDoc = await getDoc(doc(getFirestore(), 'users', user.uid));\r\n        if (!userDoc.exists()) {\r\n          await setDoc(doc(getFirestore(), 'users', user.uid), {\r\n            email: user.email,\r\n            username: user.displayName || user.email?.split('@')[0] || 'User',\r\n            fullName: user.displayName || 'User',\r\n            isLoggedIn: true,\r\n            savedPosts: [],\r\n            createdAt: serverTimestamp(),\r\n\r\n            image:\r\n              user.photoURL ||\r\n              'https://www.gravatar.com/avatar/' +\r\n                Math.random().toString(36).substring(7),\r\n          });\r\n        }\r\n      }\r\n\r\n      return {success: true};\r\n    } catch (error: any) {\r\n      if (error.code === statusCodes.SIGN_IN_CANCELLED) {\r\n        return {success: false, error: 'Sign in cancelled'};\r\n      } else if (error.code === statusCodes.IN_PROGRESS) {\r\n        return {success: false, error: 'Sign in already in progress'};\r\n      } else if (error.code === statusCodes.PLAY_SERVICES_NOT_AVAILABLE) {\r\n        return {success: false, error: 'Play services not available'};\r\n      }\r\n      console.log('AuthModule :: googleSignIn() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n\r\n  async githubSignIn() {\r\n    try {\r\n      const config: AuthConfiguration = {\r\n        issuer: 'https://github.com',\r\n        clientId: Config.GITHUB_CLIENT_ID!,\r\n        clientSecret: Config.GITHUB_CLIENT_SECRET,\r\n        redirectUrl: 'learnex://callback',\r\n        scopes: ['user:email'],\r\n        serviceConfiguration: {\r\n          authorizationEndpoint: 'https://github.com/login/oauth/authorize',\r\n          tokenEndpoint: 'https://github.com/login/oauth/access_token',\r\n        },\r\n      };\r\n      const authState = await authorize(config);\r\n      const githubCredential = GithubAuthProvider.credential(\r\n        authState.accessToken,\r\n      );\r\n      await signInWithCredential(getAuth(), githubCredential);\r\n\r\n      // Create user document if it doesn't exist\r\n      const user = getAuth().currentUser;\r\n      if (user) {\r\n        const userDoc = await getDoc(doc(getFirestore(), 'users', user.uid));\r\n        if (!userDoc.exists()) {\r\n          await setDoc(doc(getFirestore(), 'users', user.uid), {\r\n            email: user.email,\r\n            username:\r\n              user.displayName || user.email?.split('@')[0] || 'GitHub User',\r\n            fullName: user.displayName || 'GitHub User',\r\n            isLoggedIn: true,\r\n            savedPosts: [],\r\n            createdAt: serverTimestamp(),\r\n\r\n            image:\r\n              user.photoURL ||\r\n              'https://www.gravatar.com/avatar/' +\r\n                Math.random().toString(36).substring(7),\r\n          });\r\n        }\r\n      }\r\n\r\n      return {success: true};\r\n    } catch (error) {\r\n      console.log('AuthModule :: githubSignIn() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n\r\n  isUserLoggedIn(): boolean {\r\n    return getAuth().currentUser != null;\r\n  }\r\n}\r\n\r\n// User Module\r\nclass UserModule {\r\n  async getNameUsernamestring(): Promise<{fullName: string; username: string}> {\r\n    try {\r\n      const doc = (\r\n        await getDocs(\r\n          query(\r\n            collection(getFirestore(), 'users'),\r\n            where('email', '==', getAuth().currentUser?.email),\r\n          ),\r\n        )\r\n      ).docs[0].data();\r\n      return {fullName: doc.fullName, username: doc.username};\r\n    } catch (error) {\r\n      console.log('UserModule :: getNameUsernamestring() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async checkUsernameIsAvailable(username: string) {\r\n    try {\r\n      const user = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'users'),\r\n          where('username', '==', username),\r\n        ),\r\n      );\r\n      return {success: user.empty};\r\n    } catch (error) {\r\n      console.log('UserModule :: checkUsernameIsAvailable() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n\r\n  async checkEmailIsAvailable(email: string) {\r\n    try {\r\n      const user = await getDocs(\r\n        query(collection(getFirestore(), 'users'), where('email', '==', email)),\r\n      );\r\n      return {success: user.empty};\r\n    } catch (error) {\r\n      console.log('UserModule :: checkEmailIsAvailable() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n\r\n  async checkUsernameOrEmailRegistered(emailOrUsername: string) {\r\n    try {\r\n      const email = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'users'),\r\n          where('email', '==', emailOrUsername),\r\n        ),\r\n      );\r\n      const username = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'users'),\r\n          where('username', '==', emailOrUsername),\r\n        ),\r\n      );\r\n\r\n      if (!email.empty) return {success: true, email: emailOrUsername};\r\n\r\n      if (!username.empty) {\r\n        const emailValue = username.docs[0].data().email;\r\n        return {success: true, email: emailValue};\r\n      }\r\n\r\n      return {success: false};\r\n    } catch (error: any) {\r\n      console.log('UserModule :: checkUsernameOrEmailRegistered() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n}\r\n\r\n// Posts Module\r\nclass PostsModule {\r\n  // Helper function to format timestamps\r\n  private formatTimestamp(date: Date): string {\r\n    const now = new Date();\r\n    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);\r\n\r\n    if (diffInSeconds < 60) {\r\n      return `${diffInSeconds}s ago`;\r\n    } else if (diffInSeconds < 3600) {\r\n      const minutes = Math.floor(diffInSeconds / 60);\r\n      return `${minutes}m ago`;\r\n    } else if (diffInSeconds < 86400) {\r\n      const hours = Math.floor(diffInSeconds / 3600);\r\n      return `${hours}h ago`;\r\n    } else if (diffInSeconds < 604800) {\r\n      const days = Math.floor(diffInSeconds / 86400);\r\n      return `${days}d ago`;\r\n    } else if (diffInSeconds < 2419200) {\r\n      const weeks = Math.floor(diffInSeconds / 604800);\r\n      return `${weeks}w ago`;\r\n    } else {\r\n      return date.toLocaleDateString('en-US', {\r\n        day: 'numeric',\r\n        month: 'short',\r\n        year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined,\r\n      });\r\n    }\r\n  }\r\n\r\n  async createPost(postData: {\r\n    description: string;\r\n    postImages?: string[];\r\n    postVideo?: string;\r\n    isVideo?: boolean;\r\n  }) {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) throw new Error('User not authenticated');\r\n\r\n      const userModule = new UserModule();\r\n      const {fullName: username} = await userModule.getNameUsernamestring();\r\n\r\n      const postRef = collection(getFirestore(), 'posts');\r\n      const newPost = {\r\n        user: {\r\n          id: currentUser.uid,\r\n          username,\r\n          image: currentUser.photoURL || '',\r\n        },\r\n        ...postData,\r\n        likes: 0,\r\n        comments: 0,\r\n        createdAt: serverTimestamp(),\r\n      };\r\n\r\n      const docRef = await addDoc(postRef, newPost);\r\n      return {success: true, postId: docRef.id};\r\n    } catch (error) {\r\n      console.log('PostsModule :: createPost() ::', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Failed to create post',\r\n      };\r\n    }\r\n  }\r\n\r\n  async getPosts(limitNum = 10): Promise<GetPostsResponse> {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      const postsRef = collection(getFirestore(), 'posts');\r\n\r\n      let snapshot;\r\n      try {\r\n        snapshot = await getDocs(\r\n          query(postsRef, orderBy('createdAt', 'desc'), limit(limitNum)),\r\n        );\r\n      } catch (orderByError) {\r\n        console.log(\r\n          'Error with orderBy, fetching without sorting:',\r\n          orderByError,\r\n        );\r\n        snapshot = await getDocs(query(postsRef, limit(limitNum)));\r\n      }\r\n\r\n      const postsWithLikes = await Promise.all(\r\n        snapshot.docs.map(async doc => {\r\n          const data = doc.data();\r\n          // Check if current user has liked this post\r\n          const isLiked = currentUser\r\n            ? await this.isPostLikedByUser(doc.id)\r\n            : false;\r\n\r\n          // Get comments with their like status\r\n          const commentsSnapshot = await getDocs(\r\n            query(\r\n              collection(doc.ref, 'comments'),\r\n              orderBy('createdAt', 'desc'),\r\n              limitToLast(5),\r\n            ),\r\n          );\r\n\r\n          const comments = commentsSnapshot.docs.map(commentDoc => {\r\n            const commentData = commentDoc.data();\r\n            return {\r\n              id: commentDoc.id,\r\n              userId: commentData.userId,\r\n              username: commentData.username,\r\n              userImage: commentData.userImage,\r\n              text: commentData.text,\r\n              likes: commentData.likes || 0,\r\n              timestamp: this.formatTimestamp(\r\n                commentData.createdAt?.toDate() || new Date(),\r\n              ),\r\n              isLiked: false, // You can implement comment likes similarly if needed\r\n            };\r\n          });\r\n\r\n          return {\r\n            id: doc.id,\r\n            user: {\r\n              id: data.user.id,\r\n              username: data.user.username,\r\n              image: data.user.image,\r\n            },\r\n            description: data.description || '',\r\n            likes: data.likes || 0,\r\n            comments: data.comments || 0,\r\n            timestamp: this.formatTimestamp(\r\n              data.createdAt?.toDate() || new Date(),\r\n            ),\r\n            postImages: data.postImages || [],\r\n            postVideo: data.postVideo,\r\n            isVideo: data.isVideo,\r\n            commentsList: comments,\r\n            isLiked, // Include the like status\r\n          };\r\n        }),\r\n      );\r\n\r\n      return {success: true, posts: postsWithLikes};\r\n    } catch (error) {\r\n      console.error('PostsModule :: getPosts() ::', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Failed to fetch posts',\r\n      };\r\n    }\r\n  }\r\n\r\n  async isPostLikedByUser(postId: string): Promise<boolean> {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) return false;\r\n\r\n      const likeDoc = await getDoc(\r\n        doc(getFirestore(), 'likes', `${postId}_${currentUser.uid}`),\r\n      );\r\n\r\n      return likeDoc.exists();\r\n    } catch (error) {\r\n      console.error('Error checking if post is liked:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async likePost(postId: string) {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) throw new Error('User not authenticated');\r\n\r\n      const postRef = doc(getFirestore(), 'posts', postId);\r\n      const likeDocRef = doc(\r\n        getFirestore(),\r\n        'likes',\r\n        `${postId}_${currentUser.uid}`,\r\n      );\r\n\r\n      await runTransaction(getFirestore(), async transaction => {\r\n        const likeDoc = await transaction.get(likeDocRef);\r\n        if (likeDoc.exists()) {\r\n          transaction.delete(likeDocRef);\r\n          transaction.update(postRef, {\r\n            likes: increment(-1),\r\n          });\r\n        } else {\r\n          transaction.set(likeDocRef, {\r\n            userId: currentUser.uid,\r\n            postId,\r\n            createdAt: serverTimestamp(),\r\n          });\r\n          transaction.update(postRef, {\r\n            likes: increment(1),\r\n          });\r\n        }\r\n      });\r\n\r\n      // Determine new status after transaction\r\n      const updatedLikeDoc = await likeDocRef.get();\r\n      return {success: true, liked: updatedLikeDoc.exists};\r\n    } catch (error) {\r\n      console.log('PostsModule :: likePost() ::', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Failed to toggle like',\r\n      };\r\n    }\r\n  }\r\n\r\n  async addComment(postId: string, comment: string) {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) throw new Error('User not authenticated');\r\n\r\n      const userModule = new UserModule();\r\n      const {fullName: username} = await userModule.getNameUsernamestring();\r\n\r\n      // Create a batch to ensure atomic operations\r\n      const batch = writeBatch(getFirestore());\r\n\r\n      // Get post reference\r\n      const postRef = doc(getFirestore(), 'posts', postId);\r\n\r\n      // Get post data first to verify it exists\r\n      const postDoc = await getDoc(postRef);\r\n      if (postDoc.exists()) {\r\n        throw new Error('Post not found');\r\n      }\r\n\r\n      // Create a direct comments collection in the post document\r\n      const commentRef = doc(collection(postRef, 'comments'));\r\n\r\n      // Get current timestamp\r\n      const timestamp = serverTimestamp();\r\n\r\n      // Create the comment data\r\n      const newComment = {\r\n        postId,\r\n        userId: currentUser.uid,\r\n        username,\r\n        userImage: currentUser.photoURL || '',\r\n        text: comment,\r\n        likes: 0,\r\n        likedBy: [],\r\n        timestamp,\r\n        createdAt: timestamp,\r\n      };\r\n\r\n      // Add comment to the batch\r\n      batch.set(commentRef, newComment);\r\n\r\n      // Increment comment count in post\r\n      batch.update(postRef, {\r\n        comments: increment(1),\r\n      });\r\n\r\n      // Commit the batch\r\n      await batch.commit();\r\n\r\n      // Construct the comment object to return for immediate UI update\r\n      return {\r\n        success: true,\r\n        comment: {\r\n          id: commentRef.id,\r\n          userId: currentUser.uid,\r\n          username,\r\n          userImage: currentUser.photoURL || '',\r\n          text: comment,\r\n          likes: 0,\r\n          timestamp: new Date().toISOString(),\r\n          isLiked: false,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      console.log('PostsModule :: addComment() ::', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Failed to add comment',\r\n      };\r\n    }\r\n  }\r\n\r\n  async savePost(postId: string) {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) {\r\n        return {success: false, error: 'User not authenticated'};\r\n      }\r\n\r\n      // Check if post exists\r\n      const postDoc = await getDoc(doc(getFirestore(), 'posts', postId));\r\n      if (!postDoc.exists()) {\r\n        return {success: false, error: 'Post not found'};\r\n      }\r\n\r\n      // Get user document\r\n      const userDoc = await getDoc(\r\n        doc(getFirestore(), 'users', currentUser.uid),\r\n      );\r\n\r\n      // If user document doesn't exist, create it with savedPosts field\r\n      if (!userDoc.exists()) {\r\n        await setDoc(doc(getFirestore(), 'users', currentUser.uid), {\r\n          savedPosts: [postId],\r\n          updatedAt: serverTimestamp(),\r\n        });\r\n        return {success: true, saved: true};\r\n      }\r\n\r\n      // Check if post is already saved\r\n      const userData = userDoc.data();\r\n      const savedPosts = userData?.savedPosts || [];\r\n      const isSaved = savedPosts.includes(postId);\r\n\r\n      // Toggle saved status\r\n      await updateDoc(doc(getFirestore(), 'users', currentUser.uid), {\r\n        savedPosts: isSaved ? arrayRemove(postId) : arrayUnion(postId),\r\n        updatedAt: serverTimestamp(),\r\n      });\r\n\r\n      return {success: true, saved: !isSaved};\r\n    } catch (error) {\r\n      console.log('PostsModule :: savePost() ::', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Failed to save post',\r\n      };\r\n    }\r\n  }\r\n\r\n  async deletePost(postId: string) {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) {\r\n        return {success: false, error: 'User not authenticated'};\r\n      }\r\n\r\n      // Get the post to check ownership\r\n      const postRef = doc(getFirestore(), 'posts', postId);\r\n      const postDoc = await getDoc(postRef);\r\n\r\n      if (!postDoc.exists()) {\r\n        return {success: false, error: 'Post not found'};\r\n      }\r\n\r\n      // Verify that the current user is the creator of the post\r\n      const postData = postDoc.data();\r\n      if (postData?.user?.id !== currentUser.uid) {\r\n        return {success: false, error: 'Not authorized to delete this post'};\r\n      }\r\n\r\n      // Create a batch to delete the post and all its associated data\r\n      const batch = writeBatch(getFirestore());\r\n\r\n      // 1. Delete all comments\r\n      const commentsSnapshot = await getDocs(collection(postRef, 'comments'));\r\n      commentsSnapshot.docs.forEach(doc => {\r\n        batch.delete(doc.ref);\r\n      });\r\n\r\n      // 2. Delete the post itself\r\n      batch.delete(postRef);\r\n\r\n      // 3. Commit the batch\r\n      await batch.commit();\r\n\r\n      return {success: true};\r\n    } catch (error) {\r\n      console.log('PostsModule :: deletePost() ::', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Failed to delete post',\r\n      };\r\n    }\r\n  }\r\n\r\n  isPostSaved(): boolean {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) return false;\r\n\r\n      // This is a synchronous check, so we need to have the data already cached\r\n      // Return false if we're not sure, the UI will update once the actual status is fetched\r\n      return false;\r\n    } catch (error) {\r\n      console.error('Error checking saved status:', error);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n// Main Firebase Service Class\r\nclass Firebase {\r\n  auth: AuthModule;\r\n  user: UserModule;\r\n  posts: PostsModule;\r\n\r\n  constructor() {\r\n    this.auth = new AuthModule();\r\n    this.user = new UserModule();\r\n    this.posts = new PostsModule();\r\n  }\r\n\r\n  currentUser(): FirebaseAuthTypes.User | null {\r\n    return this.auth.currentUser();\r\n  }\r\n}\r\n\r\nexport default Firebase;","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\LexAIService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Appearance' is defined but never used.","line":3,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useDispatch' is defined but never used.","line":29,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useTypedDispatch' is defined but never used.","line":30,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'normalizedScreenName' is assigned a value but never used.","line":791,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":791,"endColumn":35},{"ruleId":"no-script-url","severity":1,"message":"Script URL is a form of eval.","line":1834,"column":33,"nodeType":"Literal","messageId":"unexpectedScriptURL","endLine":1834,"endColumn":46}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\r\nimport Config from 'react-native-config';\r\nimport {Appearance, Linking} from 'react-native';\r\nimport {DeepLinkHandler} from 'shared/services/DeepLinkHandler';\r\nimport {\r\n  LexAIMessage,\r\n  LexAIConversation,\r\n  LexAIResponse,\r\n  LexAITool,\r\n  LexAIToolCall,\r\n  WebSearchResult,\r\n  LexAIPersonality,\r\n  LexAIMode,\r\n  PERSONALITIES,\r\n} from 'lex-ai/types/lexAITypes';\r\nimport {TaskService} from 'shared/services/TaskService';\r\nimport LexAIFirestoreService from 'lex-ai/services/LexAIFirestoreService';\r\nimport {Task} from 'shared/types/taskTypes';\r\nimport {Message} from 'conversations/models/Message';\r\nimport {getAuth} from '@react-native-firebase/auth';\r\nimport {\r\n  getFirestore,\r\n  collection,\r\n  query,\r\n  where,\r\n  limit,\r\n  getDocs,\r\n} from '@react-native-firebase/firestore';\r\nimport {useDispatch} from 'react-redux';\r\nimport {useTypedDispatch} from '../hooks/redux/useTypedDispatch';\r\nconst generateUUID = (): string => {\r\n  // Use a timestamp-based prefix to ensure uniqueness\r\n  const timestamp = Date.now().toString(36);\r\n\r\n  // Generate random segments\r\n  const randomSegment1 = Math.random().toString(36).substring(2, 15);\r\n  const randomSegment2 = Math.random().toString(36).substring(2, 15);\r\n\r\n  // Combine timestamp and random segments to form a UUID-like string\r\n  return `${timestamp}-${randomSegment1}-${randomSegment2}`;\r\n};\r\n\r\n/**\r\n * LexAI Service - Handles communication with Gemini API and implements agentic capabilities\r\n */\r\nclass LexAIService {\r\n  private API_KEY = Config.GROQ_API_KEY;\r\n  private API_URL = 'https://api.groq.com/openai/v1/chat/completions';\r\n  private taskService: TaskService;\r\n  private systemPrompt: string;\r\n  private availableTools: LexAITool[];\r\n  // Use a safe default if PERSONALITIES is undefined\r\n  private personality: LexAIPersonality = PERSONALITIES?.FRIENDLY_COMPANION || {\r\n    id: 'friendly_companion',\r\n    name: 'Friendly Companion',\r\n    traits: ['casual', 'conversational', 'humorous'],\r\n    description:\r\n      'Uses a casual tone with occasional humor, making learning feel like talking with a friend.',\r\n  };\r\n  private mode: LexAIMode = LexAIMode.AGENT;\r\n\r\n  constructor() {\r\n    this.taskService = new TaskService();\r\n    this.systemPrompt = this.generateSystemPrompt();\r\n    this.availableTools = this.defineTools();\r\n  }\r\n\r\n  /**\r\n   * Define the available tools for LexAI\r\n   */\r\n  private defineTools(): LexAITool[] {\r\n    return [\r\n      {\r\n        name: 'navigate',\r\n        description:\r\n          'Navigate to a specific screen in the application. Use this function call when a user asks to navigate, go to a screen, or open a section of the app. Valid screen names are: \"Home\", \"Search\", \"CreatePost\" (these are in the Tab Navigator), \"Tasks\", \"Room\",\"EventsAndHackathons\", \"Conversations\", \"ContactList\", \"SavedPosts\", \"QRCode\". For \"Home\", \"Search\", and \"CreatePost\" screens, they need special navigation via \"Tabs\" navigator.',\r\n        parameters: {\r\n          screenName: 'string - The name of the screen to navigate to',\r\n          params: 'object - Optional parameters to pass to the screen',\r\n        },\r\n      },\r\n      {\r\n        name: 'searchPosts',\r\n        description:\r\n          'Search for posts using a keyword or phrase. Use this function call when user wants to find posts or content within the app.',\r\n        parameters: {\r\n          query: 'string - The search term to look for in posts',\r\n        },\r\n      },\r\n      {\r\n        name: 'getTasks',\r\n        description:\r\n          'Get all tasks for the current user. Use this function call when the user asks to see their tasks, to-dos, or reminders. If the user specifically asks for team tasks, use getTeamTasks instead.',\r\n        parameters: {},\r\n      },\r\n      {\r\n        name: 'getTeamTasks',\r\n        description:\r\n          'Get all team/duo tasks for the current user. Use this function call when the user asks about their team tasks, collaborative tasks, or shared to-dos specifically. This returns tasks that are shared with collaborators.',\r\n        parameters: {},\r\n      },\r\n      {\r\n        name: 'addTask',\r\n        description:\r\n          \"Add a new task to the user's task list. Use this function call IMMEDIATELY when a user mentions adding a task, creating a reminder, setting up a to-do, or using phrases like 'remind me', even if only the title is provided. Default values will be used for missing parameters. If you detect any intent to create a task, use this function call right away without asking for confirmation.\",\r\n        parameters: {\r\n          title: 'string - The title of the task',\r\n          description: 'string - Optional description of the task',\r\n          dueDate: 'string - Due date in YYYY-MM-DD format',\r\n          dueTime: 'string - Due time in HH:MM format (24-hour)',\r\n          priority: 'string - Priority level: \"low\", \"medium\", or \"high\"',\r\n          category: 'string - Category of the task',\r\n          notify: 'boolean - Whether to send a notification for this task',\r\n        },\r\n      },\r\n      {\r\n        name: 'toggleTheme',\r\n        description:\r\n          'Toggle between light and dark themes in the application. Use this function call when a user requests to switch themes, change appearance, or mentions light/dark mode.',\r\n        parameters: {},\r\n      },\r\n      {\r\n        name: 'addTeamTask',\r\n        description:\r\n          \"Add a new team task that will be shared with collaborators. Use this function call IMMEDIATELY when a user mentions adding a team task, collaborative task, shared to-do, or phrases like 'create a task for our team'. The system will handle finding and adding the collaborator. Default values will be used for missing parameters.\",\r\n        parameters: {\r\n          title: 'string - The title of the team task',\r\n          description: 'string - Optional description of the team task',\r\n          collaboratorEmail:\r\n            'string - Email of the collaborator to add to this task',\r\n          dueDate: 'string - Due date in YYYY-MM-DD format',\r\n          dueTime: 'string - Due time in HH:MM format (24-hour)',\r\n          priority: 'string - Priority level: \"low\", \"medium\", or \"high\"',\r\n          category: 'string - Category of the task',\r\n          notify: 'boolean - Whether to send a notification for this task',\r\n        },\r\n      },\r\n      {\r\n        name: 'updateTask',\r\n        description:\r\n          'Update an existing task. Use this function call IMMEDIATELY when user wants to modify, change, update, edit, or alter a task. Extract the task name from their request and pass it as the taskName parameter, along with any fields they want to change. DO NOT ask for confirmation first - make your best guess about which task they want to modify and call this function right away. For example, if user says \"make it due tomorrow\" after discussing a task, call this function with that task name and the updated due date.',\r\n        parameters: {\r\n          taskName: 'string - The name of the task to update',\r\n          title: 'string - Optional new title',\r\n          description: 'string - Optional new description',\r\n          dueDate: 'string - Optional new due date (YYYY-MM-DD)',\r\n          dueTime: 'string - Optional new due time (HH:MM)',\r\n          priority: 'string - Optional new priority',\r\n          category: 'string - Optional new category',\r\n          notify: 'boolean - Optional notification setting',\r\n        },\r\n      },\r\n      {\r\n        name: 'deleteTask',\r\n        description:\r\n          'Delete a task by its name. Use this function call IMMEDIATELY when the user asks to delete, remove, clear, get rid of, cancel, or eliminate a task. Extract the task name from their request and pass it as the taskName parameter. Do not ask for confirmation first - call this function right away with your best guess of the task name. If the task name is ambiguous or not found, the function will return an error, and you can then ask for clarification.',\r\n        parameters: {\r\n          taskName:\r\n            'string - The exact name of the task to delete (not the ID). Must match exactly with an existing task name.',\r\n        },\r\n      },\r\n      {\r\n        name: 'toggleTaskCompletion',\r\n        description:\r\n          'Mark a task as complete or incomplete. Use this function call IMMEDIATELY when user mentions completing a task, marking it as done/finished, checking it off, or they want to mark it as incomplete, undone, or reopen it. Extract the task name from their request and pass it as the taskName parameter. Do not ask for confirmation first - call this function right away with your best guess of the task name.',\r\n        parameters: {\r\n          taskName: 'string - The name of the task to toggle completion status',\r\n        },\r\n      },\r\n      {\r\n        name: 'acceptTeamTaskInvitation',\r\n        description:\r\n          'Accept an invitation to join a team task. Use this function call when the user wants to accept, approve, or join a team task they were invited to. The taskId is required and can be obtained from the list of pending invitations returned by getTeamTasks.',\r\n        parameters: {\r\n          taskId: 'string - The ID of the team task invitation to accept',\r\n        },\r\n      },\r\n      {\r\n        name: 'rejectTeamTaskInvitation',\r\n        description:\r\n          'Reject an invitation to join a team task. Use this function call when the user wants to decline, reject, or refuse a team task invitation. The taskId is required and can be obtained from the list of pending invitations returned by getTeamTasks.',\r\n        parameters: {\r\n          taskId: 'string - The ID of the team task invitation to reject',\r\n        },\r\n      },\r\n      {\r\n        name: 'createRoom',\r\n        description:\r\n          'Create a new meeting room with a specific title. Use this function call when user wants to create, set up, or make a meeting room. You can optionally link a team task (from getTeamTasks) by including its taskId.',\r\n        parameters: {\r\n          title: 'string - The title for the meeting room',\r\n          description: 'string - Optional description for the meeting',\r\n          isPrivate:\r\n            'boolean - Whether the meeting is private (default: false)',\r\n          taskId:\r\n            'string - Optional ID of a team task to associate with this meeting',\r\n        },\r\n      },\r\n      {\r\n        name: 'joinRoom',\r\n        description:\r\n          'Join an existing meeting room using a room code. Use this function call when user wants to join, enter, or access a meeting room with a specific code.',\r\n        parameters: {\r\n          roomCode: 'string - The code for the meeting room to join',\r\n        },\r\n      },\r\n      {\r\n        name: 'webSearch',\r\n        description:\r\n          'Search the web for information not available in the knowledge base. Use this function call when user asks to search, look up, or find information online. Extract search terms from the user query. Only use this for current events, specific facts, or when the user explicitly requests online information. Do not use this for general knowledge questions that can be answered from your training data.',\r\n        parameters: {\r\n          query: 'string - The search query to look up on the web',\r\n        },\r\n      },\r\n      {\r\n        name: 'openUrl',\r\n        description:\r\n          'Open a URL in the browser. Use this function call when a user mentions opening a website, visiting a URL, or browsing to a specific site.',\r\n        parameters: {\r\n          url: 'string - The URL to open',\r\n        },\r\n      },\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Generate the system prompt based on personality and mode\r\n   */\r\n  private generateSystemPrompt(): string {\r\n    // Basic introduction\r\n    let basePrompt = `You are LexAI, a helpful AI assistant in the Learnex app.`;\r\n\r\n    // Add personality traits from the configuration\r\n    if (this.personality?.traits?.length) {\r\n      basePrompt += ` Your personality is: ${this.personality.traits.join(\r\n        ', ',\r\n      )}.`;\r\n    }\r\n\r\n    // Add mode-specific instructions\r\n    if (this.mode === LexAIMode.AGENT) {\r\n      // Full agent mode instructions\r\n      basePrompt += `\r\nYou have access to several capabilities to help the user via function calls:\r\n\r\n1. You can help users navigate through the app with the \"navigate\" tool\r\n2. You can search for posts in the app with the \"searchPosts\" tool\r\n3. You can manage tasks using these tools:\r\n   - \"getTasks\" - Use this when users ask about their tasks\r\n   - \"addTask\" - Use this when users want to create a new personal task or reminder\r\n   - \"addTeamTask\" - Use this when users want to create a shared task with collaborators\r\n   - \"updateTask\" - Use this when users mention changing any task details\r\n   - \"deleteTask\" - Use this when users want to remove a task\r\n   - \"toggleTaskCompletion\" - Use this when users want to mark a task as done\r\n   - \"toggleTheme\" - use this wehen user asks to toggle app theme from current one \r\n   \r\n   CRITICAL FUNCTION CALL RULES:\r\n   - You MUST RESPOND WITH FUNCTION CALLS for ANY task operations (add, delete, update, complete, list) - NO EXCEPTIONS.\r\n   - IF the user says anything about deleting a task, you MUST CALL deleteTask function immediately.\r\n   - IF the user says anything about updating a task, you MUST CALL updateTask function immediately.\r\n   - NEVER say you've done something (like updating a task) in text unless you've actually made the function call.\r\n   - NEVER ask for confirmation before calling functions - just make the function call directly.\r\n   - If you need clarification about which task to modify, use the function call with your best guess and handle errors.\r\n   - ALWAYS use the task NAME (not ID) for all task operations\r\n   - Use \"deleteTask\" with the parameter taskName: \"Buy groceries\" (not taskId)\r\n   - Task names must be unique - you cannot create two tasks with the same name\r\n   - If a user tries to create a task with a name that already exists, suggest using a more specific name\r\n   - If a task name is ambiguous or not found, ask the user for clarification\r\n   - When detecting indirect references to tasks like \"delete it\" or \"the previous one\", extract the task name from context\r\n   - Always use the appropriate task function call when the intent relates to task management, never just talk about doing it\r\n   - Use \"addTeamTask\" when users want to create a shared task with someone else (requires collaborator email)\r\n   - Team tasks require a collaborator email address for sharing - if not provided, ask the user who they want to share with\r\n   - Team task management includes:\r\n     * Use \"getTeamTasks\" to view all team tasks including pending invitations\r\n     * Use \"acceptTeamTaskInvitation\" to accept a team task invitation (requires taskId)\r\n     * Use \"rejectTeamTaskInvitation\" to decline a team task invitation (requires taskId)\r\n\r\n4. You can manage meeting rooms:\r\n   - \"createRoom\" - Use this when users want to create a new meeting room\r\n   - \"joinRoom\" - Use this when users want to join an existing meeting with a room code\r\n   - Note: When creating a meeting room, you can associate it with a team task (not regular tasks)\r\n   - Team tasks can be fetched using \"getTeamTasks\" function call\r\n   - ONLY team tasks (not regular tasks) can be linked with meeting rooms\r\n   - When a user wants to create a meeting room for collaboration with others:\r\n     * First check if they have a team task using \"getTeamTasks\"\r\n     * If not, suggest creating a team task first with \"addTeamTask\"\r\n     * Then create a meeting room and link it to the team task ID\r\n\r\n5. You are knowledgeable about a wide range of topics and can help users by:\r\n   - Answering questions directly using your built-in knowledge when appropriate\r\n   - Using \"webSearch\" only for current events, specific facts, or when users explicitly request online information\r\n   - Understanding when to use your own knowledge vs when to search\r\n   - Being conversational and helpful while staying within your capabilities\r\n   - Only use \"webSearch\" when absolutely necessary to find information not in your training data\r\n6. You can open URLs using the \"openUrl\" tool when needed\r\n7. You can help users understand how to use the app\r\n\r\nYOU ARE REQUIRED TO USE FUNCTION CALLS FOR ACTIONS, but be intelligent about when to use them. \r\n- Answer general questions directly without searching\r\n- Use webSearch only when truly needed or explicitly requested\r\n- Use webSearch for current events or very specific facts and when you cannot answer from your knowledge and training data\r\n- Maintain natural conversation while using tools appropriately\r\nEVERY action requiring app functionality MUST be a function call.\r\n\r\nCRITICAL: ALL of these phrases require IMMEDIATE function calls, not text responses:\r\n- \"Delete it\"  MUST call deleteTask with taskName based on context\r\n- \"Update task2 due date to April 21, 2025\"  MUST call updateTask with taskName: \"task2\" and dueDate: \"2025-04-21\"\r\n- \"Previous one\"  MUST determine the task from context and use appropriate function\r\n- \"Yes\" (after asking about a task)  MUST make the function call right away\r\n- \"Join meeting ABC123\"  MUST call joinRoom with roomCode: \"ABC123\"\r\n\r\nAvailable app screens for navigation:\r\n- Home - Main feed and dashboard\r\n- Search - Find posts and users\r\n- CreatePost - Create a new post\r\n- Tasks - View and manage tasks/to-dos\r\n- Room - View available meeting rooms\r\n- EventsAndHackathons - View upcoming events\r\n- LexAI - Access this AI assistant\r\n- Conversations - Chat and messaging\r\n- SavedPosts - View bookmarked content\r\n- QRCode - Scan QR codes\r\n\r\nRemember:\r\n- ALWAYS USE FUNCTION CALLS for task operations - never use text to pretend you did them\r\n- Never say \"I'll delete that for you\" - CALL the deleteTask function instead\r\n- Never ask \"which task do you want to delete\" - make your best guess from context and call the function\r\n- Be concise in text responses\r\n- When working with tasks, always use the task NAME (not ID) for all operations\r\n- ALWAYS use function calls for any action that requires app functionality\r\n`;\r\n    } else {\r\n      // Simple chat mode instructions\r\n      basePrompt += `\r\nYou are in simple chat mode, focused on being a helpful conversational assistant.\r\n\r\nIn this mode:\r\n1. You can engage in general discussion and answer factual questions using your built-in knowledge\r\n2. You can provide educational content, explanations, and information based on your training\r\n3. You cannot directly manipulate the app (no task creation, navigation, etc.)\r\n4. You do not have web search capabilities or the ability to access external information\r\n\r\nWhen asked about topics:\r\n- Draw on your built-in knowledge to provide accurate, helpful information\r\n- If you're unsure about something, admit the limitations of your knowledge \r\n- Never claim to search the web or access external information\r\n- When asked about topics outside your knowledge, explain that you can only provide information based on your training\r\n- Do not suggest that you could perform a search or that the user switch to Agent mode\r\n\r\nFocus on being a good conversational partner. Be friendly, informative, and concise.\r\nYour primary goal is to provide helpful information and engage in meaningful conversation.\r\n`;\r\n    }\r\n\r\n    // Add closing instructions\r\n    basePrompt += `\r\nAvoid making up information. If you're unsure, clearly say so.\r\nAlways be helpful, respectful, and focused on the user's needs.`;\r\n\r\n    return basePrompt;\r\n  }\r\n\r\n  /**\r\n   * Set LexAI mode\r\n   */\r\n  public setMode(mode: LexAIMode): void {\r\n    this.mode = mode;\r\n    this.systemPrompt = this.generateSystemPrompt();\r\n  }\r\n\r\n  /**\r\n   * Get current LexAI mode\r\n   */\r\n  public getMode(): LexAIMode {\r\n    return this.mode;\r\n  }\r\n\r\n  /**\r\n   * Set LexAI personality\r\n   */\r\n  public setPersonality(personality: LexAIPersonality): void {\r\n    this.personality = personality;\r\n    this.systemPrompt = this.generateSystemPrompt();\r\n  }\r\n\r\n  /**\r\n   * Initialize a new conversation\r\n   */\r\n  public initConversation(\r\n    title: string = 'New Conversation',\r\n    mode: LexAIMode = this.mode,\r\n  ): LexAIConversation {\r\n    // Update current mode if provided\r\n    if (mode !== this.mode) {\r\n      this.setMode(mode);\r\n    }\r\n\r\n    const conversationId = generateUUID();\r\n    const systemMessage: LexAIMessage = {\r\n      id: generateUUID(),\r\n      role: 'system',\r\n      content: this.systemPrompt,\r\n      timestamp: Date.now(),\r\n    };\r\n\r\n    return {\r\n      id: conversationId,\r\n      title,\r\n      messages: [systemMessage],\r\n      createdAt: Date.now(),\r\n      updatedAt: Date.now(),\r\n      mode: this.mode,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Process a user message and get a response from the AI\r\n   */\r\n  public async processMessage(\r\n    userMessage: string,\r\n    conversation: LexAIConversation,\r\n  ): Promise<LexAIResponse> {\r\n    try {\r\n      console.log(\r\n        `LexAI :: processMessage() :: Processing user message: \"${userMessage}\"`,\r\n      );\r\n\r\n      // Set the mode to match the conversation's mode\r\n      if (conversation.mode !== this.mode) {\r\n        this.setMode(conversation.mode);\r\n      }\r\n\r\n      // Get messages for context (excluding system messages for API)\r\n      const messages = conversation.messages\r\n        .filter(msg => msg.role !== 'system')\r\n        .map(msg => ({\r\n          role: msg.role,\r\n          content: msg.content,\r\n        }));\r\n\r\n      // Add new user message\r\n      messages.push({\r\n        role: 'user',\r\n        content: userMessage,\r\n      });\r\n\r\n      // System prompt message\r\n      const systemMessage = {\r\n        role: 'system',\r\n        content: this.systemPrompt,\r\n      };\r\n\r\n      // Prepare request for API with proper format for function calling\r\n      const payload: any = {\r\n        messages: [systemMessage, ...messages],\r\n        model: 'openai/gpt-oss-120b',\r\n        temperature: 0.6,\r\n        max_completion_tokens: 4096,\r\n        top_p: 0.95,\r\n        stream: false, // Set to false to simplify handling for now, user requested true but code handles response.data directly\r\n        stop: null,\r\n      };\r\n\r\n      // Add tools to payload based on mode\r\n      this.addToolsToPayload(payload);\r\n\r\n      // Make API request without streaming\r\n      console.log('LexAI :: processMessage() :: Sending request to Groq API');\r\n\r\n      // Log debug information about the request\r\n      console.log('LexAI :: processMessage() :: Request details:');\r\n      console.log(`  - Model: ${payload.model}`);\r\n      console.log(`  - Temperature: ${payload.temperature}`);\r\n\r\n      if (payload.tools && payload.tools.length > 0) {\r\n        const functionNames = payload.tools\r\n          .map((t: any) => t.function.name)\r\n          .join(', ');\r\n        console.log(\r\n          `  - Available tools (${payload.tools.length}): ${functionNames}`,\r\n        );\r\n      }\r\n\r\n      const response = await axios.post(`${this.API_URL}`, payload, {\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          Authorization: `Bearer ${this.API_KEY}`,\r\n        },\r\n      });\r\n\r\n      // Process the response\r\n      console.log(\r\n        'LexAI :: processMessage() :: Received response from Groq API',\r\n      );\r\n\r\n      // Debug logging for function calls\r\n      if (response.data.choices && response.data.choices.length > 0) {\r\n        const firstChoice = response.data.choices[0];\r\n        console.log('Response choice:', JSON.stringify(firstChoice, null, 2));\r\n\r\n        // Check for function call in the response\r\n        if (firstChoice.message?.tool_calls) {\r\n          console.log(\r\n            `FUNCTION CALLS DETECTED:`,\r\n            firstChoice.message.tool_calls,\r\n          );\r\n        } else {\r\n          console.log('NO FUNCTION CALL IN RESPONSE');\r\n        }\r\n      } else {\r\n        console.log('No choices in response');\r\n      }\r\n\r\n      console.log(\r\n        'Response structure:',\r\n        JSON.stringify(response.data, null, 2),\r\n      );\r\n\r\n      const responseData = response.data;\r\n      const message = responseData.choices?.[0]?.message;\r\n\r\n      // Check if this response contains tool calls\r\n      if (message?.tool_calls && message.tool_calls.length > 0) {\r\n        const toolCallData = message.tool_calls[0]; // Handle first tool call for now\r\n\r\n        console.log(\r\n          `LexAI :: processMessage() :: Processing tool call: ${toolCallData.function.name}`,\r\n        );\r\n\r\n        // Parse arguments which are returned as a JSON string\r\n        let args = {};\r\n        try {\r\n          args = JSON.parse(toolCallData.function.arguments);\r\n        } catch (e) {\r\n          console.error('Error parsing tool arguments:', e);\r\n        }\r\n\r\n        console.log(\r\n          `LexAI :: processMessage() :: Function parameters:`,\r\n          JSON.stringify(args),\r\n        );\r\n\r\n        const toolCall: LexAIToolCall = {\r\n          id: generateUUID(),\r\n          toolName: toolCallData.function.name,\r\n          parameters: args,\r\n        };\r\n\r\n        // Execute the function call\r\n        console.log(\r\n          `LexAI :: processMessage() :: Executing tool call: ${toolCall.toolName}`,\r\n        );\r\n        const toolResult = await this.executeToolCall(toolCall);\r\n        console.log('LexAI :: processMessage() :: Tool execution result:', {\r\n          toolName: toolCall.toolName,\r\n          parameters: toolCall.parameters,\r\n          response: toolResult.response ? 'Success' : undefined,\r\n          error: toolResult.error || undefined,\r\n        });\r\n\r\n        // Process the result with another API call\r\n        console.log(\r\n          `LexAI :: processMessage() :: Processing tool result for follow-up response`,\r\n        );\r\n        const followUpResponse = await this.processToolResult(\r\n          toolResult,\r\n          conversation,\r\n        );\r\n        console.log(\r\n          `LexAI :: processMessage() :: Returning follow-up response from tool execution`,\r\n        );\r\n\r\n        return followUpResponse;\r\n      } else {\r\n        console.log(\r\n          'LexAI :: processMessage() :: No tool calls found, processing as text response',\r\n        );\r\n\r\n        const textContent = message?.content || '';\r\n\r\n        // Provide a fallback message if no text is found\r\n        if (!textContent.trim()) {\r\n          console.log('No text content found, using fallback message');\r\n          // If strictly empty content and no tool calls, it might be an error or empty completion\r\n          // But usually Groq returns content.\r\n        }\r\n\r\n        // Return the text response\r\n        const aiMsg: LexAIMessage = {\r\n          id: generateUUID(),\r\n          role: 'assistant',\r\n          content:\r\n            textContent || \"I'm sorry, I couldn't generate a proper response.\",\r\n          timestamp: Date.now(),\r\n        };\r\n\r\n        return {message: aiMsg};\r\n      }\r\n    } catch (error: any) {\r\n      console.error('Error in LexAI processMessage:', error);\r\n      console.error('Error details:', error.message);\r\n      if (error.response) {\r\n        console.error(\r\n          'API response error:',\r\n          JSON.stringify(error.response.data),\r\n        );\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add appropriate tools to the API payload based on current mode\r\n   */\r\n  private addToolsToPayload(payload: any): void {\r\n    if (this.mode === LexAIMode.AGENT) {\r\n      // Include all tools in agent mode\r\n      payload.tools = this.availableTools.map(tool => {\r\n        // Format each tool according to the OpenAI API documentation\r\n        const functionDefinition: any = {\r\n          name: tool.name,\r\n          description: tool.description,\r\n          parameters: {\r\n            type: 'object',\r\n            properties: {},\r\n            required: [],\r\n          },\r\n        };\r\n\r\n        // Convert parameters to the correct format\r\n        Object.entries(tool.parameters).forEach(([key, value]) => {\r\n          const description = value.toString();\r\n\r\n          // Parse the parameter description to identify type\r\n          const typeMatch = description.match(/^(.*?)\\s+-\\s+/);\r\n          const typeStr = typeMatch ? typeMatch[1].toLowerCase() : 'string';\r\n\r\n          // Check if parameter is required (doesn't contain \"Optional\")\r\n          if (!description.includes('Optional')) {\r\n            functionDefinition.parameters.required.push(key);\r\n          }\r\n\r\n          // Set up property with appropriate type\r\n          if (typeStr.includes('array')) {\r\n            functionDefinition.parameters.properties[key] = {\r\n              type: 'array',\r\n              items: {type: 'string'},\r\n              description: description,\r\n            };\r\n          } else if (typeStr.includes('boolean')) {\r\n            functionDefinition.parameters.properties[key] = {\r\n              type: 'boolean',\r\n              description: description,\r\n            };\r\n          } else if (typeStr.includes('number')) {\r\n            functionDefinition.parameters.properties[key] = {\r\n              type: 'number',\r\n              description: description,\r\n            };\r\n          } else if (typeStr.includes('object')) {\r\n            functionDefinition.parameters.properties[key] = {\r\n              type: 'object',\r\n              description: description,\r\n            };\r\n          } else {\r\n            // Default to string for all other types\r\n            functionDefinition.parameters.properties[key] = {\r\n              type: 'string',\r\n              description: description,\r\n            };\r\n          }\r\n        });\r\n\r\n        return {\r\n          type: 'function',\r\n          function: functionDefinition,\r\n        };\r\n      });\r\n\r\n      // OpenAI/Groq Tool Choice\r\n      payload.tool_choice = 'auto';\r\n\r\n      // Update system prompt in first message to enhance function calling behavior\r\n      if (payload.messages && payload.messages.length > 0) {\r\n        const firstMessage = payload.messages[0];\r\n        if (firstMessage.role === 'system') {\r\n          // Add clear function call instructions to the system prompt\r\n          const functionCallInstructions = `\r\nIMPORTANT FUNCTION CALL INSTRUCTIONS:\r\n1. You MUST use function calls for ALL actions - NEVER try to perform actions through text responses.\r\n2. For ANY task-related operations (creating, updating, listing, deleting tasks), you MUST use function calls.\r\n3. When users ask to delete something, IMMEDIATELY call the deleteTask function.\r\n4. When users ask to update something, IMMEDIATELY call the updateTask function.\r\n5. When users ask to create something, IMMEDIATELY call the addTask function.\r\n6. NEVER reply with text when a function call is appropriate - the system can ONLY perform actions via function calls.\r\n7. When users ask to search or look up information, IMMEDIATELY call the webSearch function.\r\n8. User confirmations like \"yes\", \"do it\", or \"go ahead\" should trigger immediate function calls based on context.\r\n9. NEVER say you'll do something without making the corresponding function call.\r\n\r\nEXAMPLES OF CORRECT RESPONSES:\r\n1. User: \"Delete my homework task\"  Call deleteTask with taskName=\"homework\"\r\n2. User: \"Can you update the meeting task to be due tomorrow?\"  Call updateTask with taskName=\"meeting\"\r\n3. User: \"Create a task to buy groceries\"  Call addTask with title=\"Buy groceries\"\r\n4. User: \"What tasks do I have?\"  Call getTasks\r\n5. User: \"Show me the latest React updates\"  Call webSearch with query=\"latest React updates\"\r\n`;\r\n\r\n          // Append to existing system prompt\r\n          firstMessage.content =\r\n            firstMessage.content + functionCallInstructions;\r\n\r\n          console.log('Enhanced system prompt with function call instructions');\r\n        }\r\n      }\r\n    } else {\r\n      // In simple chat mode, don't include any tools\r\n      // This ensures the model will rely on its built-in knowledge\r\n\r\n      // Update system prompt for simple chat mode\r\n      if (payload.messages && payload.messages.length > 0) {\r\n        const firstMessage = payload.messages[0];\r\n        if (firstMessage.role === 'system') {\r\n          // Add reminders about using internal knowledge\r\n          const simpleModeInstructions = `\r\nIMPORTANT INSTRUCTIONS:\r\n1. You are in simple chat mode with no external tools.\r\n2. Answer questions using your built-in knowledge only.\r\n3. Do not claim to search for information or access external data.\r\n4. When uncertain, admit the limitations of your knowledge rather than suggesting a search.\r\n5. Focus on providing educational, informative content based on what you already know.\r\n6. Be conversational, friendly, and concise in your responses.\r\n`;\r\n\r\n          // Append to existing system prompt\r\n          firstMessage.content = firstMessage.content + simpleModeInstructions;\r\n\r\n          console.log(\r\n            'Enhanced system prompt with instructions for simple chat mode',\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Log information about the tools being included\r\n    console.log(`Adding tools to payload for ${this.mode} mode`);\r\n    if (payload.tools) {\r\n      console.log(`Number of tools: ${payload.tools.length}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute a tool call and return the result\r\n   */\r\n  private async executeToolCall(\r\n    toolCall: LexAIToolCall,\r\n  ): Promise<LexAIToolCall> {\r\n    try {\r\n      const {toolName, parameters} = toolCall;\r\n\r\n      // In simple chat mode, don't allow any tool calls including web search\r\n      if (this.mode === LexAIMode.SIMPLE_CHAT) {\r\n        return {\r\n          ...toolCall,\r\n          error: `Tool ${toolName} is not available in simple chat mode. Simple chat mode doesn't support any external tools.`,\r\n        };\r\n      }\r\n\r\n      switch (toolName) {\r\n        case 'navigate':\r\n          // Validate required parameters\r\n          if (!parameters.screenName) {\r\n            return {\r\n              ...toolCall,\r\n              error: 'Missing required parameter: screenName',\r\n            };\r\n          }\r\n\r\n          try {\r\n            // Normalize screen name to match UserStackParamList names\r\n            // This handles variations like \"home\", \"Home\", \"home screen\", etc.\r\n            const screenNameInput = parameters.screenName.trim();\r\n            let normalizedScreenName = screenNameInput;\r\n\r\n            // Convert first letter to uppercase for standard screens\r\n            if (screenNameInput.length > 0) {\r\n              const firstChar = screenNameInput.charAt(0).toUpperCase();\r\n              const restOfString = screenNameInput\r\n                .slice(1)\r\n                .toLowerCase()\r\n                .replace(/\\s+screen$/, '');\r\n              normalizedScreenName = firstChar + restOfString;\r\n            }\r\n\r\n            // Map common variations to exact screen names\r\n            const screenNameMap: Record<string, string> = {\r\n              home: 'Home',\r\n              search: 'Search',\r\n              create: 'CreatePost',\r\n              createpost: 'CreatePost',\r\n              'create post': 'CreatePost',\r\n              post: 'CreatePost',\r\n              lexai: 'LexAI',\r\n              lex: 'LexAI',\r\n              ai: 'LexAI',\r\n              assistant: 'LexAI',\r\n              tasks: 'Tasks',\r\n              task: 'Tasks',\r\n              todo: 'Tasks',\r\n              todos: 'Tasks',\r\n              'to-do': 'Tasks',\r\n              'to-dos': 'Tasks',\r\n              events: 'EventsAndHackathons',\r\n              hackathons: 'EventsAndHackathons',\r\n              event: 'EventsAndHackathons',\r\n              'events and hackathons': 'EventsAndHackathons',\r\n              eventdetails: 'EventDetails',\r\n              'event details': 'EventDetails',\r\n              room: 'Room',\r\n              roomscreen: 'RoomScreen',\r\n              'room screen': 'RoomScreen',\r\n              rooms: 'Room',\r\n              meetings: 'Room',\r\n              meeting: 'Room',\r\n              chat: 'Conversations',\r\n              chats: 'Conversations',\r\n              conversation: 'Conversations',\r\n              conversations: 'Conversations',\r\n              messages: 'Conversations',\r\n              message: 'Conversations',\r\n              saved: 'SavedPosts',\r\n              'saved posts': 'SavedPosts',\r\n              'saved post': 'SavedPosts',\r\n              bookmarks: 'SavedPosts',\r\n              qr: 'QRCode',\r\n              qrcode: 'QRCode',\r\n              'qr code': 'QRCode',\r\n              scan: 'QRCode',\r\n              contacts: 'ContactList',\r\n              'contact list': 'ContactList',\r\n              contactlist: 'ContactList',\r\n              profile: 'Profile',\r\n            };\r\n\r\n            // Get the correct screen name from the map or use the original (properly cased)\r\n            const lowercaseScreenName = screenNameInput.toLowerCase().trim();\r\n            const mappedScreenName =\r\n              screenNameMap[lowercaseScreenName] || screenNameInput;\r\n\r\n            // Handle special cases for tab navigation\r\n            const tabScreens = ['Home', 'Search', 'CreatePost'];\r\n            if (tabScreens.includes(mappedScreenName)) {\r\n              DeepLinkHandler.navigate('Tabs', {screen: mappedScreenName});\r\n              return {\r\n                ...toolCall,\r\n                response: {\r\n                  success: true,\r\n                  screenName: mappedScreenName,\r\n                  originalInput: parameters.screenName,\r\n                  message: `Navigated to ${mappedScreenName} tab`,\r\n                },\r\n              };\r\n            }\r\n\r\n            // Handle screens that may require parameters\r\n            if (mappedScreenName === 'EventDetails' && parameters.params) {\r\n              DeepLinkHandler.navigate(mappedScreenName, parameters.params);\r\n              return {\r\n                ...toolCall,\r\n                response: {\r\n                  success: true,\r\n                  screenName: mappedScreenName,\r\n                  originalInput: parameters.screenName,\r\n                  message: `Navigated to ${mappedScreenName} with parameters`,\r\n                },\r\n              };\r\n            }\r\n\r\n            // Handle Room navigation with potential parameters\r\n            if (\r\n              (mappedScreenName === 'Room' ||\r\n                mappedScreenName === 'RoomScreen') &&\r\n              parameters.params\r\n            ) {\r\n              DeepLinkHandler.navigate(mappedScreenName, parameters.params);\r\n              return {\r\n                ...toolCall,\r\n                response: {\r\n                  success: true,\r\n                  screenName: mappedScreenName,\r\n                  originalInput: parameters.screenName,\r\n                  message: `Navigated to ${mappedScreenName} with parameters`,\r\n                },\r\n              };\r\n            }\r\n\r\n            // Default navigation for other screens\r\n            const success = DeepLinkHandler.navigate(\r\n              mappedScreenName,\r\n              parameters.params || {},\r\n            );\r\n\r\n            return {\r\n              ...toolCall,\r\n              response: {\r\n                success,\r\n                screenName: mappedScreenName,\r\n                originalInput: parameters.screenName,\r\n                message: success\r\n                  ? `Navigated to ${mappedScreenName} screen`\r\n                  : `Failed to navigate to ${mappedScreenName}`,\r\n              },\r\n            };\r\n          } catch (error: any) {\r\n            console.error('Navigation error:', error);\r\n            return {\r\n              ...toolCall,\r\n              error: `Failed to navigate: ${error.message || 'Unknown error'}`,\r\n            };\r\n          }\r\n\r\n        case 'searchPosts':\r\n          // Provide default for query if missing\r\n          const searchQuery = parameters.query || 'recent posts';\r\n\r\n          try {\r\n            // In the future, implement actual post search logic here\r\n            return {\r\n              ...toolCall,\r\n              response: {\r\n                message: `Searching for posts containing \"${searchQuery}\"`,\r\n                query: searchQuery,\r\n                // In a real implementation, you would return actual search results\r\n                results: [],\r\n              },\r\n            };\r\n          } catch (error: any) {\r\n            console.error('Post search error:', error);\r\n            return {\r\n              ...toolCall,\r\n              error: `Failed to search posts: ${\r\n                error.message || 'Unknown error'\r\n              }`,\r\n            };\r\n          }\r\n\r\n        case 'getTasks':\r\n          console.log('LexAI :: executeToolCall() :: Getting user tasks');\r\n          try {\r\n            const tasks = await this.taskService.getTasks();\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Retrieved ${tasks.length} tasks`,\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              response: {tasks},\r\n            };\r\n          } catch (error: any) {\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Error getting tasks: ${error.message}`,\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: 'Failed to retrieve tasks: ' + error.message,\r\n            };\r\n          }\r\n\r\n        case 'getTeamTasks':\r\n          console.log('LexAI :: executeToolCall() :: Getting user team tasks');\r\n          try {\r\n            const duoTasks = await this.taskService.getDuoTasks();\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Retrieved ${duoTasks.length} team tasks`,\r\n            );\r\n\r\n            // Get pending invitations as well\r\n            const pendingInvitations =\r\n              await this.taskService.getPendingDuoTaskInvitations();\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Retrieved ${pendingInvitations.length} pending team task invitations`,\r\n            );\r\n\r\n            return {\r\n              ...toolCall,\r\n              response: {\r\n                teamTasks: duoTasks,\r\n                pendingInvitations: pendingInvitations,\r\n              },\r\n            };\r\n          } catch (error: any) {\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Error getting team tasks: ${error.message}`,\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: 'Failed to retrieve team tasks: ' + error.message,\r\n            };\r\n          }\r\n\r\n        case 'toggleTheme':\r\n          return {\r\n            ...toolCall,\r\n          };\r\n        case 'addTask':\r\n          // Validate required parameter\r\n          if (!parameters.title) {\r\n            console.log(\r\n              'LexAI :: executeToolCall() :: Missing required parameter: title',\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: 'Missing required parameter: title',\r\n            };\r\n          }\r\n\r\n          console.log(\r\n            `LexAI :: executeToolCall() :: Creating task with title: \"${parameters.title}\"`,\r\n          );\r\n\r\n          // Smart defaults for task creation\r\n          const now = new Date();\r\n          const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);\r\n\r\n          // Format date and time for default values\r\n          const defaultDueDate = oneHourLater.toISOString().split('T')[0]; // YYYY-MM-DD\r\n          const defaultDueTime = `${oneHourLater\r\n            .getHours()\r\n            .toString()\r\n            .padStart(2, '0')}:${oneHourLater\r\n            .getMinutes()\r\n            .toString()\r\n            .padStart(2, '0')}`; // HH:MM\r\n\r\n          // Create task with defaults but prioritize explicit parameters\r\n          try {\r\n            console.log(\r\n              'LexAI :: executeToolCall() :: Preparing task data with defaults',\r\n            );\r\n            const taskData = {\r\n              title: parameters.title,\r\n              description: parameters.description || '',\r\n              dueDate: parameters.dueDate || defaultDueDate,\r\n              dueTime: parameters.dueTime || defaultDueTime,\r\n              priority: parameters.priority || 'medium',\r\n              category: parameters.category || 'general',\r\n              notify:\r\n                parameters.notify !== undefined ? parameters.notify : true,\r\n              completed: false,\r\n              userId: '', // This will be set by the TaskService\r\n              isDuoTask: false, // Explicitly mark as a regular task, not a team task\r\n            };\r\n            console.log(\r\n              'LexAI :: executeToolCall() :: Task data:',\r\n              JSON.stringify(taskData),\r\n            );\r\n\r\n            const taskId = await this.taskService.addTask(taskData);\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Task created successfully with ID: ${taskId}`,\r\n            );\r\n\r\n            return {\r\n              ...toolCall,\r\n              response: {\r\n                success: true,\r\n                taskId,\r\n                message: `Task \"${parameters.title}\" created${\r\n                  parameters.dueDate\r\n                    ? ` for ${parameters.dueDate}`\r\n                    : ' for today'\r\n                }.`,\r\n              },\r\n            };\r\n          } catch (error: any) {\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Error creating task: ${error.message}`,\r\n            );\r\n\r\n            // Check if error is due to duplicate task name\r\n            if (error.message && error.message.includes('already exists')) {\r\n              // Extract the task name from the error message\r\n              const taskNameMatch = error.message.match(/name \"([^\"]+)\"/);\r\n              if (taskNameMatch && taskNameMatch[1]) {\r\n                const taskName = taskNameMatch[1];\r\n                // Suggest adding a number suffix to make it unique\r\n                return {\r\n                  ...toolCall,\r\n                  error: `A task named \"${taskName}\" already exists. Please try again with a different name, such as \"${taskName} 2\".`,\r\n                };\r\n              }\r\n            }\r\n\r\n            return {\r\n              ...toolCall,\r\n              error: `Failed to create task: ${error.message}`,\r\n            };\r\n          }\r\n\r\n        case 'addTeamTask':\r\n          // Validate required parameters\r\n          if (!parameters.title) {\r\n            console.log(\r\n              'LexAI :: executeToolCall() :: Missing required parameter: title',\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: 'Missing required parameter: title',\r\n            };\r\n          }\r\n\r\n          if (!parameters.collaboratorEmail) {\r\n            console.log(\r\n              'LexAI :: executeToolCall() :: Missing required parameter: collaboratorEmail',\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: 'Missing required parameter: collaboratorEmail',\r\n            };\r\n          }\r\n\r\n          console.log(\r\n            `LexAI :: executeToolCall() :: Creating team task with title: \"${parameters.title}\" for collaborator: ${parameters.collaboratorEmail}`,\r\n          );\r\n\r\n          // Smart defaults for task creation\r\n          const teamTaskNow = new Date();\r\n          const teamTaskOneHourLater = new Date(\r\n            teamTaskNow.getTime() + 60 * 60 * 1000,\r\n          );\r\n\r\n          // Format date and time for default values\r\n          const teamTaskDefaultDueDate = teamTaskOneHourLater\r\n            .toISOString()\r\n            .split('T')[0]; // YYYY-MM-DD\r\n          const teamTaskDefaultDueTime = `${teamTaskOneHourLater\r\n            .getHours()\r\n            .toString()\r\n            .padStart(2, '0')}:${teamTaskOneHourLater\r\n            .getMinutes()\r\n            .toString()\r\n            .padStart(2, '0')}`; // HH:MM\r\n\r\n          try {\r\n            console.log(\r\n              'LexAI :: executeToolCall() :: Preparing team task data with defaults',\r\n            );\r\n\r\n            // First, get the current user ID\r\n            const currentUserId = getAuth().currentUser?.uid;\r\n            if (!currentUserId) {\r\n              return {\r\n                ...toolCall,\r\n                error: 'User not authenticated',\r\n              };\r\n            }\r\n\r\n            // Search for collaborator by email\r\n            const userSnapshot = await getDocs(\r\n              query(\r\n                collection(getFirestore(), 'users'),\r\n                where('email', '==', parameters.collaboratorEmail),\r\n                limit(1),\r\n              ),\r\n            );\r\n\r\n            if (userSnapshot.empty) {\r\n              return {\r\n                ...toolCall,\r\n                error: `No user found with email ${parameters.collaboratorEmail}`,\r\n              };\r\n            }\r\n\r\n            const collaboratorId = userSnapshot.docs[0].id;\r\n            const collaboratorData = userSnapshot.docs[0].data();\r\n\r\n            // Verify not adding self\r\n            if (collaboratorId === currentUserId) {\r\n              return {\r\n                ...toolCall,\r\n                error: 'You cannot add yourself as a collaborator',\r\n              };\r\n            }\r\n\r\n            // Create task data with collaborators array\r\n            const teamTaskData = {\r\n              title: parameters.title,\r\n              description: parameters.description || '',\r\n              dueDate: parameters.dueDate || teamTaskDefaultDueDate,\r\n              dueTime: parameters.dueTime || teamTaskDefaultDueTime,\r\n              priority: parameters.priority || 'medium',\r\n              category: parameters.category || 'general',\r\n              notify:\r\n                parameters.notify !== undefined ? parameters.notify : true,\r\n              completed: false,\r\n              userId: currentUserId,\r\n              isDuoTask: true,\r\n              collaborators: [currentUserId, collaboratorId],\r\n              collaborationStatus: 'pending',\r\n              progress: 0,\r\n            };\r\n\r\n            console.log(\r\n              'LexAI :: executeToolCall() :: Team task data:',\r\n              JSON.stringify(teamTaskData),\r\n            );\r\n\r\n            // Use the createDuoTask method to add the team task\r\n            const teamTaskId =\r\n              await this.taskService.createDuoTask(teamTaskData);\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Team task created successfully with ID: ${teamTaskId}`,\r\n            );\r\n\r\n            return {\r\n              ...toolCall,\r\n              response: {\r\n                success: true,\r\n                taskId: teamTaskId,\r\n                message: `Team task \"${\r\n                  parameters.title\r\n                }\" created and shared with ${\r\n                  collaboratorData.displayName || parameters.collaboratorEmail\r\n                }${\r\n                  parameters.dueDate\r\n                    ? ` for ${parameters.dueDate}`\r\n                    : ' for today'\r\n                }.`,\r\n              },\r\n            };\r\n          } catch (error: any) {\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Error creating team task: ${error.message}`,\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: `Failed to create team task: ${error.message}`,\r\n            };\r\n          }\r\n\r\n        case 'updateTask':\r\n          // Validate required parameter for update\r\n          if (!parameters.taskName) {\r\n            console.log(\r\n              'LexAI :: executeToolCall() :: Missing required parameter: taskName',\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: 'Missing required parameter: taskName',\r\n            };\r\n          }\r\n\r\n          console.log(\r\n            `LexAI :: executeToolCall() :: Updating task: \"${parameters.taskName}\"`,\r\n          );\r\n\r\n          // Create a partial task object with the provided parameters\r\n          const taskUpdate: Partial<Task> = {};\r\n          if (parameters.title) taskUpdate.title = parameters.title;\r\n          if (parameters.description)\r\n            taskUpdate.description = parameters.description;\r\n          if (parameters.dueDate) taskUpdate.dueDate = parameters.dueDate;\r\n          if (parameters.dueTime) taskUpdate.dueTime = parameters.dueTime;\r\n          if (parameters.priority)\r\n            taskUpdate.priority = parameters.priority as any;\r\n          if (parameters.category) taskUpdate.category = parameters.category;\r\n          if (parameters.notify !== undefined)\r\n            taskUpdate.notify = parameters.notify;\r\n\r\n          console.log(\r\n            'LexAI :: executeToolCall() :: Update data:',\r\n            JSON.stringify(taskUpdate),\r\n          );\r\n\r\n          try {\r\n            await this.taskService.updateTaskByName(\r\n              parameters.taskName,\r\n              taskUpdate,\r\n            );\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Task \"${parameters.taskName}\" updated successfully`,\r\n            );\r\n\r\n            return {\r\n              ...toolCall,\r\n              response: {\r\n                success: true,\r\n                taskName: parameters.taskName,\r\n                message: 'Task updated successfully.',\r\n              },\r\n            };\r\n          } catch (error: any) {\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Error updating task: ${error.message}`,\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: `Failed to update task: ${error.message}`,\r\n            };\r\n          }\r\n\r\n        case 'deleteTask':\r\n          // Validate required parameter\r\n          if (!parameters.taskName) {\r\n            console.log(\r\n              'LexAI :: executeToolCall() :: Missing required parameter: taskName',\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: 'Missing required parameter: taskName',\r\n            };\r\n          }\r\n\r\n          console.log(\r\n            `LexAI :: executeToolCall() :: Deleting task: \"${parameters.taskName}\"`,\r\n          );\r\n\r\n          try {\r\n            await this.taskService.deleteTaskByName(parameters.taskName);\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Task \"${parameters.taskName}\" deleted successfully`,\r\n            );\r\n\r\n            return {\r\n              ...toolCall,\r\n              response: {\r\n                success: true,\r\n                taskName: parameters.taskName,\r\n                message: 'Task deleted successfully.',\r\n              },\r\n            };\r\n          } catch (error: any) {\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Error deleting task: ${error.message}`,\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: `Failed to delete task: ${error.message}`,\r\n            };\r\n          }\r\n\r\n        case 'toggleTaskCompletion':\r\n          // Validate required parameter\r\n          if (!parameters.taskName) {\r\n            console.log(\r\n              'LexAI :: executeToolCall() :: Missing required parameter: taskName',\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: 'Missing required parameter: taskName',\r\n            };\r\n          }\r\n\r\n          console.log(\r\n            `LexAI :: executeToolCall() :: Toggling completion for task: \"${parameters.taskName}\"`,\r\n          );\r\n\r\n          try {\r\n            await this.taskService.toggleTaskCompletionByName(\r\n              parameters.taskName,\r\n            );\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Completion toggled for task \"${parameters.taskName}\"`,\r\n            );\r\n\r\n            return {\r\n              ...toolCall,\r\n              response: {\r\n                success: true,\r\n                taskName: parameters.taskName,\r\n                message: 'Task completion status toggled.',\r\n              },\r\n            };\r\n          } catch (error: any) {\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Error toggling task completion: ${error.message}`,\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: `Failed to toggle task completion: ${error.message}`,\r\n            };\r\n          }\r\n\r\n        case 'acceptTeamTaskInvitation':\r\n          // Validate required parameter\r\n          if (!parameters.taskId) {\r\n            console.log(\r\n              'LexAI :: executeToolCall() :: Missing required parameter: taskId',\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: 'Missing required parameter: taskId',\r\n            };\r\n          }\r\n\r\n          console.log(\r\n            `LexAI :: executeToolCall() :: Accepting team task invitation: \"${parameters.taskId}\"`,\r\n          );\r\n\r\n          try {\r\n            await this.taskService.acceptDuoTaskInvitation(parameters.taskId);\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Team task invitation accepted successfully`,\r\n            );\r\n\r\n            return {\r\n              ...toolCall,\r\n              response: {\r\n                success: true,\r\n                taskId: parameters.taskId,\r\n                message: 'Team task invitation accepted successfully.',\r\n              },\r\n            };\r\n          } catch (error: any) {\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Error accepting team task invitation: ${error.message}`,\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: `Failed to accept team task invitation: ${error.message}`,\r\n            };\r\n          }\r\n\r\n        case 'rejectTeamTaskInvitation':\r\n          // Validate required parameter\r\n          if (!parameters.taskId) {\r\n            console.log(\r\n              'LexAI :: executeToolCall() :: Missing required parameter: taskId',\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: 'Missing required parameter: taskId',\r\n            };\r\n          }\r\n\r\n          console.log(\r\n            `LexAI :: executeToolCall() :: Rejecting team task invitation: \"${parameters.taskId}\"`,\r\n          );\r\n\r\n          try {\r\n            await this.taskService.rejectDuoTaskInvitation(parameters.taskId);\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Team task invitation rejected successfully`,\r\n            );\r\n\r\n            return {\r\n              ...toolCall,\r\n              response: {\r\n                success: true,\r\n                taskId: parameters.taskId,\r\n                message: 'Team task invitation rejected successfully.',\r\n              },\r\n            };\r\n          } catch (error: any) {\r\n            console.log(\r\n              `LexAI :: executeToolCall() :: Error rejecting team task invitation: ${error.message}`,\r\n            );\r\n            return {\r\n              ...toolCall,\r\n              error: `Failed to reject team task invitation: ${error.message}`,\r\n            };\r\n          }\r\n\r\n        case 'createRoom':\r\n          // Validate required parameter\r\n          if (!parameters.title) {\r\n            return {\r\n              ...toolCall,\r\n              error: 'Missing required parameter: title',\r\n            };\r\n          }\r\n\r\n          return {\r\n            ...toolCall,\r\n            response: {\r\n              success: true,\r\n              message: `Created room: ${parameters.title}`,\r\n              // Navigate to the room (if you have this capability)\r\n              roomInfo: {\r\n                title: parameters.title,\r\n                description: parameters.description || '',\r\n                isPrivate:\r\n                  parameters.isPrivate !== undefined\r\n                    ? parameters.isPrivate\r\n                    : false,\r\n              },\r\n            },\r\n          };\r\n\r\n        case 'joinRoom':\r\n          // Validate required parameter\r\n          if (!parameters.roomCode) {\r\n            return {\r\n              ...toolCall,\r\n              error: 'Missing required parameter: roomCode',\r\n            };\r\n          }\r\n\r\n          return {\r\n            ...toolCall,\r\n            response: {\r\n              success: true,\r\n              message: `Joined room: ${parameters.roomCode}`,\r\n              // Navigate to the room (if you have this capability)\r\n              roomInfo: {\r\n                title: parameters.title,\r\n                description: parameters.description || '',\r\n                isPrivate:\r\n                  parameters.isPrivate !== undefined\r\n                    ? parameters.isPrivate\r\n                    : false,\r\n              },\r\n            },\r\n          };\r\n\r\n        case 'webSearch':\r\n          try {\r\n            const webSearchQuery = parameters.query || 'learnex app';\r\n            console.log('Executing web search for:', webSearchQuery);\r\n\r\n            // Create a search result that points to a real search engine\r\n            const searchResults: WebSearchResult[] = [\r\n              {\r\n                title: `Search results for \"${webSearchQuery}\"`,\r\n                url: `https://www.google.com/search?q=${encodeURIComponent(\r\n                  webSearchQuery,\r\n                )}`,\r\n                snippet:\r\n                  'This search will open in your browser when you click the link in my response.',\r\n              },\r\n            ];\r\n\r\n            return {\r\n              ...toolCall,\r\n              response: {\r\n                query: webSearchQuery,\r\n                results: searchResults,\r\n                message: `I found search results for \"${webSearchQuery}\". You can see them in my response.`,\r\n              },\r\n            };\r\n          } catch (error: any) {\r\n            console.error('Web search error:', error);\r\n            return {\r\n              ...toolCall,\r\n              error: `Failed to search the web: ${\r\n                error.message || 'Unknown error'\r\n              }`,\r\n            };\r\n          }\r\n\r\n        case 'openUrl':\r\n          // Validate required parameter\r\n          if (!parameters.url) {\r\n            return {\r\n              ...toolCall,\r\n              error: 'Missing required parameter: url',\r\n            };\r\n          }\r\n\r\n          try {\r\n            // Ensure URL has proper protocol\r\n            let url = parameters.url;\r\n            if (!url.startsWith('http://') && !url.startsWith('https://')) {\r\n              url = 'https://' + url;\r\n            }\r\n\r\n            // Safety check for URLs\r\n            if (!this.isUrlSafe(url)) {\r\n              return {\r\n                ...toolCall,\r\n                error: 'URL appears to be unsafe or malicious.',\r\n              };\r\n            }\r\n\r\n            // Handle differently based on mode\r\n            if (this.mode === LexAIMode.AGENT) {\r\n              // In agent mode, open the URL directly\r\n              Linking.openURL(url);\r\n              return {\r\n                ...toolCall,\r\n                response: {\r\n                  success: true,\r\n                  url,\r\n                  opened: true,\r\n                  message: `I've opened this URL for you: ${url}`,\r\n                },\r\n              };\r\n            } else {\r\n              // In simple chat mode, just return the URL to be displayed in the chat\r\n              return {\r\n                ...toolCall,\r\n                response: {\r\n                  success: true,\r\n                  url,\r\n                  willOpen: false,\r\n                  displayInChat: true,\r\n                  message: `Here's the link you requested: ${url}`,\r\n                },\r\n              };\r\n            }\r\n          } catch (error: any) {\r\n            console.error('URL opening error:', error);\r\n            return {\r\n              ...toolCall,\r\n              error: `Failed to process URL: ${\r\n                error.message || 'Unknown error'\r\n              }`,\r\n            };\r\n          }\r\n\r\n        default:\r\n          return {\r\n            ...toolCall,\r\n            error: `Unknown tool: ${toolName}`,\r\n          };\r\n      }\r\n    } catch (error: any) {\r\n      console.error(`Error executing tool ${toolCall.toolName}:`, error);\r\n      return {\r\n        ...toolCall,\r\n        error: `Error executing tool ${toolCall.toolName}: ${error.message}`,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process a tool result and get a follow-up response from the AI\r\n   */\r\n  private async processToolResult(\r\n    toolResult: LexAIToolCall,\r\n    conversation: LexAIConversation,\r\n  ): Promise<LexAIResponse> {\r\n    try {\r\n      // Get messages for context (excluding system messages for API)\r\n      const messages = conversation.messages\r\n        .filter(msg => msg.role !== 'system')\r\n        .map(msg => ({\r\n          role: msg.role,\r\n          content: msg.content,\r\n        }));\r\n\r\n      // Create a comprehensive system message that includes context + tool result\r\n      // This simulates a tool result follow-up in a single turn if we aren't maintaining full tool history on client\r\n\r\n      const payload = {\r\n        messages: [\r\n          {\r\n            role: 'system',\r\n            content: this.systemPrompt,\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: `Here's the conversation so far: ${JSON.stringify(\r\n              messages,\r\n            )}\\n\\nI executed the tool ${\r\n              toolResult.toolName\r\n            } with parameters ${JSON.stringify(\r\n              toolResult.parameters,\r\n            )} and got this result: ${JSON.stringify(\r\n              toolResult.response || toolResult.error,\r\n            )}. Please provide an appropriate response to the user based on this result.`,\r\n          },\r\n        ],\r\n        model: 'openai/gpt-oss-120b',\r\n        temperature: 0.6,\r\n        max_completion_tokens: 4096,\r\n        top_p: 0.95,\r\n        stream: false,\r\n        stop: null,\r\n      };\r\n\r\n      // Make API request without streaming\r\n      console.log('Sending tool result follow-up request to Groq API');\r\n      const response = await axios.post(`${this.API_URL}`, payload, {\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          Authorization: `Bearer ${this.API_KEY}`,\r\n        },\r\n      });\r\n\r\n      console.log('Received tool result follow-up response');\r\n      console.log(\r\n        'Response structure:',\r\n        JSON.stringify(response.data, null, 2).substring(0, 500) + '...',\r\n      );\r\n\r\n      // Extract text content\r\n      const textContent = response.data.choices?.[0]?.message?.content || '';\r\n\r\n      console.log(\r\n        'Extracted tool result text content length:',\r\n        textContent.length,\r\n      );\r\n\r\n      // Provide a fallback message if no text is found\r\n      let finalContent = textContent;\r\n      if (!finalContent.trim()) {\r\n        console.log(\r\n          'No text content found in tool result, using fallback message',\r\n        );\r\n        finalContent =\r\n          \"I processed your request but couldn't generate a proper response. Here's what happened: \" +\r\n          (toolResult.error\r\n            ? `There was an error: ${toolResult.error}`\r\n            : `I completed the action successfully.`);\r\n      }\r\n\r\n      // Create a message from the response\r\n      const aiMsg: LexAIMessage = {\r\n        id: generateUUID(),\r\n        role: 'assistant',\r\n        content: finalContent,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      return {\r\n        message: aiMsg,\r\n        toolCalls: [toolResult],\r\n      };\r\n    } catch (error: any) {\r\n      console.error('Error in LexAI processToolResult:', error);\r\n      console.error('Error details:', error.message);\r\n      if (error.response) {\r\n        console.error(\r\n          'API response error:',\r\n          JSON.stringify(error.response.data),\r\n        );\r\n      }\r\n\r\n      // Return a fallback message\r\n      const aiMsg: LexAIMessage = {\r\n        id: generateUUID(),\r\n        role: 'assistant',\r\n        content: `I tried to help with that, but encountered an issue. Could you try asking in a different way?`,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      return {\r\n        message: aiMsg,\r\n        toolCalls: [toolResult],\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save a conversation to Firestore\r\n   */\r\n  public async saveConversation(\r\n    conversation: LexAIConversation,\r\n  ): Promise<void> {\r\n    try {\r\n      await LexAIFirestoreService.saveConversation(conversation);\r\n    } catch (error) {\r\n      console.error('Error saving LexAI conversation:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a specific conversation\r\n   */\r\n  public async getConversation(\r\n    conversationId: string,\r\n  ): Promise<LexAIConversation | null> {\r\n    try {\r\n      return await LexAIFirestoreService.getConversation(conversationId);\r\n    } catch (error) {\r\n      console.error('Error getting LexAI conversation:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load conversations from Firestore\r\n   */\r\n  public async loadConversations(): Promise<LexAIConversation[]> {\r\n    try {\r\n      return await LexAIFirestoreService.loadConversations();\r\n    } catch (error) {\r\n      console.error('Error loading LexAI conversations:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a conversation\r\n   */\r\n  public async deleteConversation(conversationId: string): Promise<void> {\r\n    try {\r\n      await LexAIFirestoreService.deleteConversation(conversationId);\r\n    } catch (error) {\r\n      console.error('Error deleting LexAI conversation:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Enhanced URL safety check method\r\n  private isUrlSafe(url: string): boolean {\r\n    try {\r\n      const urlObj = new URL(url);\r\n      const domain = urlObj.hostname;\r\n\r\n      // List of known malicious domains (would be more comprehensive in production)\r\n      const unsafeDomains = [\r\n        'evil.com',\r\n        'malware.com',\r\n        'phishing.com',\r\n        'virus.com',\r\n        'hack.com',\r\n        'scam.com',\r\n        'spam.com',\r\n        'trojan.com',\r\n      ];\r\n\r\n      // Check against unsafe domains\r\n      for (const unsafeDomain of unsafeDomains) {\r\n        if (\r\n          domain.includes(unsafeDomain) ||\r\n          domain.endsWith(`.${unsafeDomain}`)\r\n        ) {\r\n          console.warn(`Blocked access to unsafe domain: ${domain}`);\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Check for suspicious TLDs that are often associated with malicious sites\r\n      const suspiciousTLDs = ['.xyz', '.tk', '.ml', '.ga', '.cf', '.gq'];\r\n      for (const tld of suspiciousTLDs) {\r\n        if (domain.endsWith(tld)) {\r\n          console.warn(`Blocked access to suspicious TLD: ${domain}`);\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Block certain protocols\r\n      const blockedProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];\r\n      for (const protocol of blockedProtocols) {\r\n        if (url.toLowerCase().startsWith(protocol)) {\r\n          console.warn(`Blocked dangerous protocol: ${protocol}`);\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Restrict to common protocols (http and https)\r\n      if (!urlObj.protocol.match(/^https?:$/)) {\r\n        console.warn(`Blocked uncommon protocol: ${urlObj.protocol}`);\r\n        return false;\r\n      }\r\n\r\n      // Only allow http and https URLs\r\n      if (urlObj.protocol !== 'http:' && urlObj.protocol !== 'https:') {\r\n        console.warn(\r\n          `Only http: and https: protocols are allowed, blocked: ${urlObj.protocol}`,\r\n        );\r\n        return false;\r\n      }\r\n\r\n      // URL passed all safety checks\r\n      return true;\r\n    } catch (_) {\r\n      // If URL parsing fails, consider it unsafe\r\n      console.warn(`URL parsing failed for: ${url}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process the LexAI response and handle any actions that need to be taken\r\n   * This is the method that should be called by the UI after getting a response\r\n   */\r\n  public async handleResponseActions(response: LexAIResponse): Promise<void> {\r\n    try {\r\n      // Check if there are any tool calls that require user-facing actions\r\n      if (response.toolCalls && response.toolCalls.length > 0) {\r\n        for (const toolCall of response.toolCalls) {\r\n          // Handle only specific tools that need direct user interaction\r\n          if (\r\n            toolCall.toolName === 'openUrl' &&\r\n            toolCall.response &&\r\n            !toolCall.error\r\n          ) {\r\n            const urlResponse = toolCall.response as any;\r\n\r\n            // Action depends on mode and response properties\r\n            if (urlResponse.url) {\r\n              if (this.mode === LexAIMode.AGENT && urlResponse.opened) {\r\n                // In AGENT mode with opened flag, we've already opened the URL\r\n                console.log(\r\n                  'URL was opened directly in agent mode:',\r\n                  urlResponse.url,\r\n                );\r\n              } else if (\r\n                this.mode === LexAIMode.SIMPLE_CHAT &&\r\n                urlResponse.displayInChat\r\n              ) {\r\n                // In SIMPLE_CHAT mode, URLs are displayed in chat for user to tap\r\n                console.log(\r\n                  'URL will be displayed in chat for user to tap:',\r\n                  urlResponse.url,\r\n                );\r\n                // No need to do anything here, the UI will handle displaying the URL\r\n              } else if (urlResponse.willOpen) {\r\n                // Backward compatibility for older implementations\r\n                await Linking.openURL(urlResponse.url);\r\n                console.log('Opened URL (legacy mode):', urlResponse.url);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Handle web search results if needed\r\n          if (\r\n            toolCall.toolName === 'webSearch' &&\r\n            toolCall.response &&\r\n            !toolCall.error\r\n          ) {\r\n            const searchResponse = toolCall.response as any;\r\n            if (\r\n              this.mode === LexAIMode.AGENT &&\r\n              searchResponse.results &&\r\n              searchResponse.results.length > 0\r\n            ) {\r\n              // In AGENT mode, we automatically open the first search result\r\n              const searchUrl = searchResponse.results[0].url;\r\n              if (searchUrl && this.isUrlSafe(searchUrl)) {\r\n                await Linking.openURL(searchUrl);\r\n                console.log('Opened search results:', searchUrl);\r\n              }\r\n            }\r\n            // In SIMPLE_CHAT mode, search results are just shown in the conversation\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error handling response actions:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if the user message matches patterns that should force specific tool calls\r\n   * @param userMessage The user's message\r\n   * @returns A tool call object if pattern matched, null otherwise\r\n   */\r\n  private checkForForcedToolCalls(userMessage: string): LexAIToolCall | null {\r\n    const lowerMessage = userMessage.toLowerCase().trim();\r\n\r\n    // Skip forced tool call detection in SIMPLE_CHAT mode\r\n    if (this.mode === LexAIMode.SIMPLE_CHAT) {\r\n      console.log('In SIMPLE_CHAT mode: tool call detection disabled');\r\n      return null;\r\n    }\r\n\r\n    console.log(\r\n      `LexAI :: checkForForcedToolCalls() :: Checking for forced tool calls in: \"${lowerMessage}\"`,\r\n    );\r\n\r\n    // Web search patterns\r\n    if (\r\n      lowerMessage.startsWith('search') ||\r\n      lowerMessage.startsWith('look up') ||\r\n      lowerMessage.startsWith('google') ||\r\n      lowerMessage.match(/^(find|search for|tell me about)\\s+/i) ||\r\n      lowerMessage.includes('search the web for') ||\r\n      // Only match questions that explicitly request online/current information\r\n      lowerMessage.match(\r\n        /^(what'?s|who'?s|what is|who is)\\s+the\\s+(latest|current|recent|newest|trending)/i,\r\n      )\r\n    ) {\r\n      // Extract search query - remove action words\r\n      const searchText = userMessage\r\n        .replace(\r\n          /^(search|look up|find|search for|look for|find out about|google|tell me about)\\s*/i,\r\n          '',\r\n        )\r\n        .replace(\r\n          /^(what'?s|who'?s|what is|who is)\\s+(the\\s+)?(latest|current|recent|newest|trending)\\s+/i,\r\n          '',\r\n        )\r\n        .trim();\r\n\r\n      // Only proceed if we have a meaningful search query\r\n      if (!searchText || searchText.match(/^(about|for)?\\s*$/i)) {\r\n        return null;\r\n      }\r\n\r\n      console.log(\r\n        `LexAI :: checkForForcedToolCalls() :: Detected web search request for: \"${query}\"`,\r\n      );\r\n      return {\r\n        id: generateUUID(),\r\n        toolName: 'webSearch',\r\n        parameters: {query},\r\n      };\r\n    }\r\n\r\n    // The following tool patterns are for AGENT mode only\r\n\r\n    // Add task patterns\r\n    if (\r\n      lowerMessage.includes('add task') ||\r\n      lowerMessage.includes('create task') ||\r\n      lowerMessage.includes('add a task') ||\r\n      lowerMessage.includes('create a task') ||\r\n      lowerMessage.includes('remind me') ||\r\n      lowerMessage.includes('set reminder')\r\n    ) {\r\n      // Try to extract task title\r\n      let title = 'New Task';\r\n\r\n      // Look for patterns like \"add task X\" or \"add a task called X\"\r\n      const titleMatches = userMessage.match(\r\n        /(add|create)(?:\\sa)?\\stask(?:\\scalled|\\snamed|\\stitled)?\\s+(.*?)(?:$|for|on|at)/i,\r\n      );\r\n      if (titleMatches && titleMatches[2]) {\r\n        title = titleMatches[2].trim();\r\n      } else if (lowerMessage.includes('remind me')) {\r\n        // Extract what comes after \"remind me to\" or \"remind me\"\r\n        const reminderMatches = userMessage.match(\r\n          /remind me(?:\\sto)?\\s+(.*?)(?:$|on|at)/i,\r\n        );\r\n        if (reminderMatches && reminderMatches[1]) {\r\n          title = reminderMatches[1].trim();\r\n        }\r\n      }\r\n\r\n      // Get current date + 1 day for default due date\r\n      const tomorrow = new Date();\r\n      tomorrow.setDate(tomorrow.getDate() + 1);\r\n      const dueDate = tomorrow.toISOString().split('T')[0]; // YYYY-MM-DD\r\n\r\n      console.log(\r\n        `LexAI :: checkForForcedToolCalls() :: Detected add task request for: \"${title}\"`,\r\n      );\r\n      return {\r\n        id: generateUUID(),\r\n        toolName: 'addTask',\r\n        parameters: {\r\n          title,\r\n          dueDate,\r\n          dueTime: '12:00',\r\n          priority: 'medium',\r\n          category: 'general',\r\n          notify: true,\r\n          isDuoTask: false, // Explicitly mark as a regular task, not a team task\r\n        },\r\n      };\r\n    }\r\n\r\n    // Add team task patterns\r\n    if (\r\n      lowerMessage.includes('add team task') ||\r\n      lowerMessage.includes('create team task') ||\r\n      lowerMessage.includes('add a team task') ||\r\n      lowerMessage.includes('create a team task') ||\r\n      lowerMessage.includes('add duo task') ||\r\n      lowerMessage.includes('create duo task') ||\r\n      lowerMessage.includes('add a duo task') ||\r\n      lowerMessage.includes('create a duo task') ||\r\n      lowerMessage.includes('add a task with') ||\r\n      lowerMessage.includes('create a task with') ||\r\n      lowerMessage.includes('create a shared task') ||\r\n      lowerMessage.includes('add a shared task')\r\n    ) {\r\n      // Try to extract task title\r\n      let title = 'New Team Task';\r\n      let collaboratorEmail = '';\r\n\r\n      // Look for patterns like \"add team task X\" or \"add a team task called X\"\r\n      const titleMatches = userMessage.match(\r\n        /(add|create)(?:\\sa)?(?:\\steam|\\sduo|\\sshared)?\\stask(?:\\scalled|\\snamed|\\stitled)?\\s+(.*?)(?:$|for|on|at|with)/i,\r\n      );\r\n      if (titleMatches && titleMatches[2]) {\r\n        title = titleMatches[2].trim();\r\n      }\r\n\r\n      // Try to extract collaborator email\r\n      const emailMatches = userMessage.match(\r\n        /with\\s+([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/i,\r\n      );\r\n      if (emailMatches && emailMatches[1]) {\r\n        collaboratorEmail = emailMatches[1].trim();\r\n      }\r\n\r\n      // If no collaborator email is found, we'll return early since it's required\r\n      if (!collaboratorEmail) {\r\n        return null; // Let the AI handle this case with a proper response\r\n      }\r\n\r\n      // Get current date + 1 day for default due date\r\n      const tomorrow = new Date();\r\n      tomorrow.setDate(tomorrow.getDate() + 1);\r\n      const dueDate = tomorrow.toISOString().split('T')[0]; // YYYY-MM-DD\r\n\r\n      console.log(\r\n        `LexAI :: checkForForcedToolCalls() :: Detected add team task request for: \"${title}\" with collaborator: ${collaboratorEmail}`,\r\n      );\r\n      return {\r\n        id: generateUUID(),\r\n        toolName: 'addTeamTask',\r\n        parameters: {\r\n          title,\r\n          collaboratorEmail,\r\n          dueDate,\r\n          dueTime: '12:00',\r\n          priority: 'medium',\r\n          category: 'general',\r\n          notify: true,\r\n        },\r\n      };\r\n    }\r\n\r\n    // Accept team task invitation pattern\r\n    if (\r\n      (lowerMessage.includes('accept') ||\r\n        lowerMessage.includes('approve') ||\r\n        lowerMessage.includes('join') ||\r\n        lowerMessage.includes('confirm')) &&\r\n      (lowerMessage.includes('team task') ||\r\n        lowerMessage.includes('duo task') ||\r\n        lowerMessage.includes('team invitation') ||\r\n        lowerMessage.includes('task invitation'))\r\n    ) {\r\n      // Try to extract task ID\r\n      const taskIdMatches = userMessage.match(\r\n        /task(?:\\s+id)?(?:\\s*:?\\s*)([a-zA-Z0-9]+)/i,\r\n      );\r\n      let taskId = '';\r\n\r\n      if (taskIdMatches && taskIdMatches[1]) {\r\n        taskId = taskIdMatches[1].trim();\r\n\r\n        console.log(\r\n          `LexAI :: checkForForcedToolCalls() :: Detected accept team task invitation for ID: \"${taskId}\"`,\r\n        );\r\n\r\n        return {\r\n          id: generateUUID(),\r\n          toolName: 'acceptTeamTaskInvitation',\r\n          parameters: {\r\n            taskId,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    // Reject team task invitation pattern\r\n    if (\r\n      (lowerMessage.includes('reject') ||\r\n        lowerMessage.includes('decline') ||\r\n        lowerMessage.includes('refuse') ||\r\n        lowerMessage.includes('deny')) &&\r\n      (lowerMessage.includes('team task') ||\r\n        lowerMessage.includes('duo task') ||\r\n        lowerMessage.includes('team invitation') ||\r\n        lowerMessage.includes('task invitation'))\r\n    ) {\r\n      // Try to extract task ID\r\n      const taskIdMatches = userMessage.match(\r\n        /task(?:\\s+id)?(?:\\s*:?\\s*)([a-zA-Z0-9]+)/i,\r\n      );\r\n      let taskId = '';\r\n\r\n      if (taskIdMatches && taskIdMatches[1]) {\r\n        taskId = taskIdMatches[1].trim();\r\n\r\n        console.log(\r\n          `LexAI :: checkForForcedToolCalls() :: Detected reject team task invitation for ID: \"${taskId}\"`,\r\n        );\r\n\r\n        return {\r\n          id: generateUUID(),\r\n          toolName: 'rejectTeamTaskInvitation',\r\n          parameters: {\r\n            taskId,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    // Navigate patterns\r\n    if (\r\n      lowerMessage.includes('navigate to') ||\r\n      lowerMessage.includes('go to') ||\r\n      lowerMessage.includes('open screen') ||\r\n      lowerMessage.match(/^navigate|^go to|^open/)\r\n    ) {\r\n      // Try to extract screen name\r\n      let screenName = 'Home';\r\n\r\n      // Look for patterns like \"navigate to X\" or \"go to X screen\"\r\n      const screenMatches = userMessage.match(\r\n        /(navigate to|go to|open)(?:\\sthe)?\\s+([a-z0-9\\s]+?)(?:\\sscreen|\\spage)?(?:$|\\s)/i,\r\n      );\r\n      if (screenMatches && screenMatches[2]) {\r\n        screenName = screenMatches[2].trim();\r\n      }\r\n\r\n      console.log(\r\n        `LexAI :: checkForForcedToolCalls() :: Detected navigation request to: \"${screenName}\"`,\r\n      );\r\n      return {\r\n        id: generateUUID(),\r\n        toolName: 'navigate',\r\n        parameters: {screenName},\r\n      };\r\n    }\r\n\r\n    // Open URL patterns\r\n    if (\r\n      lowerMessage.includes('open url') ||\r\n      lowerMessage.includes('visit website') ||\r\n      lowerMessage.includes('open website') ||\r\n      lowerMessage.includes('go to website') ||\r\n      lowerMessage.includes('.com') ||\r\n      lowerMessage.includes('.org') ||\r\n      lowerMessage.includes('.net') ||\r\n      lowerMessage.includes('http')\r\n    ) {\r\n      // Try to extract URL\r\n      let url = '';\r\n\r\n      // Look for URL patterns\r\n      const urlMatches = userMessage.match(\r\n        /(https?:\\/\\/[^\\s]+)|(www\\.[^\\s]+)|([a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]\\.[a-zA-Z]{2,}(?:\\.[a-zA-Z]{2,})?)/i,\r\n      );\r\n      if (urlMatches) {\r\n        // Use the first match group that has a value\r\n        for (let i = 1; i < urlMatches.length; i++) {\r\n          if (urlMatches[i]) {\r\n            url = urlMatches[i];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (url) {\r\n        console.log(\r\n          `LexAI :: checkForForcedToolCalls() :: Detected URL open request for: \"${url}\"`,\r\n        );\r\n        return {\r\n          id: generateUUID(),\r\n          toolName: 'openUrl',\r\n          parameters: {url},\r\n        };\r\n      }\r\n    }\r\n\r\n    console.log(\r\n      `LexAI :: checkForForcedToolCalls() :: No forced tool calls detected`,\r\n    );\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Generate message suggestions for direct messaging based on conversation history\r\n   * @param conversationHistory Previous messages in the conversation\r\n   * @param recipientName Name of the person the user is chatting with\r\n   * @returns Array of suggested messages\r\n   */\r\n  public async generateMessageSuggestions(\r\n    conversationHistory: Message[],\r\n    recipientName: string,\r\n  ): Promise<string[]> {\r\n    try {\r\n      // Default suggestions in case API fails\r\n      const defaultSuggestions = [\r\n        `How are you doing, ${recipientName}?`,\r\n        'Would you like to meet up later?',\r\n        'That sounds interesting!',\r\n      ];\r\n\r\n      // If there are no messages yet, return initial greeting suggestions\r\n      if (conversationHistory.length === 0) {\r\n        return [\r\n          `Hi ${recipientName}!`,\r\n          `Hello ${recipientName}, how are you?`,\r\n          `Hey ${recipientName}, nice to connect!`,\r\n        ];\r\n      }\r\n\r\n      // Limit history to last 6 messages to keep context relevant and reduce token usage\r\n      const recentMessages = conversationHistory.slice(-6);\r\n\r\n      // Format conversation for the API\r\n      const formattedConversation = recentMessages.map(msg => ({\r\n        role: 'user',\r\n        content: `${\r\n          msg.senderId === getAuth().currentUser?.uid ? 'Me' : recipientName\r\n        }: ${msg.text}`,\r\n      }));\r\n\r\n      // Prepare request payload\r\n      const payload = {\r\n        messages: [\r\n          {\r\n            role: 'user',\r\n            content: `Given this conversation with ${recipientName}, suggest 3 short, natural-sounding replies I could send next. Format as a JSON array of strings, and keep suggestions brief (under 10 words when possible). Don't include descriptions, just the message text in conversational language:\r\n            ${JSON.stringify(formattedConversation)}`,\r\n          },\r\n        ],\r\n        model: 'openai/gpt-oss-120b',\r\n        temperature: 0.6,\r\n        max_completion_tokens: 4096,\r\n        top_p: 0.95,\r\n        stream: false,\r\n        stop: null,\r\n      };\r\n\r\n      // Make the API request\r\n      console.log('Requesting message suggestions from API');\r\n      const response = await axios.post(`${this.API_URL}`, payload, {\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          Authorization: `Bearer ${this.API_KEY}`,\r\n        },\r\n      });\r\n\r\n      // Extract suggestions from response\r\n      let suggestions: string[] = defaultSuggestions;\r\n\r\n      try {\r\n        const content = response.data.choices?.[0]?.message?.content;\r\n\r\n        if (content) {\r\n          // Look for array pattern\r\n          const match = content.match(/\\[.*\\]/s);\r\n          if (match) {\r\n            const jsonArray = match[0];\r\n            const parsedSuggestions = JSON.parse(jsonArray);\r\n            if (\r\n              Array.isArray(parsedSuggestions) &&\r\n              parsedSuggestions.length > 0\r\n            ) {\r\n              suggestions = parsedSuggestions.slice(0, 3); // Limit to 3 suggestions\r\n            }\r\n          }\r\n        }\r\n      } catch (parseError) {\r\n        console.error('Error parsing suggestions response:', parseError);\r\n        // Use defaults if parsing fails\r\n      }\r\n\r\n      return suggestions;\r\n    } catch (error) {\r\n      console.error('Error generating message suggestions:', error);\r\n      return [\r\n        `How are you doing, ${recipientName}?`,\r\n        'Would you like to meet up later?',\r\n        'Sounds good!',\r\n      ];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if this is a confirmation message for a previous request (like task deletion)\r\n   * @param userMessage The user's message\r\n   * @param conversation The current conversation\r\n   * @returns Object with taskName if this is a confirmation, null otherwise\r\n   */\r\n  private isConfirmationMessage(\r\n    userMessage: string,\r\n    conversation: LexAIConversation,\r\n  ): {taskName: string} | null {\r\n    const lowerMessage = userMessage.toLowerCase().trim();\r\n    console.log(\r\n      `LexAI :: isConfirmationMessage() :: Checking if message is confirmation: \"${lowerMessage}\"`,\r\n    );\r\n\r\n    // Common confirmation patterns\r\n    const isConfirmation =\r\n      lowerMessage === 'yes' ||\r\n      lowerMessage === 'yeah' ||\r\n      lowerMessage === 'yep' ||\r\n      lowerMessage === 'sure' ||\r\n      lowerMessage === 'ok' ||\r\n      lowerMessage === 'okay' ||\r\n      lowerMessage === 'confirm' ||\r\n      lowerMessage === 'do it' ||\r\n      lowerMessage === 'go ahead' ||\r\n      lowerMessage === 'i confirm' ||\r\n      lowerMessage === 'please do' ||\r\n      lowerMessage === \"that's right\" ||\r\n      lowerMessage === 'thats right' ||\r\n      lowerMessage === 'correct' ||\r\n      lowerMessage === 'proceed' ||\r\n      lowerMessage.includes('go ahead') ||\r\n      lowerMessage.includes('sounds good') ||\r\n      lowerMessage.includes('please do') ||\r\n      lowerMessage.includes('that is correct') ||\r\n      lowerMessage.includes('yes please');\r\n\r\n    if (!isConfirmation) {\r\n      console.log(\r\n        `LexAI :: isConfirmationMessage() :: Not a confirmation message`,\r\n      );\r\n      return null;\r\n    }\r\n\r\n    // Check the previous assistant message for task deletion question\r\n    if (conversation.messages.length >= 2) {\r\n      const lastAssistantMessageIndex = conversation.messages\r\n        .slice(0, -1) // Exclude the current user message\r\n        .reverse()\r\n        .findIndex(msg => msg.role === 'assistant');\r\n\r\n      if (lastAssistantMessageIndex !== -1) {\r\n        const lastAssistantMessage =\r\n          conversation.messages[\r\n            conversation.messages.length - 2 - lastAssistantMessageIndex\r\n          ];\r\n        const content = lastAssistantMessage.content.toLowerCase();\r\n        console.log(\r\n          `LexAI :: isConfirmationMessage() :: Last assistant message: \"${content}\"`,\r\n        );\r\n\r\n        // Enhanced task name extraction patterns\r\n        // Look for patterns like \"delete the task named X\" or \"Did you mean to delete X\"\r\n        const taskNameMatch =\r\n          // Match \"delete task X\" patterns\r\n          content.match(\r\n            /delete(?:\\s+the)?(?:\\s+task)?(?:\\s+named)?\\s+[\"']?([^\"'?.,]+)[\"']?/i,\r\n          ) ||\r\n          // Match \"delete X\" patterns\r\n          content.match(/\\bdelete\\s+[\"']?([^\"'?.,]+)[\"']?/i) ||\r\n          // Match \"remove task X\" patterns\r\n          content.match(\r\n            /remove(?:\\s+the)?(?:\\s+task)?(?:\\s+named)?\\s+[\"']?([^\"'?.,]+)[\"']?/i,\r\n          ) ||\r\n          // Match \"cancel task X\" patterns\r\n          content.match(\r\n            /cancel(?:\\s+the)?(?:\\s+task)?(?:\\s+named)?\\s+[\"']?([^\"'?.,]+)[\"']?/i,\r\n          ) ||\r\n          // Match \"would you like to delete\" patterns\r\n          content.match(\r\n            /would you like (?:me )?to delete(?:\\s+the)?(?:\\s+task)?(?:\\s+named)?\\s+[\"']?([^\"'?.,]+)[\"']?/i,\r\n          ) ||\r\n          // Match \"mean the task named X\" patterns (for correction suggestions)\r\n          content.match(\r\n            /mean(?:\\s+the)?(?:\\s+task)?(?:\\s+named)?\\s+[\"']?([^\"'?.,]+)[\"']?/i,\r\n          ) ||\r\n          // Match \"Did you mean task X\" patterns\r\n          content.match(\r\n            /did you mean(?:\\s+the)?(?:\\s+task)?(?:\\s+named)?\\s+[\"']?([^\"'?.,]+)[\"']?/i,\r\n          ) ||\r\n          // Match \"referred to task X\" patterns\r\n          content.match(\r\n            /referred to(?:\\s+the)?(?:\\s+task)?(?:\\s+named)?\\s+[\"']?([^\"'?.,]+)[\"']?/i,\r\n          ) ||\r\n          // Match \"complete task X\" or \"mark X as complete\" patterns\r\n          content.match(\r\n            /(?:complete|mark)(?:\\s+the)?(?:\\s+task)?(?:\\s+named)?\\s+[\"']?([^\"'?.,]+)[\"']?(?:\\s+as\\s+(?:complete|done|finished))?/i,\r\n          ) ||\r\n          // Match \"task X\" as a fallback\r\n          content.match(/\\btask\\s+[\"']?([^\"'?.,]+)[\"']?/i);\r\n\r\n        if (taskNameMatch && taskNameMatch[1]) {\r\n          let extractedTaskName = taskNameMatch[1].trim();\r\n\r\n          // Clean up the task name by removing any \"the task\" phrases\r\n          console.log(\r\n            `LexAI :: isConfirmationMessage() :: Cleaning task name \"${extractedTaskName}\"`,\r\n          );\r\n\r\n          // IMPROVED CLEANING: More thorough step-by-step cleaning\r\n          // Check for \"the task\" prefix first (most specific check first)\r\n          if (extractedTaskName.startsWith('the task ')) {\r\n            console.log(\r\n              `LexAI :: isConfirmationMessage() :: Removing 'the task' prefix`,\r\n            );\r\n            extractedTaskName = extractedTaskName.substring(9).trim();\r\n          }\r\n          // Then check for \"the\" prefix\r\n          else if (extractedTaskName.startsWith('the ')) {\r\n            console.log(\r\n              `LexAI :: isConfirmationMessage() :: Removing 'the' prefix`,\r\n            );\r\n            extractedTaskName = extractedTaskName.substring(4).trim();\r\n          }\r\n\r\n          // Also handle cases where \"the task\" might appear mid-string\r\n          if (extractedTaskName.includes(' the task ')) {\r\n            console.log(\r\n              `LexAI :: isConfirmationMessage() :: Removing ' the task ' from within task name`,\r\n            );\r\n            extractedTaskName = extractedTaskName\r\n              .replace(/\\s+the\\s+task\\s+/gi, ' ')\r\n              .trim();\r\n          }\r\n\r\n          // If the task name contains \"task\" anywhere as a standalone word, remove it\r\n          if (extractedTaskName.match(/\\btask\\b/i)) {\r\n            console.log(\r\n              `LexAI :: isConfirmationMessage() :: Removing standalone 'task' word`,\r\n            );\r\n            extractedTaskName = extractedTaskName\r\n              .replace(/\\btask\\b/gi, '')\r\n              .trim();\r\n          }\r\n\r\n          // Remove \"task\" suffix if present\r\n          if (extractedTaskName.endsWith('task')) {\r\n            console.log(\r\n              `LexAI :: isConfirmationMessage() :: Removing 'task' suffix`,\r\n            );\r\n            extractedTaskName = extractedTaskName\r\n              .substring(0, extractedTaskName.length - 5)\r\n              .trim();\r\n          }\r\n\r\n          // After all cleaning, ensure we don't have multiple spaces\r\n          extractedTaskName = extractedTaskName.replace(/\\s+/g, ' ').trim();\r\n\r\n          console.log(\r\n            `LexAI :: isConfirmationMessage() :: Final extracted task name: \"${extractedTaskName}\"`,\r\n          );\r\n          return {taskName: extractedTaskName};\r\n        } else {\r\n          console.log(\r\n            `LexAI :: isConfirmationMessage() :: No task name found in assistant message`,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    console.log(\r\n      `LexAI :: isConfirmationMessage() :: No relevant previous message found`,\r\n    );\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Handle a confirmed action like task deletion\r\n   * @param toolCall The tool call to execute\r\n   * @param conversation The current conversation\r\n   * @returns LexAIResponse with the result\r\n   */\r\n  private async handleConfirmedAction(\r\n    toolCall: LexAIToolCall,\r\n    conversation: LexAIConversation,\r\n  ): Promise<LexAIResponse> {\r\n    try {\r\n      console.log(\r\n        `LexAI :: handleConfirmedAction() :: Executing confirmed action: ${toolCall.toolName}`,\r\n        JSON.stringify(toolCall.parameters),\r\n      );\r\n\r\n      // Execute the tool call\r\n      const toolResult = await this.executeToolCall(toolCall);\r\n\r\n      // Process the result with another API call\r\n      const followUpResponse = await this.processToolResult(\r\n        toolResult,\r\n        conversation,\r\n      );\r\n\r\n      return followUpResponse;\r\n    } catch (error: any) {\r\n      console.error('Error handling confirmed action:', error);\r\n\r\n      // Return a fallback message\r\n      const aiMsg: LexAIMessage = {\r\n        id: generateUUID(),\r\n        role: 'assistant',\r\n        content: `I tried to process your confirmation, but encountered an issue: ${error.message}`,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      return {\r\n        message: aiMsg,\r\n        toolCalls: [toolCall],\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Create and export a single instance of the service\r\nexport default new LexAIService();\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\NotificationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\TaskService.ts","messages":[{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":51,"column":38,"nodeType":"Identifier","messageId":"noShadow","endLine":51,"endColumn":46},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":541,"column":13,"nodeType":"Identifier","messageId":"noShadow","endLine":541,"endColumn":16},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":912,"column":41,"nodeType":"Identifier","messageId":"noShadow","endLine":912,"endColumn":44},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":948,"column":9,"nodeType":"Identifier","messageId":"noShadow","endLine":948,"endColumn":12},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":966,"column":13,"nodeType":"Identifier","messageId":"noShadow","endLine":966,"endColumn":16},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":1027,"column":44,"nodeType":"Identifier","messageId":"noShadow","endLine":1027,"endColumn":47},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":1122,"column":44,"nodeType":"Identifier","messageId":"noShadow","endLine":1122,"endColumn":47},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":1400,"column":18,"nodeType":"Identifier","messageId":"noShadow","endLine":1400,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {getAuth} from '@react-native-firebase/auth';\r\nimport {\r\n  getFirestore,\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  updateDoc,\r\n  deleteDoc,\r\n  addDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  limit,\r\n  getDocs,\r\n  serverTimestamp,\r\n  arrayRemove,\r\n  writeBatch,\r\n  FirebaseFirestoreTypes,\r\n} from '@react-native-firebase/firestore';\r\nimport {Task, SubTask} from 'shared/types/taskTypes';\r\nimport notificationService from './NotificationService';\r\nimport axios from 'axios';\r\nimport Config from 'react-native-config';\r\n\r\nexport class TaskService {\r\n  private tasksCollection = collection(\r\n    getFirestore(),\r\n    'tasks',\r\n  ) as FirebaseFirestoreTypes.CollectionReference<Task>;\r\n  /**\r\n   * Get all tasks for the current user (excluding team tasks)\r\n   *\r\n   */\r\n  async getTasks(): Promise<Task[]> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      const tasksSnapshot = await getDocs(\r\n        query(\r\n          this.tasksCollection,\r\n          where('userId', '==', userId),\r\n          where('isDuoTask', '!=', true), // Exclude team tasks\r\n          orderBy('isDuoTask'), // Required for using the != filter\r\n          orderBy('dueDate', 'asc'),\r\n        ),\r\n      );\r\n\r\n      return tasksSnapshot.docs.map((doc: any) => ({\r\n        id: doc.id,\r\n        ...doc.data(),\r\n      })) as Task[];\r\n    } catch (error) {\r\n      console.log('TaskService :: getTasks() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getTaskSuggestion() {\r\n    try {\r\n      const tasks = await this.getTasks();\r\n      const tasksTitles = tasks.map(task => task.title);\r\n      console.log('tasksTitles', tasksTitles);\r\n      const payload = {\r\n        messages: [\r\n          {\r\n        role: 'user',\r\n        content: `You are an AI assistant that suggests new tasks for a user to help improve their life. Here are the user's previous tasks:\\n${tasksTitles.map((ele, index) => `${index + 1}. ${ele}`).join('\\n')}\r\n    Suggest a new, relevant task that is not a duplicate of the above. If you can't infer a new task, suggest a random but valuable task for a normal human being's growth.\r\n    Respond ONLY with the task title and a brief description, separated by \"|\". The title should be concise (3 to 7 words). Do not include any extra text or explanation.`,\r\n          },\r\n        ],\r\n        model: 'openai/gpt-oss-20b',\r\n        temperature: 1,\r\n        max_completion_tokens: 8192,\r\n        top_p: 1,\r\n        stream: false,\r\n        reasoning_effort: 'medium',\r\n        stop: null,\r\n      };\r\n      console.log('payload', payload);\r\n      const response = await axios.post(\r\n        `https://api.groq.com/openai/v1/chat/completions`,\r\n        payload,\r\n        {\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n            Authorization: `Bearer ${Config.GROQ_API_KEY}`,\r\n          },\r\n        },\r\n      );\r\n      const aiSuggestedTask = response.data.choices[0].message.content;\r\n      return aiSuggestedTask;\r\n    } catch (error) {\r\n      console.log('TaskService :: getTaskSugesstions() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a new task\r\n   */\r\n  async addTask(task: Omit<Task, 'id'>): Promise<string> {\r\n    try {\r\n      console.log(\r\n        `TaskService :: addTask() :: Attempting to add task: \"${task.title}\"`,\r\n      );\r\n      console.log(\r\n        `TaskService :: addTask() :: Task data:`,\r\n        JSON.stringify(task),\r\n      );\r\n\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        console.log('TaskService :: addTask() :: User not authenticated');\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Check if a task with the same name already exists\r\n      console.log(\r\n        `TaskService :: addTask() :: Checking for existing task with name: \"${task.title}\"`,\r\n      );\r\n      const existingTask = await this.findTaskByName(task.title);\r\n      if (existingTask) {\r\n        console.warn(\r\n          `TaskService :: addTask() :: Task with name \"${task.title}\" already exists (ID: ${existingTask.id})`,\r\n        );\r\n        throw new Error(\r\n          `A task with the name \"${task.title}\" already exists. Please use a different name.`,\r\n        );\r\n      }\r\n      console.log(\r\n        `TaskService :: addTask() :: No existing task found with name: \"${task.title}\", proceeding with creation`,\r\n      );\r\n\r\n      // Validate date/time format\r\n      if (task.notify) {\r\n        if (!task.dueDate || !task.dueDate.match(/^\\d{4}-\\d{2}-\\d{2}$/)) {\r\n          console.warn(\r\n            `TaskService :: addTask() :: Invalid dueDate format:`,\r\n            task.dueDate,\r\n          );\r\n        }\r\n        if (!task.dueTime || !task.dueTime.match(/^\\d{2}:\\d{2}$/)) {\r\n          console.warn(\r\n            `TaskService :: addTask() :: Invalid dueTime format:`,\r\n            task.dueTime,\r\n          );\r\n        }\r\n\r\n        console.log(\r\n          `TaskService :: addTask() :: Task due date/time: ${task.dueDate} ${task.dueTime}`,\r\n        );\r\n      }\r\n\r\n      // Ensure task contains all required fields\r\n      if (task.notify && (!task.dueDate || !task.dueTime)) {\r\n        console.warn(\r\n          `TaskService :: addTask() :: Task has notify enabled but missing date/time:`,\r\n          JSON.stringify(task),\r\n        );\r\n      }\r\n\r\n      const taskWithUser = {\r\n        ...task,\r\n        userId,\r\n        createdAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp(),\r\n        isDuoTask: task.isDuoTask !== undefined ? task.isDuoTask : false,\r\n      };\r\n\r\n      console.log(\r\n        `TaskService :: addTask() :: Adding task to Firestore, notify: ${\r\n          task.notify ? 'Yes' : 'No'\r\n        }, isDuoTask: ${taskWithUser.isDuoTask ? 'Yes' : 'No'}`,\r\n      );\r\n      const docRef = await addDoc(this.tasksCollection, taskWithUser);\r\n      console.log(\r\n        `TaskService :: addTask() :: Task added with ID: ${docRef.id}`,\r\n      );\r\n\r\n      // Schedule notification if needed\r\n      if (task.notify) {\r\n        console.log(\r\n          `TaskService :: addTask() :: Scheduling notification for task: ${docRef.id}`,\r\n        );\r\n        const taskWithId = {...taskWithUser, id: docRef.id} as Task;\r\n\r\n        try {\r\n          const notificationId =\r\n            await notificationService.scheduleTaskNotification(taskWithId);\r\n\r\n          if (notificationId) {\r\n            console.log(\r\n              `TaskService :: addTask() :: Notification scheduled successfully, ID: ${notificationId}`,\r\n            );\r\n            // Update the task with the notification ID\r\n            await updateDoc(doc(this.tasksCollection, docRef.id), {\r\n              notificationId: notificationId,\r\n            });\r\n            console.log(\r\n              `TaskService :: addTask() :: Updated task with notification ID`,\r\n            );\r\n          } else {\r\n            console.warn(\r\n              `TaskService :: addTask() :: Failed to schedule notification for task: ${docRef.id}`,\r\n            );\r\n          }\r\n        } catch (notificationError) {\r\n          console.error(\r\n            `TaskService :: addTask() :: Error scheduling notification:`,\r\n            notificationError,\r\n          );\r\n        }\r\n      }\r\n\r\n      console.log(\r\n        `TaskService :: addTask() :: Successfully completed task creation: \"${task.title}\" (ID: ${docRef.id})`,\r\n      );\r\n      return docRef.id;\r\n    } catch (error) {\r\n      console.log('TaskService :: addTask() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update an existing task\r\n   */\r\n  async updateTask(taskId: string, taskData: Partial<Task>): Promise<void> {\r\n    try {\r\n      console.log(\r\n        `TaskService :: updateTask() :: Attempting to update task with ID: ${taskId}`,\r\n      );\r\n      console.log(\r\n        `TaskService :: updateTask() :: Update data:`,\r\n        JSON.stringify(taskData),\r\n      );\r\n\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        console.log('TaskService :: updateTask() :: User not authenticated');\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Verify task belongs to current user\r\n      console.log(\r\n        `TaskService :: updateTask() :: Verifying task ownership for user: ${userId}`,\r\n      );\r\n      const taskDoc = await getDoc(doc(this.tasksCollection, taskId));\r\n\r\n      if (!taskDoc.exists()) {\r\n        console.log(\r\n          `TaskService :: updateTask() :: Task does not exist: ${taskId}`,\r\n        );\r\n        throw new Error('Task not found or unauthorized');\r\n      }\r\n\r\n      if (taskDoc.data()?.userId !== userId) {\r\n        console.log(\r\n          `TaskService :: updateTask() :: Unauthorized task access. Owner: ${\r\n            taskDoc.data()?.userId\r\n          }, Requester: ${userId}`,\r\n        );\r\n        throw new Error('Task not found or unauthorized');\r\n      }\r\n\r\n      const existingTask = {id: taskId, ...taskDoc.data()} as Task;\r\n      console.log(\r\n        `TaskService :: updateTask() :: Found task: \"${existingTask.title}\"`,\r\n      );\r\n\r\n      // Log if notification settings are changing\r\n      if (taskData.notify !== undefined) {\r\n        console.log(\r\n          `Notification setting changing from ${existingTask.notify} to ${taskData.notify}`,\r\n        );\r\n      }\r\n\r\n      // If date or time is changing, log it\r\n      if (\r\n        taskData.dueDate !== undefined &&\r\n        taskData.dueDate !== existingTask.dueDate\r\n      ) {\r\n        console.log(\r\n          `Due date changing from ${existingTask.dueDate} to ${taskData.dueDate}`,\r\n        );\r\n      }\r\n\r\n      if (\r\n        taskData.dueTime !== undefined &&\r\n        taskData.dueTime !== existingTask.dueTime\r\n      ) {\r\n        console.log(\r\n          `Due time changing from ${existingTask.dueTime} to ${taskData.dueTime}`,\r\n        );\r\n      }\r\n\r\n      // Cancel existing notification if it exists\r\n      if (existingTask.notificationId) {\r\n        console.log(\r\n          'Cancelling existing notification:',\r\n          existingTask.notificationId,\r\n        );\r\n        await notificationService.cancelTaskNotification(\r\n          existingTask.notificationId,\r\n        );\r\n      }\r\n\r\n      // Update the task\r\n      await updateDoc(doc(this.tasksCollection, taskId), {\r\n        ...taskData,\r\n        notificationId: null, // Clear the notification ID as we'll create a new one\r\n        updatedAt: serverTimestamp(),\r\n      });\r\n\r\n      console.log('Task updated in database');\r\n\r\n      // If task is not completed and notifications are enabled, schedule a new notification\r\n      const updatedTask = {\r\n        ...existingTask,\r\n        ...taskData,\r\n        id: taskId,\r\n      } as Task;\r\n\r\n      if (updatedTask.notify && !updatedTask.completed) {\r\n        console.log('Scheduling new notification for updated task');\r\n        try {\r\n          const notificationId =\r\n            await notificationService.scheduleTaskNotification(updatedTask);\r\n\r\n          if (notificationId) {\r\n            console.log('New notification scheduled with ID:', notificationId);\r\n            await updateDoc(doc(this.tasksCollection, taskId), {\r\n              notificationId: notificationId,\r\n            });\r\n          } else {\r\n            console.warn('Failed to schedule notification for updated task');\r\n          }\r\n        } catch (notificationError) {\r\n          console.error(\r\n            'Error scheduling notification for updated task:',\r\n            notificationError,\r\n          );\r\n        }\r\n      } else {\r\n        console.log(\r\n          'Task not eligible for notification: notify=',\r\n          updatedTask.notify,\r\n          'completed=',\r\n          updatedTask.completed,\r\n        );\r\n      }\r\n    } catch (error) {\r\n      console.log('TaskService :: updateTask() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggle task completion status\r\n   */\r\n  async toggleTaskCompletion(taskId: string): Promise<void> {\r\n    try {\r\n      console.log(\r\n        `TaskService :: toggleTaskCompletion() :: Attempting to toggle completion for task with ID: ${taskId}`,\r\n      );\r\n\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        console.log(\r\n          'TaskService :: toggleTaskCompletion() :: User not authenticated',\r\n        );\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Get current task data\r\n      console.log(\r\n        `TaskService :: toggleTaskCompletion() :: Verifying task ownership for user: ${userId}`,\r\n      );\r\n      const taskDoc = await getDoc(doc(this.tasksCollection, taskId));\r\n\r\n      if (!taskDoc.exists()) {\r\n        console.log(\r\n          `TaskService :: toggleTaskCompletion() :: Task does not exist: ${taskId}`,\r\n        );\r\n        throw new Error('Task not found or unauthorized');\r\n      }\r\n\r\n      if (taskDoc.data()?.userId !== userId) {\r\n        console.log(\r\n          `TaskService :: toggleTaskCompletion() :: Unauthorized task access. Owner: ${\r\n            taskDoc.data()?.userId\r\n          }, Requester: ${userId}`,\r\n        );\r\n        throw new Error('Task not found or unauthorized');\r\n      }\r\n\r\n      const existingTask = {id: taskId, ...taskDoc.data()} as Task;\r\n      const currentStatus = existingTask.completed || false;\r\n      console.log(\r\n        `TaskService :: toggleTaskCompletion() :: Found task: \"${existingTask.title}\", current status: ${currentStatus}`,\r\n      );\r\n\r\n      // If task has notification and is being marked as completed, cancel it\r\n      if (!currentStatus && existingTask.notificationId) {\r\n        await notificationService.cancelTaskNotification(\r\n          existingTask.notificationId,\r\n        );\r\n      }\r\n\r\n      // Toggle completion status\r\n      await updateDoc(doc(this.tasksCollection, taskId), {\r\n        completed: !currentStatus,\r\n        notificationId: !currentStatus ? null : existingTask.notificationId, // Clear notification ID if marking as completed\r\n        updatedAt: serverTimestamp(),\r\n      });\r\n\r\n      // If task is being marked as not completed and notifications are enabled, reschedule\r\n      if (currentStatus && existingTask.notify) {\r\n        const updatedTask = {...existingTask, completed: false} as Task;\r\n        const notificationId =\r\n          await notificationService.scheduleTaskNotification(updatedTask);\r\n        if (notificationId) {\r\n          await updateDoc(doc(this.tasksCollection, taskId), {\r\n            notificationId: notificationId,\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.log('TaskService :: toggleTaskCompletion() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a task\r\n   */\r\n  async deleteTask(taskId: string): Promise<void> {\r\n    try {\r\n      console.log(\r\n        `TaskService :: deleteTask() :: Attempting to delete task with ID: ${taskId}`,\r\n      );\r\n\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        console.log('TaskService :: deleteTask() :: User not authenticated');\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Verify task belongs to current user\r\n      console.log(\r\n        `TaskService :: deleteTask() :: Verifying task ownership for user: ${userId}`,\r\n      );\r\n      const taskDoc = await getDoc(doc(this.tasksCollection, taskId));\r\n\r\n      if (!taskDoc.exists()) {\r\n        console.log(\r\n          `TaskService :: deleteTask() :: Task does not exist: ${taskId}`,\r\n        );\r\n        throw new Error('Task not found or unauthorized');\r\n      }\r\n\r\n      if (taskDoc.data()?.userId !== userId) {\r\n        console.log(\r\n          `TaskService :: deleteTask() :: Unauthorized task access. Owner: ${\r\n            taskDoc.data()?.userId\r\n          }, Requester: ${userId}`,\r\n        );\r\n        throw new Error('Task not found or unauthorized');\r\n      }\r\n\r\n      const existingTask = taskDoc.data() as Task;\r\n      console.log(\r\n        `TaskService :: deleteTask() :: Task found: \"${existingTask.title}\"`,\r\n      );\r\n\r\n      // Cancel the notification if it exists\r\n      if (existingTask.notificationId) {\r\n        console.log(\r\n          `TaskService :: deleteTask() :: Cancelling notification: ${existingTask.notificationId}`,\r\n        );\r\n        await notificationService.cancelTaskNotification(\r\n          existingTask.notificationId,\r\n        );\r\n      }\r\n\r\n      await deleteDoc(doc(this.tasksCollection, taskId));\r\n      console.log(\r\n        `TaskService :: deleteTask() :: Successfully deleted task with ID: ${taskId}`,\r\n      );\r\n    } catch (error) {\r\n      console.log('TaskService :: deleteTask() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find a task by its name\r\n   * @param taskName The name/title of the task to find\r\n   * @returns The task if found, null otherwise\r\n   */\r\n  async findTaskByName(taskName: string): Promise<Task | null> {\r\n    try {\r\n      console.log(\r\n        `TaskService :: findTaskByName() :: Looking for task with name: \"${taskName}\"`,\r\n      );\r\n\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        console.log(\r\n          'TaskService :: findTaskByName() :: User not authenticated',\r\n        );\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Find tasks with the given name\r\n      console.log(\r\n        `TaskService :: findTaskByName() :: Querying Firestore with userId=${userId}, title=\"${taskName}\"`,\r\n      );\r\n\r\n      const tasksSnapshot = await getDocs(\r\n        query(\r\n          this.tasksCollection,\r\n          where('userId', '==', userId),\r\n          where('title', '==', taskName),\r\n          limit(1), // Limit to one result\r\n        ),\r\n      );\r\n\r\n      if (tasksSnapshot.empty) {\r\n        console.log(\r\n          `TaskService :: findTaskByName() :: No task found with name: \"${taskName}\"`,\r\n        );\r\n        return null;\r\n      }\r\n\r\n      // Return the first matching task\r\n      const doc = tasksSnapshot.docs[0];\r\n      console.log(\r\n        `TaskService :: findTaskByName() :: Found task with ID: ${doc.id}`,\r\n      );\r\n\r\n      return {\r\n        id: doc.id,\r\n        ...doc.data(),\r\n      } as Task;\r\n    } catch (error) {\r\n      console.log('TaskService :: findTaskByName() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a task by its name\r\n   */\r\n  async deleteTaskByName(taskName: string): Promise<void> {\r\n    try {\r\n      console.log(\r\n        `TaskService :: deleteTaskByName() :: Attempting to delete task: \"${taskName}\"`,\r\n      );\r\n\r\n      const task = await this.findTaskByName(taskName);\r\n      if (!task) {\r\n        console.log(\r\n          `TaskService :: deleteTaskByName() :: Task not found: \"${taskName}\"`,\r\n        );\r\n        throw new Error(`Task with name \"${taskName}\" not found`);\r\n      }\r\n\r\n      console.log(\r\n        `TaskService :: deleteTaskByName() :: Found task with ID: ${task.id}, proceeding with deletion`,\r\n      );\r\n\r\n      // Use the existing deleteTask method with the found ID\r\n      await this.deleteTask(task.id);\r\n\r\n      console.log(\r\n        `TaskService :: deleteTaskByName() :: Successfully deleted task: \"${taskName}\" (ID: ${task.id})`,\r\n      );\r\n    } catch (error) {\r\n      console.log('TaskService :: deleteTaskByName() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a task by its name\r\n   */\r\n  async updateTaskByName(\r\n    taskName: string,\r\n    taskData: Partial<Task>,\r\n  ): Promise<void> {\r\n    try {\r\n      console.log(\r\n        `TaskService :: updateTaskByName() :: Attempting to update task: \"${taskName}\"`,\r\n      );\r\n      console.log(\r\n        `TaskService :: updateTaskByName() :: Update data:`,\r\n        JSON.stringify(taskData),\r\n      );\r\n\r\n      const task = await this.findTaskByName(taskName);\r\n      if (!task) {\r\n        console.log(\r\n          `TaskService :: updateTaskByName() :: Task not found: \"${taskName}\"`,\r\n        );\r\n        throw new Error(`Task with name \"${taskName}\" not found`);\r\n      }\r\n\r\n      console.log(\r\n        `TaskService :: updateTaskByName() :: Found task with ID: ${task.id}, proceeding with update`,\r\n      );\r\n\r\n      // Use the existing updateTask method with the found ID\r\n      await this.updateTask(task.id, taskData);\r\n\r\n      console.log(\r\n        `TaskService :: updateTaskByName() :: Successfully updated task: \"${taskName}\" (ID: ${task.id})`,\r\n      );\r\n    } catch (error) {\r\n      console.log('TaskService :: updateTaskByName() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggle task completion status by task name\r\n   */\r\n  async toggleTaskCompletionByName(taskName: string): Promise<void> {\r\n    try {\r\n      console.log(\r\n        `TaskService :: toggleTaskCompletionByName() :: Attempting to toggle completion for task: \"${taskName}\"`,\r\n      );\r\n\r\n      const task = await this.findTaskByName(taskName);\r\n      if (!task) {\r\n        console.log(\r\n          `TaskService :: toggleTaskCompletionByName() :: Task not found: \"${taskName}\"`,\r\n        );\r\n        throw new Error(`Task with name \"${taskName}\" not found`);\r\n      }\r\n\r\n      console.log(\r\n        `TaskService :: toggleTaskCompletionByName() :: Found task with ID: ${task.id}, current completion status: ${task.completed}`,\r\n      );\r\n\r\n      // Use the existing toggleTaskCompletion method with the found ID\r\n      await this.toggleTaskCompletion(task.id);\r\n\r\n      console.log(\r\n        `TaskService :: toggleTaskCompletionByName() :: Successfully toggled completion for task: \"${taskName}\" (ID: ${task.id})`,\r\n      );\r\n    } catch (error) {\r\n      console.log('TaskService :: toggleTaskCompletionByName() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a team task with multiple collaborators\r\n   * @param task The task data\r\n   * @returns The task ID\r\n   */\r\n  async createDuoTask(task: Omit<Task, 'id'>): Promise<string> {\r\n    try {\r\n      console.log(\r\n        `TaskService :: createDuoTask() :: Creating team task: \"${task.title}\"`,\r\n      );\r\n\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        console.log('TaskService :: createDuoTask() :: User not authenticated');\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Check if collaborators is provided and valid\r\n      if (!task.collaborators || task.collaborators.length < 2) {\r\n        console.warn(\r\n          'TaskService :: createDuoTask() :: Missing or invalid collaborators',\r\n        );\r\n        throw new Error('Team task requires at least two collaborators');\r\n      }\r\n\r\n      // Verify current user is one of the collaborators\r\n      if (!task.collaborators.includes(userId)) {\r\n        console.warn(\r\n          'TaskService :: createDuoTask() :: Current user not in collaborators list',\r\n        );\r\n        throw new Error('Current user must be a collaborator');\r\n      }\r\n\r\n      // Create task with team task fields\r\n      const teamTask = {\r\n        ...task,\r\n        userId, // Main owner is current user\r\n        isDuoTask: true,\r\n        collaborationStatus: 'pending',\r\n        createdAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp(),\r\n        lastUpdatedBy: userId,\r\n        progress:\r\n          task.subtasks && task.subtasks.length > 0\r\n            ? Math.round(\r\n                (task.subtasks.filter(s => s.completed).length /\r\n                  task.subtasks.length) *\r\n                  100,\r\n              )\r\n            : 0,\r\n      };\r\n\r\n      console.log(\r\n        `TaskService :: createDuoTask() :: Adding team task to Firestore`,\r\n      );\r\n      const docRef = await addDoc(this.tasksCollection, teamTask);\r\n      console.log(\r\n        `TaskService :: createDuoTask() :: Team task added with ID: ${docRef.id}`,\r\n      );\r\n\r\n      // Create notifications for collaborators (except current user)\r\n      const otherCollaborators = task.collaborators.filter(id => id !== userId);\r\n\r\n      for (const collaboratorId of otherCollaborators) {\r\n        await addDoc(collection(getFirestore(), 'notifications'), {\r\n          userId: collaboratorId,\r\n          type: 'duo_task_invitation',\r\n          title: 'Team Task Invitation',\r\n          message: `${\r\n            getAuth().currentUser?.displayName || 'Someone'\r\n          } invited you to collaborate on \"${task.title}\"`,\r\n          taskId: docRef.id,\r\n          read: false,\r\n          createdAt: serverTimestamp(),\r\n        });\r\n        console.log(\r\n          `TaskService :: createDuoTask() :: Notification sent to collaborator: ${collaboratorId}`,\r\n        );\r\n      }\r\n\r\n      // Schedule notification if enabled\r\n      if (task.notify) {\r\n        const taskWithId = {...teamTask, id: docRef.id} as Task;\r\n        try {\r\n          console.log(\r\n            `TaskService :: createDuoTask() :: Scheduling notification for task: ${docRef.id}`,\r\n          );\r\n          const notificationId =\r\n            await notificationService.scheduleTaskNotification(taskWithId);\r\n\r\n          if (notificationId) {\r\n            console.log(\r\n              `TaskService :: createDuoTask() :: Notification scheduled successfully, ID: ${notificationId}`,\r\n            );\r\n            // Update the task with the notification ID\r\n            await updateDoc(doc(this.tasksCollection, docRef.id), {\r\n              notificationId: notificationId,\r\n            });\r\n          } else {\r\n            console.warn(\r\n              `TaskService :: createDuoTask() :: Failed to schedule notification for task: ${docRef.id}`,\r\n            );\r\n          }\r\n        } catch (notificationError) {\r\n          console.error(\r\n            `TaskService :: createDuoTask() :: Error scheduling notification:`,\r\n            notificationError,\r\n          );\r\n        }\r\n      }\r\n\r\n      return docRef.id;\r\n    } catch (error) {\r\n      console.error('TaskService :: createDuoTask() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a team task\r\n   */\r\n  async updateDuoTask(taskId: string, task: Partial<Task>): Promise<Task> {\r\n    try {\r\n      console.log(\r\n        `TaskService :: updateDuoTask() :: Updating team task: \"${task.title}\" (ID: ${taskId})`,\r\n      );\r\n\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        console.log('TaskService :: updateDuoTask() :: User not authenticated');\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Verify user is a collaborator\r\n      const taskDoc = await getDoc(doc(this.tasksCollection, taskId));\r\n\r\n      if (!taskDoc.exists()) {\r\n        throw new Error('Task not found');\r\n      }\r\n\r\n      const existingTask = taskDoc.data() as Task;\r\n\r\n      if (!existingTask.collaborators?.includes(userId)) {\r\n        throw new Error('User is not a collaborator on this task');\r\n      }\r\n\r\n      // Update the task\r\n      const updateData = {\r\n        ...task,\r\n        updatedAt: serverTimestamp(),\r\n        lastUpdatedBy: userId,\r\n      };\r\n\r\n      await updateDoc(doc(this.tasksCollection, taskId), updateData);\r\n      console.log(\r\n        `TaskService :: updateDuoTask() :: Team task updated successfully`,\r\n      );\r\n\r\n      // Handle notification updates\r\n      if (task.notify !== undefined && task.dueDate && task.dueTime) {\r\n        // Cancel existing notification\r\n        if (existingTask.notificationId) {\r\n          await notificationService.cancelTaskNotification(\r\n            existingTask.notificationId,\r\n          );\r\n        }\r\n\r\n        // Schedule new notification if enabled\r\n        if (task.notify) {\r\n          const updatedTask = {\r\n            ...existingTask,\r\n            ...task,\r\n            id: taskId,\r\n          } as Task;\r\n\r\n          const notificationId =\r\n            await notificationService.scheduleTaskNotification(updatedTask);\r\n\r\n          if (notificationId) {\r\n            await updateDoc(doc(this.tasksCollection, taskId), {\r\n              notificationId: notificationId,\r\n            });\r\n            console.log(\r\n              `TaskService :: updateDuoTask() :: Updated notification`,\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // Notify collaborators about the update (except current user)\r\n      const collaborators = existingTask.collaborators?.filter(\r\n        id => id !== userId,\r\n      );\r\n\r\n      if (collaborators && collaborators.length > 0) {\r\n        for (const collaboratorId of collaborators) {\r\n          await addDoc(collection(getFirestore(), 'notifications'), {\r\n            userId: collaboratorId,\r\n            type: 'duo_task_update',\r\n            title: 'Team Task Updated',\r\n            message: `${\r\n              getAuth().currentUser?.displayName || 'Your team member'\r\n            } updated task \"${existingTask.title}\"`,\r\n            taskId: taskId,\r\n            read: false,\r\n            createdAt: serverTimestamp(),\r\n          });\r\n        }\r\n        console.log(\r\n          `TaskService :: updateDuoTask() :: Notifications sent to collaborators`,\r\n        );\r\n      }\r\n\r\n      // Return the updated task\r\n      const updatedTaskDoc = await getDoc(doc(this.tasksCollection, taskId));\r\n      return {\r\n        id: taskId,\r\n        ...updatedTaskDoc.data(),\r\n      } as Task;\r\n    } catch (error) {\r\n      console.error('TaskService :: updateDuoTask() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get team tasks where the current user is a collaborator\r\n   */\r\n  async getDuoTasks(): Promise<Task[]> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      console.log(\r\n        `TaskService :: getDuoTasks() :: Fetching team tasks for user: ${userId}`,\r\n      );\r\n      const teamTasksSnapshot = await getDocs(\r\n        query(\r\n          this.tasksCollection,\r\n          where('collaborators', 'array-contains', userId),\r\n          where('isDuoTask', '==', true),\r\n          orderBy('dueDate', 'asc'),\r\n        ),\r\n      );\r\n\r\n      console.log(\r\n        `TaskService :: getDuoTasks() :: Found ${teamTasksSnapshot.size} team tasks`,\r\n      );\r\n      return teamTasksSnapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data(),\r\n      })) as Task[];\r\n    } catch (error) {\r\n      console.log('TaskService :: getDuoTasks() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get team task invitations pending for the current user\r\n   */\r\n  async getPendingDuoTaskInvitations(): Promise<Task[]> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Get notifications for this user that are team task invitations and unread\r\n      const notificationsSnapshot = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'notifications'),\r\n          where('userId', '==', userId),\r\n          where('type', '==', 'duo_task_invitation'),\r\n          where('read', '==', false),\r\n        ),\r\n      );\r\n\r\n      if (notificationsSnapshot.empty) {\r\n        return [];\r\n      }\r\n\r\n      // Extract task IDs from notifications\r\n      const taskIds = notificationsSnapshot.docs.map(\r\n        doc => doc.data().taskId as string,\r\n      );\r\n\r\n      // If no task IDs, return empty array\r\n      if (taskIds.length === 0) {\r\n        return [];\r\n      }\r\n\r\n      // Get the tasks\r\n      const tasks: Task[] = [];\r\n      for (const chunkIds of this.chunkArray(taskIds, 10)) {\r\n        // Firestore \"in\" queries are limited to 10 values\r\n        const tasksSnapshot = await getDocs(\r\n          query(this.tasksCollection, where('__name__', 'in', chunkIds)),\r\n        );\r\n\r\n        tasks.push(\r\n          ...tasksSnapshot.docs.map(\r\n            doc => ({id: doc.id, ...doc.data()}) as Task,\r\n          ),\r\n        );\r\n      }\r\n\r\n      return tasks;\r\n    } catch (error) {\r\n      console.error('TaskService :: getPendingDuoTaskInvitations() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Accept a team task invitation\r\n   */\r\n  async acceptDuoTaskInvitation(taskId: string): Promise<void> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      console.log(\r\n        `TaskService :: acceptDuoTaskInvitation() :: User ${userId} accepting task ${taskId}`,\r\n      );\r\n\r\n      // Get the task to verify user is a collaborator\r\n      const taskDoc = await getDoc(doc(this.tasksCollection, taskId));\r\n\r\n      if (!taskDoc.exists()) {\r\n        throw new Error('Task not found');\r\n      }\r\n\r\n      const task = taskDoc.data() as Task;\r\n\r\n      if (!task.collaborators?.includes(userId)) {\r\n        throw new Error('User is not a collaborator on this task');\r\n      }\r\n\r\n      // Update task status\r\n      await updateDoc(doc(this.tasksCollection, taskId), {\r\n        collaborationStatus: 'active',\r\n        updatedAt: serverTimestamp(),\r\n      });\r\n\r\n      console.log(\r\n        `TaskService :: acceptDuoTaskInvitation() :: Updated task status to active`,\r\n      );\r\n\r\n      // Update notification as read\r\n      const notificationsSnapshot = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'notifications'),\r\n          where('userId', '==', userId),\r\n          where('taskId', '==', taskId),\r\n          where('type', '==', 'duo_task_invitation'),\r\n        ),\r\n      );\r\n\r\n      if (!notificationsSnapshot.empty) {\r\n        const batch = writeBatch(getFirestore());\r\n        notificationsSnapshot.docs.forEach(doc => {\r\n          batch.update(doc.ref, {read: true});\r\n        });\r\n        await batch.commit();\r\n        console.log(\r\n          `TaskService :: acceptDuoTaskInvitation() :: Updated notifications as read`,\r\n        );\r\n      }\r\n\r\n      // Notify the task creator\r\n      const notifyUserId = task.userId;\r\n      if (notifyUserId !== userId) {\r\n        await addDoc(collection(getFirestore(), 'notifications'), {\r\n          userId: notifyUserId,\r\n          type: 'duo_task_accepted',\r\n          title: 'Team Task Accepted',\r\n          message: `${\r\n            getAuth().currentUser?.displayName || 'A team member'\r\n          } accepted your invitation to task \"${task.title}\"`,\r\n          taskId: taskId,\r\n          read: false,\r\n          createdAt: serverTimestamp(),\r\n        });\r\n        console.log(\r\n          `TaskService :: acceptDuoTaskInvitation() :: Notification sent to task creator: ${notifyUserId}`,\r\n        );\r\n      }\r\n    } catch (error) {\r\n      console.error('TaskService :: acceptDuoTaskInvitation() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decline a team task invitation\r\n   */\r\n  async rejectDuoTaskInvitation(taskId: string): Promise<void> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      console.log(\r\n        `TaskService :: rejectDuoTaskInvitation() :: User ${userId} declining task ${taskId}`,\r\n      );\r\n\r\n      // Get the task\r\n      const taskDoc = await getDoc(doc(this.tasksCollection, taskId));\r\n\r\n      if (!taskDoc.exists()) {\r\n        throw new Error('Task not found');\r\n      }\r\n\r\n      const task = taskDoc.data() as Task;\r\n\r\n      // Remove the user from collaborators\r\n      const updatedCollaborators =\r\n        task.collaborators?.filter(id => id !== userId) || [];\r\n\r\n      // If only one collaborator left, convert back to regular task\r\n      if (updatedCollaborators.length <= 1) {\r\n        await updateDoc(doc(this.tasksCollection, taskId), {\r\n          isDuoTask: false,\r\n          collaborators: arrayRemove(),\r\n          collaborationStatus: arrayRemove(),\r\n          updatedAt: serverTimestamp(),\r\n          lastUpdatedBy: userId,\r\n        });\r\n        console.log(\r\n          `TaskService :: rejectDuoTaskInvitation() :: Converted task to regular task`,\r\n        );\r\n      } else {\r\n        // Update collaborators list\r\n        await updateDoc(doc(this.tasksCollection, taskId), {\r\n          collaborators: updatedCollaborators,\r\n          updatedAt: serverTimestamp(),\r\n          lastUpdatedBy: userId,\r\n        });\r\n        console.log(\r\n          `TaskService :: rejectDuoTaskInvitation() :: Removed user from collaborators`,\r\n        );\r\n      }\r\n      // Update notification as read\r\n      const notificationsSnapshot = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'notifications'),\r\n          where('userId', '==', userId),\r\n          where('taskId', '==', taskId),\r\n          where('type', '==', 'duo_task_invitation'),\r\n        ),\r\n      );\r\n\r\n      if (!notificationsSnapshot.empty) {\r\n        const batch = writeBatch(getFirestore());\r\n        notificationsSnapshot.docs.forEach(doc => {\r\n          batch.update(doc.ref, {read: true});\r\n        });\r\n        await batch.commit();\r\n        console.log(\r\n          `TaskService :: rejectDuoTaskInvitation() :: Updated notifications as read`,\r\n        );\r\n      }\r\n\r\n      // Notify the task creator\r\n      const notifyUserId = task.userId;\r\n      if (notifyUserId !== userId) {\r\n        await addDoc(collection(getFirestore(), 'notifications'), {\r\n          userId: notifyUserId,\r\n          type: 'duo_task_declined',\r\n          title: 'Team Task Declined',\r\n          message: `${\r\n            getAuth().currentUser?.displayName || 'A team member'\r\n          } declined your invitation to task \"${task.title}\"`,\r\n          taskId: taskId,\r\n          read: false,\r\n          createdAt: serverTimestamp(),\r\n        });\r\n        console.log(\r\n          `TaskService :: rejectDuoTaskInvitation() :: Notification sent to task creator: ${notifyUserId}`,\r\n        );\r\n      }\r\n    } catch (error) {\r\n      console.error('TaskService :: rejectDuoTaskInvitation() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper method to chunk an array into smaller arrays\r\n   * @private\r\n   */\r\n  private chunkArray<T>(array: T[], size: number): T[][] {\r\n    const chunked: T[][] = [];\r\n    let index = 0;\r\n    while (index < array.length) {\r\n      chunked.push(array.slice(index, size + index));\r\n      index += size;\r\n    }\r\n    return chunked;\r\n  }\r\n\r\n  /**\r\n   * Update a subtask in a duo/team task\r\n   * @param taskId The ID of the task\r\n   * @param subtaskId The ID of the subtask to update\r\n   * @param updates The updates to apply to the subtask\r\n   * @returns Promise that resolves when the subtask is updated\r\n   */\r\n  async updateDuoTaskSubtask(\r\n    taskId: string,\r\n    subtaskId: string,\r\n    updates: Partial<SubTask>,\r\n  ): Promise<void> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Verify the task exists and user is a collaborator\r\n      const taskDoc = await getDoc(doc(this.tasksCollection, taskId));\r\n      if (!taskDoc.exists()) {\r\n        throw new Error('Task not found');\r\n      }\r\n\r\n      const task = taskDoc.data() as Task;\r\n      if (!task.collaborators?.includes(userId)) {\r\n        throw new Error('User is not a collaborator on this task');\r\n      }\r\n\r\n      // Find the subtask to update\r\n      if (!task.subtasks || task.subtasks.length === 0) {\r\n        throw new Error('Task has no subtasks');\r\n      }\r\n\r\n      const subtaskIndex = task.subtasks.findIndex(s => s.id === subtaskId);\r\n      if (subtaskIndex === -1) {\r\n        throw new Error('Subtask not found');\r\n      }\r\n\r\n      // Create a new Date object for timestamps instead of using serverTimestamp()\r\n      // since serverTimestamp() is not supported in arrays\r\n      const now = new Date();\r\n\r\n      // Update the subtask\r\n      const updatedSubtasks = [...task.subtasks];\r\n      updatedSubtasks[subtaskIndex] = {\r\n        ...updatedSubtasks[subtaskIndex],\r\n        ...updates,\r\n        completedBy: updates.completed ? userId : undefined,\r\n        completedAt: updates.completed ? now : undefined,\r\n        updatedAt: now,\r\n      };\r\n\r\n      // Calculate the new progress\r\n      const completedCount = updatedSubtasks.filter(s => s.completed).length;\r\n      const progress = Math.round(\r\n        (completedCount / updatedSubtasks.length) * 100,\r\n      );\r\n\r\n      // Update the task\r\n      await updateDoc(doc(this.tasksCollection, taskId), {\r\n        subtasks: updatedSubtasks,\r\n        progress,\r\n        updatedAt: serverTimestamp(),\r\n        lastUpdatedBy: userId,\r\n      });\r\n\r\n      // Create a notification for other collaborators\r\n      const otherCollaborators = task.collaborators.filter(id => id !== userId);\r\n      if (otherCollaborators.length > 0) {\r\n        const batch = writeBatch(getFirestore());\r\n        const currentUserName =\r\n          getAuth().currentUser?.displayName || 'A team member';\r\n        const subtaskTitle = updatedSubtasks[subtaskIndex].title;\r\n\r\n        for (const collaboratorId of otherCollaborators) {\r\n          const notificationRef = doc(\r\n            collection(getFirestore(), 'notifications'),\r\n          );\r\n          batch.set(notificationRef, {\r\n            userId: collaboratorId,\r\n            type: 'subtask_update',\r\n            title: 'Subtask Update',\r\n            message: `${currentUserName} ${\r\n              updates.completed ? 'completed' : 'updated'\r\n            } the subtask \"${subtaskTitle}\"`,\r\n            taskId: taskId,\r\n            subtaskId: subtaskId,\r\n            read: false,\r\n            createdAt: serverTimestamp(),\r\n          });\r\n        }\r\n\r\n        await batch.commit();\r\n      }\r\n\r\n      console.log(\r\n        `TaskService :: updateDuoTaskSubtask() :: Subtask ${subtaskId} updated successfully`,\r\n      );\r\n    } catch (error) {\r\n      console.error('TaskService :: updateDuoTaskSubtask() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a subtask to a duo/team task\r\n   * @param taskId The ID of the task\r\n   * @param subtask The subtask to add\r\n   * @returns Promise that resolves when the subtask is added\r\n   */\r\n  async addDuoTaskSubtask(\r\n    taskId: string,\r\n    subtask: Omit<SubTask, 'id' | 'createdAt' | 'updatedAt'>,\r\n  ): Promise<void> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Verify the task exists and user is a collaborator\r\n      const taskDoc = await getDoc(doc(this.tasksCollection, taskId));\r\n      if (!taskDoc.exists()) {\r\n        throw new Error('Task not found');\r\n      }\r\n\r\n      const task = taskDoc.data() as Task;\r\n      if (!task.collaborators?.includes(userId)) {\r\n        throw new Error('User is not a collaborator on this task');\r\n      }\r\n\r\n      // Create a new Date object for timestamps\r\n      const now = new Date();\r\n\r\n      // Create a new subtask with ID and timestamps\r\n      const newSubtask: SubTask = {\r\n        id: this.generateUUID(),\r\n        ...subtask,\r\n        createdAt: now,\r\n        updatedAt: now,\r\n      };\r\n\r\n      // Add the subtask to the task\r\n      const updatedSubtasks = task.subtasks\r\n        ? [...task.subtasks, newSubtask]\r\n        : [newSubtask];\r\n\r\n      // Calculate the new progress\r\n      const completedCount = updatedSubtasks.filter(s => s.completed).length;\r\n      const progress = Math.round(\r\n        (completedCount / updatedSubtasks.length) * 100,\r\n      );\r\n\r\n      // Update the task\r\n      await updateDoc(doc(this.tasksCollection, taskId), {\r\n        subtasks: updatedSubtasks,\r\n        progress,\r\n        updatedAt: serverTimestamp(),\r\n        lastUpdatedBy: userId,\r\n      });\r\n\r\n      // Create a notification for other collaborators\r\n      const otherCollaborators = task.collaborators.filter(id => id !== userId);\r\n      if (otherCollaborators.length > 0) {\r\n        const batch = writeBatch(getFirestore());\r\n        const currentUserName =\r\n          getAuth().currentUser?.displayName || 'A team member';\r\n\r\n        for (const collaboratorId of otherCollaborators) {\r\n          const notificationRef = doc(\r\n            collection(getFirestore(), 'notifications'),\r\n          );\r\n          batch.set(notificationRef, {\r\n            userId: collaboratorId,\r\n            type: 'subtask_added',\r\n            title: 'New Subtask',\r\n            message: `${currentUserName} added a new subtask \"${newSubtask.title}\"`,\r\n            taskId: taskId,\r\n            subtaskId: newSubtask.id,\r\n            read: false,\r\n            createdAt: serverTimestamp(),\r\n          });\r\n        }\r\n\r\n        await batch.commit();\r\n      }\r\n\r\n      console.log(\r\n        `TaskService :: addDuoTaskSubtask() :: Subtask added successfully to task ${taskId}`,\r\n      );\r\n    } catch (error) {\r\n      console.error('TaskService :: addDuoTaskSubtask() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get messages for a duo/team task\r\n   * @param taskId The ID of the task\r\n   * @returns Promise that resolves with the messages\r\n   */\r\n  async getDuoTaskMessages(taskId: string): Promise<any[]> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Verify the task exists and user is a collaborator\r\n      const taskDoc = await getDoc(doc(this.tasksCollection, taskId));\r\n      if (!taskDoc.exists()) {\r\n        throw new Error('Task not found');\r\n      }\r\n\r\n      const task = taskDoc.data() as Task;\r\n      if (!task.collaborators?.includes(userId)) {\r\n        throw new Error('User is not a collaborator on this task');\r\n      }\r\n\r\n      // Get the messages for this task\r\n      const messagesSnapshot = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'taskMessages'),\r\n          where('taskId', '==', taskId),\r\n          orderBy('createdAt', 'asc'),\r\n        ),\r\n      );\r\n\r\n      // Process the messages with user info\r\n      const messages = [];\r\n      for (const doc of messagesSnapshot.docs) {\r\n        const messageData = doc.data();\r\n        let userData = {displayName: 'Unknown User'};\r\n\r\n        try {\r\n          const userDoc = await getDoc(\r\n            doc(collection(getFirestore(), 'users'), messageData.userId),\r\n          );\r\n          if (userDoc.exists()) {\r\n            userData = userDoc.data() || userData;\r\n          }\r\n        } catch (e) {\r\n          console.error('Error fetching user data for message:', e);\r\n        }\r\n\r\n        messages.push({\r\n          id: doc.id,\r\n          ...messageData,\r\n          user: {\r\n            id: messageData.userId,\r\n            displayName:\r\n              userData.displayName || userData.email || 'Unknown User',\r\n            photoURL: userData.photoURL || null,\r\n          },\r\n          isCurrentUser: messageData.userId === userId,\r\n        });\r\n      }\r\n\r\n      return messages;\r\n    } catch (error) {\r\n      console.error('TaskService :: getDuoTaskMessages() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a message for a duo/team task\r\n   * @param taskId The ID of the task\r\n   * @param message The message to send\r\n   * @returns Promise that resolves when the message is sent\r\n   */\r\n  async sendDuoTaskMessage(taskId: string, message: string): Promise<void> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Verify the task exists and user is a collaborator\r\n      const taskDoc = await getDoc(doc(this.tasksCollection, taskId));\r\n      if (!taskDoc.exists()) {\r\n        throw new Error('Task not found');\r\n      }\r\n\r\n      const task = taskDoc.data() as Task;\r\n      if (!task.collaborators?.includes(userId)) {\r\n        throw new Error('User is not a collaborator on this task');\r\n      }\r\n\r\n      // Add the message\r\n      await addDoc(collection(getFirestore(), 'taskMessages'), {\r\n        taskId,\r\n        userId,\r\n        message,\r\n        createdAt: serverTimestamp(),\r\n      });\r\n\r\n      // Create notifications for other collaborators\r\n      const otherCollaborators = task.collaborators.filter(id => id !== userId);\r\n      if (otherCollaborators.length > 0) {\r\n        const batch = writeBatch(getFirestore());\r\n        const currentUserName =\r\n          getAuth().currentUser?.displayName || 'A team member';\r\n\r\n        for (const collaboratorId of otherCollaborators) {\r\n          const notificationRef = doc(\r\n            collection(getFirestore(), 'notifications'),\r\n          );\r\n          batch.set(notificationRef, {\r\n            userId: collaboratorId,\r\n            type: 'task_message',\r\n            title: 'New Message',\r\n            message: `${currentUserName} sent a message in task \"${task.title}\"`,\r\n            taskId: taskId,\r\n            read: false,\r\n            createdAt: serverTimestamp(),\r\n          });\r\n        }\r\n\r\n        await batch.commit();\r\n      }\r\n\r\n      console.log(\r\n        `TaskService :: sendDuoTaskMessage() :: Message sent successfully for task ${taskId}`,\r\n      );\r\n    } catch (error) {\r\n      console.error('TaskService :: sendDuoTaskMessage() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper method to generate a UUID\r\n   * @private\r\n   */\r\n  private generateUUID(): string {\r\n    // Use a timestamp-based prefix to ensure uniqueness\r\n    const timestamp = Date.now().toString(36);\r\n\r\n    // Generate random segments\r\n    const randomSegment1 = Math.random().toString(36).substring(2, 15);\r\n    const randomSegment2 = Math.random().toString(36).substring(2, 15);\r\n\r\n    // Combine timestamp and random segments to form a UUID-like string\r\n    return `${timestamp}-${randomSegment1}-${randomSegment2}`;\r\n  }\r\n\r\n  /**\r\n   * Get a single task by ID\r\n   */\r\n  async getTaskById(taskId: string): Promise<Task | null> {\r\n    try {\r\n      const userId = getAuth().currentUser?.uid;\r\n      if (!userId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      console.log(\r\n        `TaskService :: getTaskById() :: Fetching task with ID: ${taskId}`,\r\n      );\r\n\r\n      const taskDoc = await getDoc(doc(this.tasksCollection, taskId));\r\n\r\n      if (!taskDoc.exists()) {\r\n        console.log(\r\n          `TaskService :: getTaskById() :: Task not found: ${taskId}`,\r\n        );\r\n        return null;\r\n      }\r\n\r\n      const task = {\r\n        id: taskId,\r\n        ...taskDoc.data(),\r\n      } as Task;\r\n\r\n      // Verify user has access to this task\r\n      if (!task.isDuoTask || !task.collaborators?.includes(userId)) {\r\n        if (task.userId !== userId) {\r\n          console.log(\r\n            `TaskService :: getTaskById() :: User does not have access to task: ${taskId}`,\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n\r\n      console.log(\r\n        `TaskService :: getTaskById() :: Successfully retrieved task: ${taskId}`,\r\n      );\r\n      return task;\r\n    } catch (error) {\r\n      console.error('TaskService :: getTaskById() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\UserService.ts","messages":[{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":24,"column":13,"nodeType":"Identifier","messageId":"noShadow","endLine":24,"endColumn":16},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":239,"column":33,"nodeType":"Identifier","messageId":"noShadow","endLine":239,"endColumn":36},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":254,"column":36,"nodeType":"Identifier","messageId":"noShadow","endLine":254,"endColumn":39},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":269,"column":32,"nodeType":"Identifier","messageId":"noShadow","endLine":269,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {getAuth} from '@react-native-firebase/auth';\r\nimport {\r\n  getFirestore,\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  updateDoc,\r\n  query,\r\n  where,\r\n  limit,\r\n  getDocs,\r\n} from '@react-native-firebase/firestore';\r\nimport {AuthResponse} from 'shared/types/firebase';\r\n\r\nexport class UserService {\r\n  async getNameUsernamestring(): Promise<{fullName: string; username: string}> {\r\n    try {\r\n      const userQuery = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'users'),\r\n          where('email', '==', getAuth().currentUser?.email),\r\n        ),\r\n      );\r\n      const doc = userQuery.docs[0].data();\r\n      if (doc.fullName && doc.username) {\r\n        return {fullName: doc.fullName, username: doc.username};\r\n      }\r\n      return {fullName: '', username: doc.email};\r\n    } catch (error) {\r\n      console.log('UserService :: getNameUsernamestring() ::', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async checkUsernameIsAvailable(username: string): Promise<AuthResponse> {\r\n    try {\r\n      const user = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'users'),\r\n          where('username', '==', username),\r\n        ),\r\n      );\r\n      return {success: user.empty};\r\n    } catch (error) {\r\n      console.log('UserService :: checkUsernameIsAvailable() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n  async checkEmailIsAvailable(email: string): Promise<AuthResponse> {\r\n    try {\r\n      const user = await getDocs(\r\n        query(collection(getFirestore(), 'users'), where('email', '==', email)),\r\n      );\r\n      return {success: user.empty};\r\n    } catch (error) {\r\n      console.log('UserService :: checkEmailIsAvailable() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n\r\n  async checkUsernameOrEmailRegistered(\r\n    emailOrUsername: string,\r\n  ): Promise<{success: boolean; email?: string; error?: Error}> {\r\n    try {\r\n      const email = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'users'),\r\n          where('email', '==', emailOrUsername),\r\n        ),\r\n      );\r\n      const username = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'users'),\r\n          where('username', '==', emailOrUsername),\r\n        ),\r\n      );\r\n\r\n      if (!email.empty) return {success: true, email: emailOrUsername};\r\n\r\n      if (!username.empty) {\r\n        const emailValue = username.docs[0].data().email;\r\n        return {success: true, email: emailValue};\r\n      }\r\n\r\n      return {success: false};\r\n    } catch (error: any) {\r\n      console.log('UserService :: checkUsernameOrEmailRegistered() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n\r\n  async getUserEmailById(userId: string): Promise<string | null> {\r\n    try {\r\n      const userDoc = await getDoc(\r\n        doc(collection(getFirestore(), 'users'), userId),\r\n      );\r\n\r\n      if (userDoc.exists() && userDoc.data()?.email) {\r\n        return userDoc.data()?.email;\r\n      }\r\n      return null;\r\n    } catch (error) {\r\n      console.log('UserService :: getUserEmailById() ::', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async updateUsername(newUsername: string) {\r\n    try {\r\n      const currentUserId = getAuth().currentUser?.uid;\r\n      const currentUserDoc = await getDoc(\r\n        doc(collection(getFirestore(), 'users'), currentUserId),\r\n      );\r\n      await updateDoc(currentUserDoc.ref, {username: newUsername});\r\n      return {success: true};\r\n    } catch (error) {\r\n      console.log('UserService :: checkUsernameIsAvailable() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n\r\n  async getUserInfoById(userId: string): Promise<{\r\n    email: string | null;\r\n    fullName: string | null;\r\n    username: string | null;\r\n  }> {\r\n    try {\r\n      const userDoc = await getDoc(\r\n        doc(collection(getFirestore(), 'users'), userId),\r\n      );\r\n\r\n      if (userDoc.exists()) {\r\n        const userData = userDoc.data();\r\n        return {\r\n          email: userData?.email || null,\r\n          fullName: userData?.fullName || null,\r\n          username: userData?.username || null,\r\n        };\r\n      }\r\n      return {email: null, fullName: null, username: null};\r\n    } catch (error) {\r\n      console.log('UserService :: getUserInfoById() ::', error);\r\n      return {email: null, fullName: null, username: null};\r\n    }\r\n  }\r\n\r\n  async updateProfilePhoto(photoURI: string): Promise<AuthResponse> {\r\n    try {\r\n      // 1. Update auth user photoURL\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) {\r\n        return {\r\n          success: false,\r\n          error: new Error('No authenticated user found'),\r\n        };\r\n      }\r\n\r\n      // 2. Update the profile\r\n      await currentUser.updateProfile({\r\n        photoURL: photoURI,\r\n      });\r\n\r\n      // 3. Update Firestore user document\r\n      await updateDoc(\r\n        doc(collection(getFirestore(), 'users'), currentUser.uid),\r\n        {\r\n          image: photoURI,\r\n        },\r\n      );\r\n\r\n      return {success: true};\r\n    } catch (error) {\r\n      console.log('UserService :: updateProfilePhoto() ::', error);\r\n      return {success: false, error};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Search for users by username or email\r\n   * @param searchQuery The search query to match against username or email\r\n   * @returns Array of user objects containing id, username, fullName, email, and image\r\n   */\r\n  async searchUsers(searchQuery: string): Promise<\r\n    Array<{\r\n      id: string;\r\n      username: string;\r\n      fullName: string;\r\n      email: string;\r\n      image?: string;\r\n    }>\r\n  > {\r\n    try {\r\n      if (!searchQuery || searchQuery.trim() === '') {\r\n        return [];\r\n      }\r\n\r\n      const currentUserId = getAuth().currentUser?.uid;\r\n      if (!currentUserId) {\r\n        throw new Error('User not authenticated');\r\n      }\r\n\r\n      // Search by email or username containing the query\r\n      const searchQueryLower = searchQuery.toLowerCase();\r\n\r\n      // Get users where email contains the search query\r\n      const emailResults = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'users'),\r\n          where('email', '>=', searchQueryLower),\r\n          where('email', '<=', searchQueryLower + '\\uf8ff'),\r\n          limit(10),\r\n        ),\r\n      );\r\n\r\n      // Get users where username contains the search query\r\n      const usernameResults = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'users'),\r\n          where('username', '>=', searchQueryLower),\r\n          where('username', '<=', searchQueryLower + '\\uf8ff'),\r\n          limit(10),\r\n        ),\r\n      );\r\n\r\n      // Get users where fullName contains the search query\r\n      const nameResults = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'users'),\r\n          where('fullName', '>=', searchQueryLower),\r\n          where('fullName', '<=', searchQueryLower + '\\uf8ff'),\r\n          limit(10),\r\n        ),\r\n      );\r\n\r\n      // Combine and deduplicate results\r\n      const userMap = new Map();\r\n\r\n      // Process email results\r\n      emailResults.docs.forEach(doc => {\r\n        const userData = doc.data();\r\n        if (doc.id !== currentUserId) {\r\n          // Exclude current user\r\n          userMap.set(doc.id, {\r\n            id: doc.id,\r\n            username: userData.username || '',\r\n            fullName: userData.fullName || '',\r\n            email: userData.email || '',\r\n            image: userData.image || null,\r\n          });\r\n        }\r\n      });\r\n\r\n      // Process username results\r\n      usernameResults.docs.forEach(doc => {\r\n        const userData = doc.data();\r\n        if (doc.id !== currentUserId) {\r\n          // Exclude current user\r\n          userMap.set(doc.id, {\r\n            id: doc.id,\r\n            username: userData.username || '',\r\n            fullName: userData.fullName || '',\r\n            email: userData.email || '',\r\n            image: userData.image || null,\r\n          });\r\n        }\r\n      });\r\n\r\n      // Process name results\r\n      nameResults.docs.forEach(doc => {\r\n        const userData = doc.data();\r\n        if (doc.id !== currentUserId) {\r\n          // Exclude current user\r\n          userMap.set(doc.id, {\r\n            id: doc.id,\r\n            username: userData.username || '',\r\n            fullName: userData.fullName || '',\r\n            email: userData.email || '',\r\n            image: userData.image || null,\r\n          });\r\n        }\r\n      });\r\n\r\n      return Array.from(userMap.values());\r\n    } catch (error) {\r\n      console.log('UserService :: searchUsers() ::', error);\r\n      return [];\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\firebase\\LikeCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\firebase\\PostQueryService.ts","messages":[{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'query' is already declared in the upper scope on line 7 column 3.","line":34,"column":23,"nodeType":"Identifier","messageId":"noShadow","endLine":34,"endColumn":33},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":70,"column":23,"nodeType":"Identifier","messageId":"noShadow","endLine":70,"endColumn":26},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":71,"column":26,"nodeType":"Identifier","messageId":"noShadow","endLine":71,"endColumn":29},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":202,"column":65,"nodeType":"Identifier","messageId":"noShadow","endLine":202,"endColumn":68},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":223,"column":21,"nodeType":"Identifier","messageId":"noShadow","endLine":223,"endColumn":24},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":231,"column":18,"nodeType":"Identifier","messageId":"noShadow","endLine":231,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'snapshot' is assigned a value but never used.","line":273,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":273,"endColumn":19},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":297,"column":19,"nodeType":"Identifier","messageId":"noShadow","endLine":297,"endColumn":22},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":298,"column":16,"nodeType":"Identifier","messageId":"noShadow","endLine":298,"endColumn":19},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":380,"column":19,"nodeType":"Identifier","messageId":"noShadow","endLine":380,"endColumn":22},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":381,"column":22,"nodeType":"Identifier","messageId":"noShadow","endLine":381,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {getAuth} from '@react-native-firebase/auth';\r\nimport {\r\n  getFirestore,\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  limit,\r\n  getDocs,\r\n  onSnapshot,\r\n  FirebaseFirestoreTypes,\r\n} from '@react-native-firebase/firestore';\r\nimport {GetPostsResponse} from 'shared/types/firebase';\r\nimport {FirestorePost} from '@/features/Home/types/post';\r\nimport {convertFirestorePost} from 'shared/services/utils';\r\nimport {CommentService} from '../../features/Home/services/CommentService';\r\nimport {SavedPostService} from '../../features/SavedPost/services/SavedPostService';\r\nimport {LikeCache} from './LikeCache';\r\n\r\nexport class PostQueryService {\r\n  private activeListeners: Map<string, () => void> = new Map();\r\n  private queryCache: Map<string, any[]> = new Map();\r\n  private readonly QUERY_CACHE_TTL = 30 * 1000; // 30 seconds TTL\r\n  private queryCacheTimestamps: Map<string, number> = new Map();\r\n\r\n  constructor(\r\n    private commentService: CommentService,\r\n    private savedPostService: SavedPostService,\r\n    private likeCache: LikeCache,\r\n  ) {}\r\n\r\n  private getCacheKey(query: any): string {\r\n    return JSON.stringify(query);\r\n  }\r\n\r\n  private isQueryCacheValid(cacheKey: string): boolean {\r\n    const timestamp = this.queryCacheTimestamps.get(cacheKey);\r\n    return timestamp ? Date.now() - timestamp < this.QUERY_CACHE_TTL : false;\r\n  }\r\n\r\n  subscribeToPostUpdates(callback: (posts: any[]) => void): () => void {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) {\r\n        console.error('Cannot subscribe to posts: User not authenticated');\r\n        return () => {};\r\n      }\r\n\r\n      // Get the user ref - we'll need this for blocked posts\r\n      const userRef = doc(collection(getFirestore(), 'users'), currentUser.uid);\r\n\r\n      // Setup the subscription\r\n      const unsubscribe = onSnapshot(\r\n        query(\r\n          collection(getFirestore(), 'posts'),\r\n          orderBy('timestamp', 'desc'),\r\n          limit(10),\r\n        ),\r\n        async (snapshot: FirebaseFirestoreTypes.QuerySnapshot) => {\r\n          try {\r\n            // Get the latest blocked post IDs on each update\r\n            const userDoc = await getDoc(userRef);\r\n            const blockedPostIds = userDoc.exists()\r\n              ? userDoc.data()?.blockedPostIds || []\r\n              : [];\r\n\r\n            const postsPromises = snapshot.docs\r\n              .filter(doc => !blockedPostIds.includes(doc.id)) // Filter out blocked posts\r\n              .map(async doc => {\r\n                const postData = {id: doc.id, ...doc.data()} as FirestorePost;\r\n                const likedBy = postData.likedBy || [];\r\n                const comments = await this.commentService.getPostComments(\r\n                  doc.ref,\r\n                );\r\n                postData.commentsList = comments;\r\n                postData.comments = comments.length;\r\n                this.likeCache.setPostLikes(doc.id, likedBy);\r\n                const post = convertFirestorePost(postData, currentUser.uid);\r\n                post.isSaved = this.savedPostService.isPostSaved(doc.id);\r\n                return post;\r\n              });\r\n\r\n            const posts = await Promise.all(postsPromises);\r\n            callback(posts);\r\n          } catch (error) {\r\n            console.error(\r\n              'PostQueryService: Error processing posts snapshot:',\r\n              error,\r\n            );\r\n          }\r\n        },\r\n        error => {\r\n          console.error(\r\n            'PostQueryService: Error in posts subscription:',\r\n            error,\r\n          );\r\n        },\r\n      );\r\n\r\n      // Store the unsubscribe function\r\n      this.activeListeners.set('posts', unsubscribe);\r\n      return () => {\r\n        unsubscribe();\r\n        this.activeListeners.delete('posts');\r\n      };\r\n    } catch (error) {\r\n      console.error(\r\n        'PostQueryService: Error setting up posts subscription:',\r\n        error,\r\n      );\r\n      return () => {};\r\n    }\r\n  }\r\n\r\n  async getPosts(\r\n    options: {\r\n      lastVisible?: any;\r\n      limit?: number;\r\n      userId?: string;\r\n      hashtag?: string;\r\n      likedByUser?: string;\r\n      timeRange?: 'day' | 'week' | 'month' | 'year';\r\n    } = {},\r\n  ): Promise<GetPostsResponse> {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) throw new Error('User not authenticated');\r\n\r\n      // Get the user's blocked post IDs\r\n      const userRef = doc(collection(getFirestore(), 'users'), currentUser.uid);\r\n      const userDoc = await getDoc(userRef);\r\n      const blockedPostIds = userDoc.exists()\r\n        ? userDoc.data()?.blockedPostIds || []\r\n        : [];\r\n\r\n      const {\r\n        lastVisible,\r\n        limit: limitCount = 10,\r\n        userId,\r\n        hashtag,\r\n        likedByUser,\r\n        timeRange,\r\n      } = options;\r\n\r\n      const cacheKey = this.getCacheKey({\r\n        lastVisible: lastVisible?.id,\r\n        limit: limitCount,\r\n        userId,\r\n        hashtag,\r\n        likedByUser,\r\n        timeRange,\r\n      });\r\n\r\n      if (this.isQueryCacheValid(cacheKey)) {\r\n        const cachedPosts = this.queryCache.get(cacheKey);\r\n        if (cachedPosts) {\r\n          // Filter out blocked posts from cache\r\n          const filteredPosts = cachedPosts.filter(\r\n            post => !blockedPostIds.includes(post.id),\r\n          );\r\n          return {success: true, posts: filteredPosts, lastVisible};\r\n        }\r\n      }\r\n\r\n      let postsQuery = query(collection(getFirestore(), 'posts'));\r\n\r\n      if (userId) {\r\n        postsQuery = query(\r\n          collection(getFirestore(), 'posts'),\r\n          where('user.id', '==', userId),\r\n        );\r\n      }\r\n\r\n      if (likedByUser) {\r\n        postsQuery = query(\r\n          collection(getFirestore(), 'posts'),\r\n          where('likedBy', 'array-contains', likedByUser),\r\n        );\r\n      }\r\n\r\n      // Special handling for hashtag search\r\n      let postsWithHashtagInDesc: PostType[] = [];\r\n      let hashtagArrayPostIds: Set<string> = new Set();\r\n\r\n      if (hashtag) {\r\n        // If searching by hashtag, we need to handle two queries:\r\n        // 1. Posts with hashtag in the hashtags array\r\n        // 2. Posts with hashtag in the description\r\n\r\n        // First, get posts with hashtag in hashtags array\r\n        const hashtagArrayQuery = query(\r\n          collection(getFirestore(), 'posts'),\r\n          where('hashtags', 'array-contains', hashtag),\r\n          orderBy('timestamp', 'desc'),\r\n          limit(limitCount),\r\n        );\r\n\r\n        const hashtagArraySnapshot = await getDocs(hashtagArrayQuery);\r\n\r\n        const hashtagArrayPosts = hashtagArraySnapshot.docs.map(doc => {\r\n          const data = doc.data();\r\n          hashtagArrayPostIds.add(doc.id); // Track IDs to avoid duplicates\r\n\r\n          return {\r\n            id: doc.id,\r\n            ...data,\r\n          };\r\n        });\r\n\r\n        // Second, look for hashtag in descriptions (only if we didn't fill the limit)\r\n        if (hashtagArrayPosts.length < limitCount) {\r\n          const descQuery = query(\r\n            collection(getFirestore(), 'posts'),\r\n            orderBy('timestamp', 'desc'),\r\n            limit(limitCount * 2), // Get more to filter\r\n          );\r\n\r\n          const descQuerySnapshot = await getDocs(descQuery);\r\n\r\n          postsWithHashtagInDesc = descQuerySnapshot.docs\r\n            .filter(doc => {\r\n              // Skip if already in array-contains results\r\n              if (hashtagArrayPostIds.has(doc.id)) return false;\r\n\r\n              // Check description for hashtag\r\n              const data = doc.data();\r\n              return (data.description || '').includes(`#${hashtag}`);\r\n            })\r\n            .map(doc => {\r\n              return {\r\n                id: doc.id,\r\n                ...doc.data(),\r\n              };\r\n            });\r\n        }\r\n\r\n        // Process results after all queries\r\n        let snapshot;\r\n        if (postsWithHashtagInDesc.length > 0) {\r\n          // We need to combine results and sort them\r\n          const allPosts = [...hashtagArrayPosts, ...postsWithHashtagInDesc];\r\n\r\n          // Convert to PostType and filter blocked\r\n          const postsData = allPosts\r\n            .sort((a, b) => {\r\n              // Sort by timestamp descending\r\n              return b.timestamp?.seconds - a.timestamp?.seconds;\r\n            })\r\n            .slice(0, limitCount) // Limit to requested number\r\n            .filter(post => !blockedPostIds.includes(post.id))\r\n            .map(postData => {\r\n              return convertFirestorePost(\r\n                postData as FirestorePost,\r\n                currentUser.uid,\r\n              );\r\n            });\r\n\r\n          const lastDoc =\r\n            allPosts.length > 0 ? allPosts[allPosts.length - 1] : null;\r\n\r\n          // Update cache\r\n          this.queryCache.set(cacheKey, postsData);\r\n          this.queryCacheTimestamps.set(cacheKey, Date.now());\r\n\r\n          return {\r\n            success: true,\r\n            posts: postsData,\r\n            lastVisible: lastDoc,\r\n          };\r\n        } else {\r\n          snapshot = hashtagArraySnapshot;\r\n        }\r\n      } else {\r\n        // Handle normal query without hashtag\r\n        const queryConstraints = [\r\n          orderBy('timestamp', 'desc'),\r\n          limit(limitCount),\r\n        ];\r\n\r\n        if (timeRange) {\r\n          // Add time range filter if specified\r\n          const rangeStart = this.getTimeRangeStart(timeRange);\r\n          queryConstraints.unshift(where('timestamp', '>=', rangeStart));\r\n        }\r\n\r\n        postsQuery = query(\r\n          collection(getFirestore(), 'posts'),\r\n          ...queryConstraints,\r\n        );\r\n\r\n        const snapshot = await getDocs(postsQuery);\r\n\r\n        // Process query results\r\n        const postsData = snapshot.docs\r\n          .filter(doc => !blockedPostIds.includes(doc.id))\r\n          .map(doc => {\r\n            const postData = {id: doc.id, ...doc.data()} as FirestorePost;\r\n            return convertFirestorePost(postData, currentUser.uid);\r\n          });\r\n\r\n        const lastDoc =\r\n          snapshot.docs.length > 0\r\n            ? snapshot.docs[snapshot.docs.length - 1]\r\n            : null;\r\n\r\n        // Update cache\r\n        this.queryCache.set(cacheKey, postsData);\r\n        this.queryCacheTimestamps.set(cacheKey, Date.now());\r\n\r\n        return {\r\n          success: true,\r\n          posts: postsData,\r\n          lastVisible: lastDoc,\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.error('Error getting posts:', error);\r\n      return {success: false, error: 'Failed to fetch posts'};\r\n    }\r\n  }\r\n\r\n  async getPostsBySearch(searchText: string): Promise<GetPostsResponse> {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) throw new Error('User not authenticated');\r\n\r\n      // Get the user's blocked post IDs\r\n      const userRef = doc(collection(getFirestore(), 'users'), currentUser.uid);\r\n      const userDoc = await getDoc(userRef);\r\n      const blockedPostIds = userDoc.exists()\r\n        ? userDoc.data()?.blockedPostIds || []\r\n        : [];\r\n\r\n      const cacheKey = this.getCacheKey({\r\n        type: 'search',\r\n        searchText: searchText.toLowerCase(),\r\n      });\r\n\r\n      if (this.isQueryCacheValid(cacheKey)) {\r\n        const cachedPosts = this.queryCache.get(cacheKey);\r\n        if (cachedPosts) {\r\n          // Filter out blocked posts from cache\r\n          const filteredPosts = cachedPosts.filter(\r\n            post => !blockedPostIds.includes(post.id),\r\n          );\r\n          return {success: true, posts: filteredPosts, lastVisible: null};\r\n        }\r\n      }\r\n\r\n      const searchWords = searchText\r\n        .toLowerCase()\r\n        .split(/\\s+/)\r\n        .filter(word => word.length > 0);\r\n\r\n      let postsQuery = query(collection(getFirestore(), 'posts'));\r\n\r\n      if (searchWords.length > 0) {\r\n        // Use array-contains-any to match any of the search words\r\n        postsQuery = query(\r\n          collection(getFirestore(), 'posts'),\r\n          where('searchKeywords', 'array-contains-any', searchWords),\r\n          orderBy('timestamp', 'desc'),\r\n          limit(20),\r\n        );\r\n      } else {\r\n        postsQuery = query(\r\n          collection(getFirestore(), 'posts'),\r\n          orderBy('timestamp', 'desc'),\r\n          limit(20),\r\n        );\r\n      }\r\n\r\n      const postsSnapshot = await getDocs(postsQuery);\r\n      const lastVisibleDoc = postsSnapshot.docs[postsSnapshot.docs.length - 1];\r\n\r\n      const posts = await Promise.all(\r\n        postsSnapshot.docs\r\n          .filter(doc => !blockedPostIds.includes(doc.id)) // Filter out blocked posts\r\n          .map(async doc => {\r\n            const postData = {id: doc.id, ...doc.data()} as FirestorePost;\r\n            const likedBy = postData.likedBy || [];\r\n            const comments = await this.commentService.getPostComments(doc.ref);\r\n            postData.commentsList = comments;\r\n            postData.comments = comments.length;\r\n            this.likeCache.setPostLikes(doc.id, likedBy);\r\n            return convertFirestorePost(postData, currentUser.uid);\r\n          }),\r\n      );\r\n\r\n      this.queryCache.set(cacheKey, posts);\r\n      this.queryCacheTimestamps.set(cacheKey, Date.now());\r\n\r\n      return {success: true, posts, lastVisible: lastVisibleDoc};\r\n    } catch (error) {\r\n      console.error('PostQueryService :: getPostsBySearch ::', error);\r\n      return {success: false, error: 'Failed to fetch posts'};\r\n    }\r\n  }\r\n\r\n  cleanup() {\r\n    this.queryCache.clear();\r\n    this.queryCacheTimestamps.clear();\r\n    this.activeListeners.forEach(unsubscribe => unsubscribe());\r\n    this.activeListeners.clear();\r\n  }\r\n\r\n  // Helper function to determine the start date for a time range filter\r\n  private getTimeRangeStart(\r\n    timeRange: 'day' | 'week' | 'month' | 'year',\r\n  ): Date {\r\n    const now = new Date();\r\n    let startDate = new Date();\r\n\r\n    switch (timeRange) {\r\n      case 'day':\r\n        startDate.setDate(now.getDate() - 1);\r\n        break;\r\n      case 'week':\r\n        startDate.setDate(now.getDate() - 7);\r\n        break;\r\n      case 'month':\r\n        startDate.setMonth(now.getMonth() - 1);\r\n        break;\r\n      case 'year':\r\n        startDate.setFullYear(now.getFullYear() - 1);\r\n        break;\r\n    }\r\n\r\n    return startDate;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\firebase\\PostService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\firebase\\TrendingService.ts","messages":[{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'query' is already declared in the upper scope on line 5 column 3.","line":20,"column":23,"nodeType":"Identifier","messageId":"noShadow","endLine":20,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {getAuth} from '@react-native-firebase/auth';\r\nimport {\r\n  getFirestore,\r\n  collection,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  getDocs,\r\n  limit as fs_limit,\r\n} from '@react-native-firebase/firestore';\r\nimport {GetPostsResponse} from 'shared/types/firebase';\r\nimport {FirestorePost} from '@/features/Home/types/post';\r\nimport {convertFirestorePost} from 'shared/services/utils';\r\n\r\nexport class TrendingService {\r\n  private queryCache: Map<string, any[]> = new Map();\r\n  private readonly QUERY_CACHE_TTL = 30 * 1000; // 30 seconds TTL\r\n  private queryCacheTimestamps: Map<string, number> = new Map();\r\n\r\n  private getCacheKey(query: any): string {\r\n    return JSON.stringify(query);\r\n  }\r\n\r\n  private isQueryCacheValid(cacheKey: string): boolean {\r\n    const timestamp = this.queryCacheTimestamps.get(cacheKey);\r\n    return timestamp ? Date.now() - timestamp < this.QUERY_CACHE_TTL : false;\r\n  }\r\n\r\n  async getTrendingPosts(\r\n    timeRange: 'day' | 'week' = 'day',\r\n    limit = 10,\r\n  ): Promise<GetPostsResponse> {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) {\r\n        return {success: false, error: 'User not authenticated'};\r\n      }\r\n\r\n      const cacheKey = `trending_${timeRange}_${limit}`;\r\n\r\n      if (this.isQueryCacheValid(cacheKey)) {\r\n        const cachedPosts = this.queryCache.get(cacheKey);\r\n        if (cachedPosts) {\r\n          return {success: true, posts: cachedPosts};\r\n        }\r\n      }\r\n\r\n      const startDate = new Date();\r\n      if (timeRange === 'week') {\r\n        startDate.setDate(startDate.getDate() - 7);\r\n      } else {\r\n        startDate.setDate(startDate.getDate() - 1);\r\n      }\r\n\r\n      const postsSnapshot = await getDocs(\r\n        query(\r\n          collection(getFirestore(), 'posts'),\r\n          where('timestamp', '>=', startDate),\r\n          orderBy('timestamp', 'desc'),\r\n          orderBy('likes', 'desc'),\r\n          fs_limit(limit),\r\n        ),\r\n      );\r\n\r\n      const posts = postsSnapshot.docs.map(doc => {\r\n        const postData = {id: doc.id, ...doc.data()} as FirestorePost;\r\n        return convertFirestorePost(postData, currentUser.uid);\r\n      });\r\n\r\n      // Update cache\r\n      this.queryCache.set(cacheKey, posts);\r\n      this.queryCacheTimestamps.set(cacheKey, Date.now());\r\n\r\n      return {success: true, posts};\r\n    } catch (error) {\r\n      console.error('TrendingService :: getTrendingPosts() ::', error);\r\n      return {success: false, error: 'Failed to fetch trending posts'};\r\n    }\r\n  }\r\n\r\n  async getPostsByHashtag(\r\n    hashtag: string,\r\n    limit = 10,\r\n  ): Promise<GetPostsResponse & {engagementRate?: number}> {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) {\r\n        return {success: false, error: 'User not authenticated'};\r\n      }\r\n\r\n      const cacheKey = `hashtag_${hashtag}_${limit}`;\r\n\r\n      if (this.isQueryCacheValid(cacheKey)) {\r\n        const cachedPosts = this.queryCache.get(cacheKey);\r\n        if (cachedPosts) {\r\n          return {success: true, posts: cachedPosts};\r\n        }\r\n      }\r\n\r\n      // First, get posts with hashtag in the hashtags array\r\n      const arrayContainsQuery = query(\r\n        collection(getFirestore(), 'posts'),\r\n        where('hashtags', 'array-contains', hashtag),\r\n        orderBy('timestamp', 'desc'),\r\n        fs_limit(limit),\r\n      );\r\n\r\n      // Then, get posts with hashtag in the description\r\n      const descriptionQuery = query(\r\n        collection(getFirestore(), 'posts'),\r\n        orderBy('timestamp', 'desc'),\r\n        fs_limit(limit * 2), // Fetch more to filter later\r\n      );\r\n\r\n      const [arrayContainsSnapshot, descriptionSnapshot] = await Promise.all([\r\n        getDocs(arrayContainsQuery),\r\n        getDocs(descriptionQuery),\r\n      ]);\r\n\r\n      // Process posts from array-contains query\r\n      const arrayContainsPosts = arrayContainsSnapshot.docs.map(doc => {\r\n        const postData = {id: doc.id, ...doc.data()} as FirestorePost;\r\n        return convertFirestorePost(postData, currentUser.uid);\r\n      });\r\n\r\n      // Get post IDs from array-contains query to avoid duplicates\r\n      const arrayContainsPostIds = new Set(\r\n        arrayContainsPosts.map(post => post.id),\r\n      );\r\n\r\n      // Process posts from description query and filter for hashtag in description\r\n      const descriptionContainsPosts = descriptionSnapshot.docs\r\n        .filter(doc => {\r\n          // Skip posts already found in array-contains query\r\n          if (arrayContainsPostIds.has(doc.id)) return false;\r\n\r\n          // Check if description contains the hashtag\r\n          const data = doc.data();\r\n          const description = data.description || '';\r\n          return description.includes(`#${hashtag}`);\r\n        })\r\n        .map(doc => {\r\n          const postData = {id: doc.id, ...doc.data()} as FirestorePost;\r\n          return convertFirestorePost(postData, currentUser.uid);\r\n        });\r\n\r\n      // Combine both sets of posts\r\n      const allPosts = [...arrayContainsPosts, ...descriptionContainsPosts];\r\n\r\n      // Sort by timestamp and limit\r\n      const posts = allPosts\r\n        .sort((a, b) => {\r\n          // Convert string timestamps back to dates for comparison\r\n          const dateA = new Date(a.timestamp);\r\n          const dateB = new Date(b.timestamp);\r\n          return dateB.getTime() - dateA.getTime();\r\n        })\r\n        .slice(0, limit);\r\n\r\n      // Calculate engagement rate\r\n      const totalEngagement = posts.reduce(\r\n        (sum, post) => sum + post.likes + post.comments,\r\n        0,\r\n      );\r\n      const engagementRate = totalEngagement / (posts.length || 1);\r\n\r\n      // Update cache\r\n      this.queryCache.set(cacheKey, posts);\r\n      this.queryCacheTimestamps.set(cacheKey, Date.now());\r\n\r\n      return {success: true, posts, engagementRate};\r\n    } catch (error) {\r\n      console.error('TrendingService :: getPostsByHashtag() ::', error);\r\n      return {success: false, error: 'Failed to fetch posts by hashtag'};\r\n    }\r\n  }\r\n\r\n  cleanup() {\r\n    this.queryCache.clear();\r\n    this.queryCacheTimestamps.clear();\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\firebase\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\services\\utils.ts","messages":[{"ruleId":"no-unreachable","severity":2,"message":"Unreachable code.","line":128,"column":3,"nodeType":"ReturnStatement","messageId":"unreachableCode","endLine":128,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {Comment, PostType, FirestoreComment} from 'shared/types/post';\r\nimport {ImageSourcePropType} from 'react-native';\r\n\r\n// FirestoreComment now imported from types/post\r\n\r\nexport interface FirestorePost {\r\n  id: string;\r\n  user: {\r\n    id: string;\r\n    username: string;\r\n    image: string;\r\n  };\r\n  description: string;\r\n  likes: number;\r\n  hashtags: string[];\r\n  comments: number;\r\n  timestamp: any; // Firestore timestamp\r\n  postImages?: string[];\r\n  postVideo?: string;\r\n  isVideo?: boolean;\r\n  commentsList?: FirestoreComment[];\r\n  likedBy?: string[];\r\n}\r\n\r\n// Helper function to convert string URLs to ImageSourcePropType\r\nexport function toImageSource(url: string): ImageSourcePropType {\r\n  return {uri: url};\r\n}\r\n\r\n// Helper function to format timestamps\r\nexport function formatTimestamp(date: Date): string {\r\n  // Check if date is valid\r\n  if (!date || isNaN(date.getTime())) {\r\n    return 'just now';\r\n  }\r\n\r\n  const now = new Date();\r\n\r\n  // Calculate time difference in seconds without timezone adjustments\r\n  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);\r\n\r\n  // Check if the timestamp string contains negative value\r\n  if (diffInSeconds < 0) {\r\n    // For any negative time difference, always show \"just now\"\r\n    console.log('Negative time detected:', diffInSeconds, 'seconds');\r\n    return 'just now';\r\n  }\r\n\r\n  // Very recent timestamps\r\n  if (diffInSeconds < 15) return 'just now';\r\n  if (diffInSeconds < 60) return `${Math.abs(diffInSeconds)}s ago`;\r\n\r\n  // Minutes, hours, days, weeks\r\n  if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;\r\n  if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;\r\n  if (diffInSeconds < 604800)\r\n    return `${Math.floor(diffInSeconds / 86400)}d ago`;\r\n  if (diffInSeconds < 2419200)\r\n    return `${Math.floor(diffInSeconds / 604800)}w ago`;\r\n\r\n  // For older content, show the date\r\n  return date.toLocaleDateString('en-US', {\r\n    day: 'numeric',\r\n    month: 'short',\r\n    year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined,\r\n  });\r\n}\r\n\r\n// Helper function to convert Firestore timestamp to formatted string\r\nexport function formatFirestoreTimestamp(timestamp: any): string {\r\n  if (!timestamp) return 'just now';\r\n\r\n  try {\r\n    let date: Date | null = null;\r\n\r\n    // Handle different timestamp formats\r\n    if (timestamp.toDate && typeof timestamp.toDate === 'function') {\r\n      // Standard Firestore timestamp object with toDate() method\r\n      date = timestamp.toDate();\r\n    } else if (\r\n      timestamp._seconds !== undefined &&\r\n      timestamp._nanoseconds !== undefined\r\n    ) {\r\n      // Raw Firestore timestamp object with _seconds and _nanoseconds\r\n      date = new Date(timestamp._seconds * 1000);\r\n    } else if (timestamp instanceof Date) {\r\n      // Already a Date object\r\n      date = timestamp;\r\n    } else if (typeof timestamp === 'number') {\r\n      // Timestamp as milliseconds\r\n      date = new Date(timestamp);\r\n    } else if (typeof timestamp === 'string') {\r\n      // Check for the special Firestore timestamp format \"v2025-04-11T16:37:14.111Z\"\r\n      if (\r\n        timestamp.startsWith('v') &&\r\n        timestamp.includes('T') &&\r\n        timestamp.includes('Z')\r\n      ) {\r\n        // Remove the 'v' prefix and parse as ISO string\r\n        const isoString = timestamp.substring(1);\r\n        date = new Date(isoString);\r\n      } else if (isNaN(Date.parse(timestamp))) {\r\n        // Not a valid date string, just show as text\r\n        return timestamp;\r\n      } else {\r\n        // Standard ISO string or other parseable date format\r\n        date = new Date(timestamp);\r\n      }\r\n    }\r\n\r\n    if (!date || isNaN(date.getTime())) {\r\n      return 'just now';\r\n    }\r\n\r\n    // Ensure the date is not in the future\r\n    const now = new Date();\r\n    if (date.getTime() > now.getTime()) {\r\n      return 'just now';\r\n    }\r\n\r\n    return formatTimestamp(date);\r\n  } catch (error) {\r\n    console.error('Error formatting timestamp:', error, timestamp);\r\n    return 'just now';\r\n  }\r\n\r\n  // Fallback for unknown format\r\n  return 'just now';\r\n}\r\n\r\n// Helper function to convert FirestoreComment to Comment\r\nexport function convertFirestoreComment(comment: FirestoreComment): Comment {\r\n  // Convert replies if they exist\r\n  const convertedReplies = comment.replies\r\n    ? comment.replies.map(reply => convertFirestoreComment(reply))\r\n    : undefined;\r\n\r\n  // Extract numeric values safely for optimistic updates\r\n  const extractNumber = (val: any, fallback = 0): number => {\r\n    if (typeof val === 'number') return val;\r\n    return fallback;\r\n  };\r\n\r\n  return {\r\n    ...comment,\r\n    likes: extractNumber(comment.likes),\r\n    userImage: comment.userImage, // Keep as string as required by Comment interface\r\n    timestamp: formatFirestoreTimestamp(comment.timestamp),\r\n    isLiked: false,\r\n    replies: convertedReplies,\r\n  };\r\n}\r\n\r\n// Helper function to extract hashtags from description\r\nexport function extractHashtagsFromText(text: string): string[] {\r\n  if (!text) return [];\r\n\r\n  // Regex to match hashtags\r\n  const hashtagRegex = /#[\\w]+/g;\r\n  const matches = text.match(hashtagRegex) || [];\r\n\r\n  // Remove the # symbol and filter out empty strings\r\n  return matches\r\n    .map(tag => tag.replace('#', '').trim())\r\n    .filter(tag => tag.length > 0);\r\n}\r\n\r\n// Helper function to convert FirestorePost to PostType\r\nexport function convertFirestorePost(\r\n  postData: FirestorePost,\r\n  currentUserId: string,\r\n): PostType {\r\n  // Convert post images if they exist\r\n  const convertedPostImages = postData.postImages\r\n    ? postData.postImages.map(img => toImageSource(img))\r\n    : undefined;\r\n\r\n  // Ensure hashtags is always an array even if it's undefined or null\r\n  let hashtags = Array.isArray(postData.hashtags)\r\n    ? [...postData.hashtags] // Create a copy to avoid reference issues\r\n    : [];\r\n\r\n  // Extract hashtags from description and combine with existing hashtags\r\n  if (postData.description) {\r\n    const extractedTags = extractHashtagsFromText(postData.description);\r\n    if (extractedTags.length > 0) {\r\n      // Combine both arrays and remove duplicates\r\n      hashtags = [...new Set([...hashtags, ...extractedTags])];\r\n    }\r\n  }\r\n\r\n  console.log(`Converting post ${postData.id} with hashtags:`, hashtags);\r\n\r\n  // Extract numeric values, handle Firebase FieldValue objects from optimistic updates\r\n  const extractNumber = (val: any, fallback = 0): number => {\r\n    if (typeof val === 'number') return val;\r\n    return fallback; // When val is an optimistic FieldValue (like increment), default it\r\n  };\r\n\r\n  // Handle FieldValue.arrayUnion optimistic updates\r\n  const isLikedVal = Array.isArray(postData.likedBy)\r\n    ? postData.likedBy.includes(currentUserId)\r\n    : false;\r\n\r\n  return {\r\n    id: postData.id,\r\n    user: {\r\n      id: postData.user.id,\r\n      username: postData.user.username,\r\n      image: toImageSource(postData.user.image), // Convert string to ImageSourcePropType\r\n    },\r\n    description: postData.description,\r\n    likes: extractNumber(postData.likes),\r\n    comments: extractNumber(postData.comments),\r\n    timestamp: formatFirestoreTimestamp(postData.timestamp),\r\n    postImages: convertedPostImages, // Use converted images array\r\n    postVideo: postData.postVideo,\r\n    hashtags: hashtags, // Use the combined hashtags array\r\n    isVideo: postData.isVideo,\r\n    commentsList: postData.commentsList?.map(convertFirestoreComment),\r\n    isLiked: isLikedVal,\r\n    isSaved: false, // Adding missing required property\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\store\\store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\styles\\App.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\styles\\Home.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\types\\authTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\types\\bottomTabBarTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\types\\firebase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\types\\post.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\types\\responses.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\types\\taskTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\types\\userType.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\utils\\FCMTokenManager.ts","messages":[{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'doc' is already declared in the upper scope on line 5 column 3.","line":178,"column":29,"nodeType":"Identifier","messageId":"noShadow","endLine":178,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {getAuth} from '@react-native-firebase/auth';\r\nimport {\r\n  getFirestore,\r\n  collection,\r\n  doc,\r\n  setDoc,\r\n  updateDoc,\r\n  deleteDoc,\r\n  query,\r\n  where,\r\n  getDocs,\r\n  serverTimestamp,\r\n  writeBatch,\r\n  FirebaseFirestoreTypes,\r\n} from '@react-native-firebase/firestore';\r\nimport {Platform} from 'react-native';\r\n\r\n/**\r\n * Manages FCM tokens for the current user, storing them in Firestore\r\n * This allows the server to send targeted notifications to specific devices\r\n *\r\n * We use a direct device-to-device messaging approach rather than topic-based messaging:\r\n * 1. Each device's FCM token is stored in Firestore with the user's ID\r\n * 2. When sending a notification, we retrieve all tokens for the recipient\r\n * 3. The notification is sent directly to each specific device token\r\n * 4. This approach is better for direct messages as it's more targeted than topics\r\n *\r\n * IMPORTANT: Tokens are preserved even when the app is closed or the user logs out\r\n * to ensure notifications can still be delivered in these states.\r\n */\r\nexport class FCMTokenManager {\r\n  private static tokensCollection = collection(\r\n    getFirestore(),\r\n    'fcmTokens',\r\n  ) as FirebaseFirestoreTypes.CollectionReference<any>;\r\n\r\n  /**\r\n   * Save a new FCM token for the current user\r\n   * This should be called after getting a new token from Firebase\r\n   *\r\n   * @param token The FCM token to save\r\n   * @returns Promise that resolves to true if successful\r\n   */\r\n  public static async saveToken(token: string): Promise<boolean> {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) {\r\n        console.error('Cannot save FCM token: No user is logged in');\r\n        return false;\r\n      }\r\n\r\n      const userId = currentUser.uid;\r\n\r\n      // Get device info in a type-safe way\r\n      const deviceInfo = {\r\n        platform: Platform.OS,\r\n        // Handle model safely with optional chaining and type assertion\r\n        model:\r\n          Platform.OS === 'android'\r\n            ? (Platform.constants as any)?.model || 'Unknown'\r\n            : 'iOS Device',\r\n        version: Platform.Version,\r\n      };\r\n\r\n      // Create a unique ID for this device's token\r\n      // This allows a user to have multiple devices\r\n      const tokenDoc = {\r\n        userId,\r\n        token,\r\n        device: deviceInfo,\r\n        active: true, // Mark the token as active\r\n        createdAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp(),\r\n      };\r\n\r\n      // We'll use the token itself as part of the document ID\r\n      // to ensure we don't store duplicate tokens\r\n      const tokenId = `${userId}_${token.substring(token.length - 12)}`;\r\n\r\n      await setDoc(doc(this.tokensCollection, tokenId), tokenDoc);\r\n      console.log('FCM token saved to Firestore');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error saving FCM token:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark a token as inactive instead of removing it\r\n   * This preserves the token for background notifications but helps\r\n   * track which tokens are from active app instances\r\n   *\r\n   * @param token The FCM token to mark as inactive\r\n   * @returns Promise that resolves to true if successful\r\n   */\r\n  public static async markTokenInactive(token: string): Promise<boolean> {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) {\r\n        console.log('No user logged in to update FCM token status');\r\n        return false;\r\n      }\r\n\r\n      const userId = currentUser.uid;\r\n      const tokenId = `${userId}_${token.substring(token.length - 12)}`;\r\n\r\n      await updateDoc(doc(this.tokensCollection, tokenId), {\r\n        active: false,\r\n        updatedAt: serverTimestamp(),\r\n      });\r\n\r\n      console.log('FCM token marked as inactive');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error marking FCM token as inactive:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove an FCM token when a user logs out\r\n   * NOTE: This method is no longer used in the regular flow to ensure\r\n   * notifications can be delivered even when the app is closed\r\n   *\r\n   * @param token The FCM token to remove\r\n   * @returns Promise that resolves to true if successful\r\n   */\r\n  public static async removeToken(token: string): Promise<boolean> {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) {\r\n        console.log('No user logged in to remove FCM token for');\r\n        return false;\r\n      }\r\n\r\n      const userId = currentUser.uid;\r\n      const tokenId = `${userId}_${token.substring(token.length - 12)}`;\r\n\r\n      await deleteDoc(doc(this.tokensCollection, tokenId));\r\n      console.log('FCM token removed from Firestore');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error removing FCM token:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove all FCM tokens for the current user\r\n   * NOTE: This method should only be used in specific cleanup operations,\r\n   * not during normal app usage, to ensure background notifications work\r\n   *\r\n   * @returns Promise that resolves to true if successful\r\n   */\r\n  public static async removeAllUserTokens(): Promise<boolean> {\r\n    try {\r\n      const currentUser = getAuth().currentUser;\r\n      if (!currentUser) {\r\n        console.log('No user logged in to remove FCM tokens for');\r\n        return false;\r\n      }\r\n\r\n      const userId = currentUser.uid;\r\n      const batch = writeBatch(getFirestore());\r\n\r\n      // Get all tokens for this user\r\n      const snapshot = await getDocs(\r\n        query(this.tokensCollection, where('userId', '==', userId)),\r\n      );\r\n\r\n      if (snapshot.empty) {\r\n        console.log('No FCM tokens found for this user');\r\n        return true;\r\n      }\r\n\r\n      // Add each token document to the batch for deletion\r\n      snapshot.docs.forEach(doc => {\r\n        batch.delete(doc.ref);\r\n      });\r\n\r\n      // Commit the batch delete\r\n      await batch.commit();\r\n      console.log(`Removed ${snapshot.size} FCM tokens for the user`);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error removing all FCM tokens:', error);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\utils\\LexAI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\utils\\PushNotificationHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\utils\\UserInterface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\utils\\cloudinary.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]},{"filePath":"D:\\Capstone_Project\\Learnex\\src\\shared\\utils\\toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-negated-in-lhs","replacedBy":[]},{"ruleId":"no-catch-shadow","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":[]}]}]
(Use `node --trace-warnings ...` to show where the warning was created)
